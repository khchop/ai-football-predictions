---
phase: 49-pipeline-scheduling-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/queue/scheduler.ts
  - src/lib/queue/workers/fixtures.worker.ts
autonomous: true

must_haves:
  truths:
    - "After server restart, scheduleMatchJobs() schedules jobs for matches where kickoff <= now (past-due matches)"
    - "Fixtures worker schedules jobs for existing matches that have no active/delayed BullMQ jobs, not just new matches"
    - "Scheduler still skips matches with no externalId"
    - "Idempotent job IDs prevent duplicate scheduling across catch-up, fixtures, and backfill code paths"
  artifacts:
    - path: "src/lib/queue/scheduler.ts"
      provides: "scheduleMatchJobs without early exit on kickoff <= now"
      contains: "lateRunnableJobs"
    - path: "src/lib/queue/workers/fixtures.worker.ts"
      provides: "Job scheduling for both new and existing scheduled matches"
      contains: "scheduleMatchJobs"
  key_links:
    - from: "src/lib/queue/catch-up.ts"
      to: "src/lib/queue/scheduler.ts"
      via: "catchUpScheduling calls scheduleMatchJobs for 48h window matches"
      pattern: "scheduleMatchJobs"
    - from: "src/lib/queue/workers/fixtures.worker.ts"
      to: "src/lib/queue/scheduler.ts"
      via: "fixtures worker calls scheduleMatchJobs for existing+new matches"
      pattern: "scheduleMatchJobs"
---

<objective>
Fix the two root causes that prevent job scheduling for existing/past-due matches: (1) remove the early exit in scheduleMatchJobs() that blocks scheduling when kickoff <= now, and (2) make fixtures worker schedule jobs for existing matches that are missing BullMQ jobs, not only new matches.

Purpose: These two bugs are the primary reason matches go unserved after server restarts. The scheduler's early exit (line 113) prevents catch-up from working, and the fixtures worker's isNewMatch check (line 90) prevents re-scheduling for known matches. Together they create a gap where matches within 48h get no analysis/predictions/lineups.

Output: Modified scheduler.ts and fixtures.worker.ts that handle past-due and existing matches correctly.
</objective>

<execution_context>
@/Users/pieterbos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/49-pipeline-scheduling-fixes/49-RESEARCH.md
@src/lib/queue/scheduler.ts
@src/lib/queue/catch-up.ts
@src/lib/queue/workers/fixtures.worker.ts
@src/instrumentation.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Remove early exit in scheduleMatchJobs and add status-based guard</name>
  <files>src/lib/queue/scheduler.ts</files>
  <action>
    In `scheduleMatchJobs()` (line 107-277):

    1. **Remove the early exit block** (lines 112-116):
       ```typescript
       // REMOVE THIS ENTIRE BLOCK:
       // if (kickoff <= now) {
       //   log.info({ matchId: match.id }, 'Match already started, skipping job scheduling');
       //   return 0;
       // }
       ```

    2. **Add a match-status-aware guard instead** -- only skip matches that are already `finished` or `cancelled`:
       ```typescript
       // Skip finished/cancelled matches (they don't need new jobs)
       if (match.status === 'finished' || match.status === 'cancelled' || match.status === 'postponed') {
         log.info({ matchId: match.id, status: match.status, homeTeam: match.homeTeam, awayTeam: match.awayTeam }, 'Match not schedulable (status), skipping job scheduling');
         return 0;
       }
       ```

    3. **Keep the existing `shouldRun` logic on line 249 INTACT.** Do NOT modify this line:
       ```typescript
       const shouldRun = job.name === JOB_TYPES.MONITOR_LIVE || kickoff > now;
       ```
       This logic correctly distinguishes between pre-match jobs (analysis, lineups, predictions -- should only run if kickoff hasn't passed) and MONITOR_LIVE (should run for in-progress matches). The early exit removal at step 1 allows past-due matches to ENTER the function, and the existing lateRunnableJobs logic correctly handles them: pre-match jobs run with 1s delay when kickoff > now, and MONITOR_LIVE runs for in-progress matches. This is the correct behavior.

    4. **Keep all other existing logic intact:** The idempotent job ID checks (lines 207-222), dynamic priority calculation, lateRunnableJobs set, and race condition handling are all correct and should not be changed.
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify no type errors in scheduler.ts.
    Verify the early exit `if (kickoff <= now)` is removed by grepping for it.
    Verify the status-based guard is present by grepping for `match.status === 'finished'`.
    Verify `shouldRun` line still contains `kickoff > now` (unchanged).
  </verify>
  <done>
    scheduleMatchJobs() no longer returns early when kickoff <= now. Past-due matches with status 'scheduled' enter the function and get their pre-match jobs scheduled (if kickoff > now via existing shouldRun logic) or MONITOR_LIVE scheduled (if match is in progress). Finished/cancelled/postponed matches are skipped via the new status guard.
  </done>
</task>

<task type="auto">
  <name>Task 2: Make fixtures worker schedule jobs for existing matches missing BullMQ jobs</name>
  <files>src/lib/queue/workers/fixtures.worker.ts</files>
  <action>
    In `createFixturesWorker()`, modify the job scheduling logic around line 89-129:

    1. **Restructure the `isNewMatch` block** so that IndexNow stays inside it but `scheduleMatchJobs` moves outside. Currently both `newMatchUrls.push(...)` and `scheduleMatchJobs(...)` are gated by `isNewMatch`. Change to two separate blocks:

       ```typescript
       // After upsertMatch...
       savedFixtures++;

       // Only ping IndexNow for genuinely NEW matches
       if (isNewMatch) {
         newMatchUrls.push(`https://kroam.xyz/leagues/${competition.id}/${slug}`);
       }

       // Schedule jobs for ALL scheduled matches (idempotent - skips if jobs exist)
       // This ensures existing matches that lost BullMQ jobs after restart get re-scheduled
       if (mapFixtureStatus(fixture.fixture.status.short) === 'scheduled') {
         const scheduled = await scheduleMatchJobs({
           match: { ... },  // Keep existing match object construction
           competition: { ... },  // Keep existing competition object construction
         });
         jobsScheduled += scheduled;
       }
       ```

       Key points:
       - `newMatchUrls.push(...)` STAYS inside the `if (isNewMatch)` block (IndexNow only for new matches)
       - `scheduleMatchJobs(...)` moves OUTSIDE the `isNewMatch` block, into its own `if (status === 'scheduled')` block
       - The `isNewMatch` variable is still needed and must NOT be removed

    2. **Add a log line** to distinguish new vs existing match scheduling:
       ```typescript
       if (scheduled > 0) {
         log.info({ matchId: actualMatchId, homeTeam: fixture.teams.home.name, awayTeam: fixture.teams.away.name, isNewMatch }, 'Scheduled jobs via fixtures worker');
       }
       ```
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify no type errors.
    Grep fixtures.worker.ts to confirm `scheduleMatchJobs` call is NOT inside an `isNewMatch` conditional.
    Grep to confirm `isNewMatch` is still used for `newMatchUrls` (IndexNow ping).
  </verify>
  <done>
    Fixtures worker calls scheduleMatchJobs for ALL scheduled matches (new and existing). IndexNow ping still only fires for new matches. Existing matches that lost their BullMQ jobs after a restart will get them re-scheduled on the next fixtures fetch (every 3 hours).
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npx tsc --noEmit` passes with zero errors
2. `npm run build --webpack 2>&1 | tail -20` succeeds (production build check)
3. Grep confirms: no `kickoff <= now` early exit in scheduler.ts
4. Grep confirms: `match.status === 'finished'` guard exists in scheduler.ts
5. Grep confirms: `shouldRun` line still contains `kickoff > now` (preserved)
6. Grep confirms: no `isNewMatch &&` before `scheduleMatchJobs` in fixtures.worker.ts
</verification>

<success_criteria>
- scheduleMatchJobs() handles past-due matches by entering the function (not skipping)
- Existing shouldRun logic preserved: pre-match jobs run when kickoff > now, MONITOR_LIVE runs for in-progress matches
- Fixtures worker schedules for both new and existing matches
- No type errors or build failures introduced
- Idempotent job IDs prevent duplicate scheduling (existing behavior preserved)
- PIPE-01 and PIPE-02 requirements addressed
</success_criteria>

<output>
After completion, create `.planning/phases/49-pipeline-scheduling-fixes/49-01-SUMMARY.md`
</output>
