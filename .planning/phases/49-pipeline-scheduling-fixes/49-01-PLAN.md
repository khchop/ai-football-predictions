---
phase: 49-pipeline-scheduling-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/queue/scheduler.ts
  - src/lib/queue/workers/fixtures.worker.ts
autonomous: true

must_haves:
  truths:
    - "After server restart, scheduleMatchJobs() schedules jobs for matches where kickoff <= now (past-due matches)"
    - "Fixtures worker schedules jobs for existing matches that have no active/delayed BullMQ jobs, not just new matches"
    - "Scheduler still skips matches with no externalId"
    - "Idempotent job IDs prevent duplicate scheduling across catch-up, fixtures, and backfill code paths"
  artifacts:
    - path: "src/lib/queue/scheduler.ts"
      provides: "scheduleMatchJobs without early exit on kickoff <= now"
      contains: "lateRunnableJobs"
    - path: "src/lib/queue/workers/fixtures.worker.ts"
      provides: "Job scheduling for both new and existing scheduled matches"
      contains: "scheduleMatchJobs"
  key_links:
    - from: "src/lib/queue/catch-up.ts"
      to: "src/lib/queue/scheduler.ts"
      via: "catchUpScheduling calls scheduleMatchJobs for 48h window matches"
      pattern: "scheduleMatchJobs"
    - from: "src/lib/queue/workers/fixtures.worker.ts"
      to: "src/lib/queue/scheduler.ts"
      via: "fixtures worker calls scheduleMatchJobs for existing+new matches"
      pattern: "scheduleMatchJobs"
---

<objective>
Fix the two root causes that prevent job scheduling for existing/past-due matches: (1) remove the early exit in scheduleMatchJobs() that blocks scheduling when kickoff <= now, and (2) make fixtures worker schedule jobs for existing matches that are missing BullMQ jobs, not only new matches.

Purpose: These two bugs are the primary reason matches go unserved after server restarts. The scheduler's early exit (line 113) prevents catch-up from working, and the fixtures worker's isNewMatch check (line 90) prevents re-scheduling for known matches. Together they create a gap where matches within 48h get no analysis/predictions/lineups.

Output: Modified scheduler.ts and fixtures.worker.ts that handle past-due and existing matches correctly.
</objective>

<execution_context>
@/Users/pieterbos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/49-pipeline-scheduling-fixes/49-RESEARCH.md
@src/lib/queue/scheduler.ts
@src/lib/queue/catch-up.ts
@src/lib/queue/workers/fixtures.worker.ts
@src/instrumentation.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Remove early exit in scheduleMatchJobs and handle past-due jobs correctly</name>
  <files>src/lib/queue/scheduler.ts</files>
  <action>
    In `scheduleMatchJobs()` (line 107-277):

    1. **Remove the early exit block** (lines 112-116):
       ```typescript
       // REMOVE THIS ENTIRE BLOCK:
       // if (kickoff <= now) {
       //   log.info({ matchId: match.id }, 'Match already started, skipping job scheduling');
       //   return 0;
       // }
       ```

    2. **Add a match-status-aware guard instead** — only skip matches that are already `finished` or `cancelled`:
       ```typescript
       // Skip finished/cancelled matches (they don't need new jobs)
       if (match.status === 'finished' || match.status === 'cancelled' || match.status === 'postponed') {
         log.debug({ matchId: match.id, status: match.status }, 'Match not schedulable, skipping');
         return 0;
       }
       ```

    3. **For past-due jobs (delay <= 0):** The existing `lateRunnableJobs` logic on lines 197-268 already handles this correctly — it schedules with 1s delay for past-due pre-kickoff jobs. However, note that line 249 has a bug:
       ```typescript
       // Line 249 CURRENT (BUG): Only runs late jobs if kickoff > now
       const shouldRun = job.name === JOB_TYPES.MONITOR_LIVE || kickoff > now;
       ```
       This defeats the purpose for past-due matches. Fix to:
       ```typescript
       // Run past-due pre-match jobs for scheduled matches (analysis, lineups, predictions)
       // Run live monitoring for matches that have started but aren't finished
       const shouldRun = true; // All late-runnable jobs should execute if match is schedulable
       ```
       The match-status guard at the top already filters out finished matches, so all remaining matches in this function are valid candidates for late job execution.

    4. **Keep all other existing logic intact:** The idempotent job ID checks (lines 207-222), dynamic priority calculation, and race condition handling are all correct and should not be changed.

    5. **Update the log message** for the status guard to be informative:
       ```typescript
       log.info({ matchId: match.id, status: match.status, homeTeam: match.homeTeam, awayTeam: match.awayTeam }, 'Match not schedulable (status), skipping job scheduling');
       ```
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify no type errors in scheduler.ts.
    Verify the early exit `if (kickoff <= now)` is removed by grepping for it.
    Verify the status-based guard is present by grepping for `match.status === 'finished'`.
  </verify>
  <done>
    scheduleMatchJobs() no longer returns early when kickoff <= now. Past-due matches with status 'scheduled' or 'live' get their jobs scheduled with 1s delay. Only finished/cancelled/postponed matches are skipped.
  </done>
</task>

<task type="auto">
  <name>Task 2: Make fixtures worker schedule jobs for existing matches missing BullMQ jobs</name>
  <files>src/lib/queue/workers/fixtures.worker.ts</files>
  <action>
    In `createFixturesWorker()`, modify the job scheduling logic around line 89-129:

    1. **Replace the `isNewMatch` gate** on line 90 with a status-only check. Currently:
       ```typescript
       if (isNewMatch && mapFixtureStatus(fixture.fixture.status.short) === 'scheduled') {
       ```
       Change to:
       ```typescript
       if (mapFixtureStatus(fixture.fixture.status.short) === 'scheduled') {
       ```
       This means ALL scheduled matches (new and existing) will have `scheduleMatchJobs()` called. The idempotent job ID pattern in `scheduleMatchJobs()` already handles the case where jobs exist — it checks `getJob(jobId)` and skips if `active/waiting/delayed`.

    2. **Move the IndexNow ping** so it only triggers for genuinely new matches. Currently `newMatchUrls.push(...)` is inside the `isNewMatch` block (which we're removing). Restructure:
       ```typescript
       // After upsertMatch...
       savedFixtures++;

       // Only ping IndexNow for NEW matches
       if (isNewMatch) {
         newMatchUrls.push(`https://kroam.xyz/leagues/${competition.id}/${slug}`);
       }

       // Schedule jobs for ALL scheduled matches (idempotent - skips if jobs exist)
       if (mapFixtureStatus(fixture.fixture.status.short) === 'scheduled') {
         const scheduled = await scheduleMatchJobs({
           match: { ... },  // Keep existing match object construction
           competition: { ... },  // Keep existing competition object construction
         });
         jobsScheduled += scheduled;
       }
       ```

    3. **Keep the `isNewMatch` variable** — it's still needed for IndexNow ping logic. Do NOT remove it.

    4. **Add a log line** to distinguish new vs existing match scheduling:
       ```typescript
       if (scheduled > 0) {
         log.info({ matchId: actualMatchId, homeTeam: fixture.teams.home.name, awayTeam: fixture.teams.away.name, isNewMatch }, 'Scheduled jobs via fixtures worker');
       }
       ```
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify no type errors.
    Grep fixtures.worker.ts to confirm `isNewMatch &&` is no longer gating `scheduleMatchJobs`.
    Grep to confirm `isNewMatch` is still used for IndexNow ping.
  </verify>
  <done>
    Fixtures worker calls scheduleMatchJobs for ALL scheduled matches (new and existing). IndexNow ping still only fires for new matches. Existing matches that lost their BullMQ jobs after a restart will get them re-scheduled on the next fixtures fetch (every 3 hours).
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npx tsc --noEmit` passes with zero errors
2. `npm run build --webpack 2>&1 | tail -20` succeeds (production build check)
3. Grep confirms: no `kickoff <= now` early exit in scheduler.ts
4. Grep confirms: `match.status === 'finished'` guard exists in scheduler.ts
5. Grep confirms: no `isNewMatch &&` before `scheduleMatchJobs` in fixtures.worker.ts
</verification>

<success_criteria>
- scheduleMatchJobs() handles past-due matches by scheduling with 1s delay (not skipping)
- Fixtures worker schedules for both new and existing matches
- No type errors or build failures introduced
- Idempotent job IDs prevent duplicate scheduling (existing behavior preserved)
- PIPE-01 and PIPE-02 requirements addressed
</success_criteria>

<output>
After completion, create `.planning/phases/49-pipeline-scheduling-fixes/49-01-SUMMARY.md`
</output>
