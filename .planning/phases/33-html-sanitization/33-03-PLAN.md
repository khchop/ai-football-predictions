---
phase: 33-html-sanitization
plan: 03
type: execute
wave: 2
depends_on: ["33-01"]
files_modified:
  - scripts/clean-html-content.ts
autonomous: true

must_haves:
  truths:
    - "Existing content with HTML is cleaned via migration"
    - "Migration verifies no HTML remains after completion"
  artifacts:
    - path: "scripts/clean-html-content.ts"
      provides: "One-time HTML cleanup migration"
      exports: []
  key_links:
    - from: "scripts/clean-html-content.ts"
      to: "src/lib/content/sanitization.ts"
      via: "import"
      pattern: "import.*sanitizeContent.*from.*sanitization"
---

<objective>
Create and run a migration script to clean HTML from existing database content.

Purpose: Sanitize all LLM-generated content already stored in the database so match pages render without visible HTML artifacts.

Output: scripts/clean-html-content.ts that processes matchContent, blogPosts, matchPreviews, and matchRoundups tables.
</objective>

<execution_context>
@/Users/pieterbos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/33-html-sanitization/33-01-SUMMARY.md
@src/lib/content/sanitization.ts
@src/lib/db/schema.ts
@scripts/backfill-slugs.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration script</name>
  <files>scripts/clean-html-content.ts</files>
  <action>
Create `scripts/clean-html-content.ts` following the pattern from `scripts/backfill-slugs.ts`:

```typescript
import { getDb, matchContent, blogPosts, matchPreviews, matchRoundups } from '../src/lib/db';
import { sanitizeContent } from '../src/lib/content/sanitization';
import { eq, sql } from 'drizzle-orm';

/**
 * Clean HTML from existing LLM-generated content
 * Run once to sanitize all existing records
 */
async function cleanHtmlContent() {
  const db = getDb();
  console.log('Starting HTML sanitization migration...\n');

  // 1. Clean matchContent table
  console.log('Cleaning matchContent...');
  const contentRecords = await db.select().from(matchContent);
  let contentCleaned = 0;

  for (const record of contentRecords) {
    const updates: Record<string, string | null> = {};

    if (record.preMatchContent) {
      updates.preMatchContent = sanitizeContent(record.preMatchContent);
    }
    if (record.bettingContent) {
      updates.bettingContent = sanitizeContent(record.bettingContent);
    }
    if (record.postMatchContent) {
      updates.postMatchContent = sanitizeContent(record.postMatchContent);
    }
    // FAQ is JSON - sanitize each question/answer
    if (record.faqContent) {
      try {
        const faqs = JSON.parse(record.faqContent);
        const cleanFaqs = faqs.map((faq: { question: string; answer: string }) => ({
          question: sanitizeContent(faq.question),
          answer: sanitizeContent(faq.answer),
        }));
        updates.faqContent = JSON.stringify(cleanFaqs);
      } catch {
        // Skip invalid JSON
      }
    }

    if (Object.keys(updates).length > 0) {
      await db.update(matchContent)
        .set({ ...updates, updatedAt: new Date().toISOString() })
        .where(eq(matchContent.id, record.id));
      contentCleaned++;

      if (contentCleaned % 50 === 0) {
        console.log(`  Processed ${contentCleaned}/${contentRecords.length}...`);
      }
    }
  }
  console.log(`✓ Cleaned ${contentCleaned} matchContent records\n`);

  // 2. Clean blogPosts table
  console.log('Cleaning blogPosts...');
  const blogRecords = await db.select().from(blogPosts);
  let blogsCleaned = 0;

  for (const blog of blogRecords) {
    await db.update(blogPosts).set({
      title: sanitizeContent(blog.title),
      excerpt: blog.excerpt ? sanitizeContent(blog.excerpt) : null,
      content: sanitizeContent(blog.content),
      metaTitle: blog.metaTitle ? sanitizeContent(blog.metaTitle) : null,
      metaDescription: blog.metaDescription ? sanitizeContent(blog.metaDescription) : null,
      updatedAt: new Date().toISOString(),
    }).where(eq(blogPosts.id, blog.id));

    blogsCleaned++;
    if (blogsCleaned % 10 === 0) {
      console.log(`  Processed ${blogsCleaned}/${blogRecords.length}...`);
    }
  }
  console.log(`✓ Cleaned ${blogsCleaned} blogPosts records\n`);

  // 3. Clean matchPreviews table
  console.log('Cleaning matchPreviews...');
  const previewRecords = await db.select().from(matchPreviews);
  let previewsCleaned = 0;

  for (const preview of previewRecords) {
    await db.update(matchPreviews).set({
      introduction: preview.introduction ? sanitizeContent(preview.introduction) : null,
      teamFormAnalysis: preview.teamFormAnalysis ? sanitizeContent(preview.teamFormAnalysis) : null,
      headToHead: preview.headToHead ? sanitizeContent(preview.headToHead) : null,
      keyPlayers: preview.keyPlayers ? sanitizeContent(preview.keyPlayers) : null,
      tacticalAnalysis: preview.tacticalAnalysis ? sanitizeContent(preview.tacticalAnalysis) : null,
      prediction: preview.prediction ? sanitizeContent(preview.prediction) : null,
      bettingInsights: preview.bettingInsights ? sanitizeContent(preview.bettingInsights) : null,
      metaDescription: preview.metaDescription ? sanitizeContent(preview.metaDescription) : null,
      updatedAt: new Date().toISOString(),
    }).where(eq(matchPreviews.id, preview.id));

    previewsCleaned++;
    if (previewsCleaned % 10 === 0) {
      console.log(`  Processed ${previewsCleaned}/${previewRecords.length}...`);
    }
  }
  console.log(`✓ Cleaned ${previewsCleaned} matchPreviews records\n`);

  // 4. Clean matchRoundups table
  console.log('Cleaning matchRoundups...');
  const roundupRecords = await db.select().from(matchRoundups);
  let roundupsCleaned = 0;

  for (const roundup of roundupRecords) {
    await db.update(matchRoundups).set({
      title: sanitizeContent(roundup.title),
      narrative: roundup.narrative ? sanitizeContent(roundup.narrative) : null,
      modelPredictions: roundup.modelPredictions ? sanitizeContent(roundup.modelPredictions) : null,
      updatedAt: new Date(),
    }).where(eq(matchRoundups.id, roundup.id));

    roundupsCleaned++;
    if (roundupsCleaned % 10 === 0) {
      console.log(`  Processed ${roundupsCleaned}/${roundupRecords.length}...`);
    }
  }
  console.log(`✓ Cleaned ${roundupsCleaned} matchRoundups records\n`);

  // 5. Verification
  console.log('Verifying HTML removal...');
  // Note: Using raw SQL for LIKE queries
  const verificationQuery = sql`
    SELECT 'matchContent' as table_name, COUNT(*) as html_count
    FROM match_content
    WHERE pre_match_content LIKE '%<%'
       OR betting_content LIKE '%<%'
       OR post_match_content LIKE '%<%'
       OR pre_match_content LIKE '%&amp;%'
       OR betting_content LIKE '%&amp;%'
       OR post_match_content LIKE '%&amp;%'
    UNION ALL
    SELECT 'blogPosts', COUNT(*)
    FROM blog_posts
    WHERE title LIKE '%<%' OR content LIKE '%<%'
       OR title LIKE '%&amp;%' OR content LIKE '%&amp;%'
    UNION ALL
    SELECT 'matchPreviews', COUNT(*)
    FROM match_previews
    WHERE introduction LIKE '%<%' OR prediction LIKE '%<%'
       OR introduction LIKE '%&amp;%' OR prediction LIKE '%&amp;%'
    UNION ALL
    SELECT 'matchRoundups', COUNT(*)
    FROM match_roundups
    WHERE title LIKE '%<%' OR narrative LIKE '%<%'
       OR title LIKE '%&amp;%' OR narrative LIKE '%&amp;%'
  `;

  const verification = await db.execute(verificationQuery);

  console.log('\nVerification results:');
  let allClean = true;
  for (const row of verification.rows as Array<{ table_name: string; html_count: string }>) {
    const count = parseInt(row.html_count, 10);
    if (count > 0) {
      console.log(`  ⚠️  ${row.table_name}: ${count} records may still contain HTML`);
      allClean = false;
    } else {
      console.log(`  ✓ ${row.table_name}: clean`);
    }
  }

  console.log('\n' + (allClean ? '✓ Migration complete - all tables clean!' : '⚠️  Migration complete - some records may need manual review'));
}

cleanHtmlContent()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error('Migration failed:', error);
    process.exit(1);
  });
```

Note on verification: The LIKE '%<%' check may have false positives for legitimate angle brackets in text (e.g., "score > 3"). This is acceptable - the check is conservative and flags potential issues for review.
  </action>
  <verify>
    File exists at scripts/clean-html-content.ts
    npm run build passes (script compiles)
  </verify>
  <done>
    scripts/clean-html-content.ts exists
    Script imports sanitizeContent from sanitization module
    Script processes all 4 content tables
    Script includes verification query
  </done>
</task>

<task type="auto">
  <name>Task 2: Run migration script</name>
  <files>None (database operation)</files>
  <action>
1. Run the migration:
   ```
   npx tsx scripts/clean-html-content.ts
   ```

2. Observe output for:
   - Progress updates for each table
   - Verification results showing "clean" or warnings
   - Final success/warning message

3. If verification shows warnings:
   - This is expected for legitimate angle brackets
   - Not a failure unless actual HTML tags remain
  </action>
  <verify>
    Script runs to completion without errors
    Verification section shows results for all 4 tables
    No actual HTML tags remain (may have legitimate angle brackets)
  </verify>
  <done>
    Migration script executed successfully
    All 4 tables processed
    Verification confirms HTML removed
  </done>
</task>

</tasks>

<verification>
1. scripts/clean-html-content.ts exists and compiles
2. Migration runs without errors
3. Verification query shows all tables clean (or only false positives for legitimate angle brackets)
</verification>

<success_criteria>
- Migration script created following project patterns
- All existing content sanitized in database
- Verification confirms no HTML artifacts remain
</success_criteria>

<output>
After completion, create `.planning/phases/33-html-sanitization/33-02-SUMMARY.md`
</output>
