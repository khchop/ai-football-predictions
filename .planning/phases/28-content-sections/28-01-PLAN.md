---
phase: 28-content-sections
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/match/match-narrative.tsx
autonomous: true

must_haves:
  truths:
    - "Pre-match narrative renders only for upcoming matches"
    - "Post-match narrative renders only for finished matches"
    - "Live matches show pre-match narrative (keep preview visible)"
    - "Missing narrative shows placeholder message"
  artifacts:
    - path: "src/components/match/match-narrative.tsx"
      provides: "State-aware narrative display component"
      min_lines: 50
      exports: ["MatchNarrative"]
  key_links:
    - from: "src/components/match/match-narrative.tsx"
      to: "useMatch()"
      via: "context consumption"
      pattern: "useMatch\\(\\)"
    - from: "src/components/match/match-narrative.tsx"
      to: "getMatchContent"
      via: "server action or fetch"
      pattern: "getMatchContent|fetch.*content"
---

<objective>
Create MatchNarrative component that displays pre-match or post-match narrative based on match state from MatchDataProvider context.

Purpose: Deliver narrative content that renders correctly based on match state (upcoming/live/finished) per user decisions from 28-CONTEXT.md.

Output: Single MatchNarrative component that consumes context and displays appropriate narrative with state-specific headings.
</objective>

<execution_context>
@/Users/pieterbos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-content-sections/28-CONTEXT.md
@.planning/phases/28-content-sections/28-RESEARCH.md
@.planning/phases/26-context-foundation/26-01-SUMMARY.md
@.planning/phases/27-hero-component/27-01-SUMMARY.md
@src/components/match/match-data-provider.tsx
@src/components/match/use-match.ts
@src/components/match/MatchContent.tsx
@src/lib/content/queries.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MatchNarrative component</name>
  <files>src/components/match/match-narrative.tsx</files>
  <action>
Create a new client component MatchNarrative that:

1. Uses 'use client' directive (required for context consumption)
2. Consumes MatchDataProvider via useMatch() hook to get match and matchState
3. Fetches narrative content using a client-side fetch to an API route or using existing getMatchContent pattern

State-aware display logic (from 28-CONTEXT.md):
- **Upcoming matches:** Show preMatchContent with heading "Match Preview"
- **Live matches:** Show preMatchContent with heading "Match Preview" (keep preview visible during match)
- **Finished matches:** Show postMatchContent with heading "Match Report"

Component structure:
```tsx
'use client';

import { useMatch } from './use-match';
import { useEffect, useState } from 'react';
import { Card, CardContent } from '@/components/ui/card';
import { FileText } from 'lucide-react';

interface NarrativeContent {
  preMatchContent: string | null;
  postMatchContent: string | null;
}

export function MatchNarrative() {
  const { match, matchState } = useMatch();
  const [content, setContent] = useState<NarrativeContent | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    async function fetchContent() {
      try {
        const res = await fetch(`/api/matches/${match.id}/content`);
        if (res.ok) {
          const data = await res.json();
          setContent(data);
        }
      } catch (err) {
        console.error('Failed to fetch narrative:', err);
      } finally {
        setLoading(false);
      }
    }
    fetchContent();
  }, [match.id]);

  // Determine which content to show based on matchState
  const isFinished = matchState === 'finished';
  const narrativeText = isFinished ? content?.postMatchContent : content?.preMatchContent;
  const heading = isFinished ? 'Match Report' : 'Match Preview';

  // Show placeholder if no narrative available
  if (!loading && !narrativeText) {
    return (
      <Card className="bg-card/50 border-border/50">
        <CardContent className="p-6">
          <h2 className="text-xl font-bold mb-4 flex items-center gap-2">
            <FileText className="h-5 w-5 text-primary" />
            {heading}
          </h2>
          <p className="text-muted-foreground italic">
            Analysis pending - check back closer to kickoff.
          </p>
        </CardContent>
      </Card>
    );
  }

  // Loading state
  if (loading) {
    return (
      <Card className="bg-card/50 border-border/50">
        <CardContent className="p-6">
          <div className="animate-pulse space-y-3">
            <div className="h-6 w-32 bg-muted rounded" />
            <div className="h-4 w-full bg-muted rounded" />
            <div className="h-4 w-3/4 bg-muted rounded" />
          </div>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card className="bg-card/50 border-border/50">
      <CardContent className="p-6">
        <h2 className="text-xl font-bold mb-4 flex items-center gap-2">
          <FileText className="h-5 w-5 text-primary" />
          {heading}
        </h2>
        <div className="prose prose-sm dark:prose-invert max-w-none">
          {narrativeText}
        </div>
      </CardContent>
    </Card>
  );
}
```

Key implementation notes:
- Same visual styling for both narratives (content itself distinguishes context per user decision)
- Always show full narrative (no truncation or "Read more")
- Placeholder message: "Analysis pending - check back closer to kickoff."
- Use prose classes for proper text formatting

If /api/matches/[id]/content route doesn't exist, create it or use server action pattern.
  </action>
  <verify>
    - File exists: `ls src/components/match/match-narrative.tsx`
    - TypeScript compiles: `npx tsc --noEmit`
    - Component exports MatchNarrative: `grep -l "export.*MatchNarrative" src/components/match/match-narrative.tsx`
    - Uses useMatch hook: `grep "useMatch()" src/components/match/match-narrative.tsx`
  </verify>
  <done>
    MatchNarrative component exists, uses useMatch() context, displays appropriate narrative based on matchState with correct headings ("Match Preview" for upcoming/live, "Match Report" for finished), and shows placeholder for missing content.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create content API route (if needed)</name>
  <files>src/app/api/matches/[id]/content/route.ts</files>
  <action>
Check if /api/matches/[id]/content route exists. If not, create it:

```tsx
import { NextResponse } from 'next/server';
import { getMatchContentUnified } from '@/lib/db/queries';

export async function GET(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const content = await getMatchContentUnified(id);

    if (!content) {
      return NextResponse.json(
        { preMatchContent: null, postMatchContent: null },
        { status: 200 }
      );
    }

    return NextResponse.json({
      preMatchContent: content.preMatchContent || null,
      postMatchContent: content.postMatchContent || null,
    });
  } catch (error) {
    console.error('Error fetching match content:', error);
    return NextResponse.json(
      { error: 'Failed to fetch content' },
      { status: 500 }
    );
  }
}
```

This endpoint:
- Uses existing getMatchContentUnified query from @/lib/db/queries
- Returns preMatchContent and postMatchContent fields
- Returns null values if no content exists (not 404)
- Handles errors gracefully

If route already exists with different shape, adapt MatchNarrative component to use existing shape.
  </action>
  <verify>
    - Route exists: `ls src/app/api/matches/*/content/route.ts` or similar
    - TypeScript compiles: `npx tsc --noEmit`
    - Route returns JSON: `curl http://localhost:3000/api/matches/test-id/content` (if dev server running)
  </verify>
  <done>
    API route exists at /api/matches/[id]/content that returns {preMatchContent, postMatchContent} for the given match ID.
  </done>
</task>

</tasks>

<verification>
1. MatchNarrative component exists and compiles
2. Component uses useMatch() for context (not props)
3. API route exists and returns narrative content
4. TypeScript has no errors: `npx tsc --noEmit`
</verification>

<success_criteria>
- MatchNarrative component created with context consumption
- State-specific headings work ("Match Preview" vs "Match Report")
- Missing content shows placeholder message
- API route returns narrative content
- Code compiles without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/28-content-sections/28-01-SUMMARY.md`
</output>
