---
phase: 28-content-sections
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/match/sortable-predictions-table.tsx
  - src/components/match/predictions-summary.tsx
autonomous: true

must_haves:
  truths:
    - "Predictions table displays all 35 models"
    - "Table is sortable by clicking column headers"
    - "Finished match predictions show actual result and points earned"
    - "Visual highlight (green) for models that got exact score"
    - "Summary shows count of exact scores, correct winners, and misses"
  artifacts:
    - path: "src/components/match/sortable-predictions-table.tsx"
      provides: "Sortable predictions table component"
      min_lines: 100
      exports: ["SortablePredictionsTable"]
    - path: "src/components/match/predictions-summary.tsx"
      provides: "Predictions summary stats component"
      min_lines: 30
      exports: ["PredictionsSummary"]
  key_links:
    - from: "src/components/match/sortable-predictions-table.tsx"
      to: "useState"
      via: "sort state management"
      pattern: "useState.*sort"
    - from: "src/components/match/sortable-predictions-table.tsx"
      to: "useMemo"
      via: "memoized sorted array"
      pattern: "useMemo.*sort"
---

<objective>
Create SortablePredictionsTable component with column sorting, result header for finished matches, color-coded points, and predictions summary.

Purpose: Deliver predictions table that displays all 35 models in sortable format with visual feedback for points earned per user decisions from 28-CONTEXT.md.

Output: SortablePredictionsTable component with sorting, PredictionsSummary component showing stats.
</objective>

<execution_context>
@/Users/pieterbos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-content-sections/28-CONTEXT.md
@.planning/phases/28-content-sections/28-RESEARCH.md
@src/components/prediction-table.tsx
@src/components/match/predictions-section.tsx
@src/lib/db/queries.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SortablePredictionsTable component</name>
  <files>src/components/match/sortable-predictions-table.tsx</files>
  <action>
Create a new client component SortablePredictionsTable that extends the existing PredictionTable pattern with:

1. **Sortable columns** using useState + useMemo pattern (from 28-RESEARCH.md)
2. **Default sort** by performance ranking (points desc for finished, alphabetical for upcoming)
3. **Clickable headers** that toggle sort direction
4. **Result header row** showing actual score for finished matches
5. **Color-coded points** per user decisions:
   - 4+ pts: green (bg-green-500/20 text-green-400)
   - 3 pts: yellow (bg-yellow-500/20 text-yellow-400)
   - 2 pts: orange (bg-orange-500/20 text-orange-400)
   - 0 pts: gray (bg-muted text-muted-foreground)
6. **Visual highlight** for exact score (green background row)
7. **Icons for accessibility** (Trophy for exact, Target for winner, X for miss)

Component structure:
```tsx
'use client';

import { useState, useMemo } from 'react';
import { cn } from '@/lib/utils';
import { Bot, Trophy, Target, X, ChevronUp, ChevronDown } from 'lucide-react';

interface Prediction {
  id: string;
  modelId: string;
  modelDisplayName: string;
  provider: string;
  predictedHomeScore: number;
  predictedAwayScore: number;
  points: number | null;
  isExact: boolean;
  isCorrectResult: boolean;
}

interface SortablePredictionsTableProps {
  predictions: Prediction[];
  homeTeam: string;
  awayTeam: string;
  homeScore?: number | null;
  awayScore?: number | null;
  isFinished: boolean;
}

type SortColumn = 'model' | 'prediction' | 'points';
type SortDirection = 'asc' | 'desc';

export function SortablePredictionsTable({
  predictions,
  homeTeam,
  awayTeam,
  homeScore,
  awayScore,
  isFinished,
}: SortablePredictionsTableProps) {
  const [sortColumn, setSortColumn] = useState<SortColumn>(isFinished ? 'points' : 'model');
  const [sortDirection, setSortDirection] = useState<SortDirection>('desc');

  // Memoize sorted array - NEVER mutate original
  const sortedPredictions = useMemo(() => {
    return [...predictions].sort((a, b) => {
      let comparison = 0;
      switch (sortColumn) {
        case 'model':
          comparison = a.modelDisplayName.localeCompare(b.modelDisplayName);
          break;
        case 'prediction':
          // Sort by home score, then away score
          comparison = a.predictedHomeScore - b.predictedHomeScore ||
                       a.predictedAwayScore - b.predictedAwayScore;
          break;
        case 'points':
          comparison = (a.points ?? 0) - (b.points ?? 0);
          break;
      }
      return sortDirection === 'desc' ? -comparison : comparison;
    });
  }, [predictions, sortColumn, sortDirection]);

  const handleSort = (column: SortColumn) => {
    if (sortColumn === column) {
      setSortDirection(prev => prev === 'asc' ? 'desc' : 'asc');
    } else {
      setSortColumn(column);
      setSortDirection(column === 'points' ? 'desc' : 'asc');
    }
  };

  const SortHeader = ({ column, label }: { column: SortColumn; label: string }) => (
    <button
      onClick={() => handleSort(column)}
      className="flex items-center gap-1 font-medium hover:text-primary transition-colors"
    >
      {label}
      {sortColumn === column && (
        sortDirection === 'desc' ? <ChevronDown className="h-4 w-4" /> : <ChevronUp className="h-4 w-4" />
      )}
    </button>
  );

  // Color-coded points badge
  const PointsBadge = ({ points }: { points: number | null }) => {
    const pts = points ?? 0;
    return (
      <span className={cn(
        "px-2 py-1 rounded text-xs font-semibold",
        pts >= 4 && "bg-green-500/20 text-green-400",
        pts === 3 && "bg-yellow-500/20 text-yellow-400",
        pts === 2 && "bg-orange-500/20 text-orange-400",
        pts < 2 && "bg-muted text-muted-foreground"
      )}>
        {pts} pts
      </span>
    );
  };

  if (predictions.length === 0) {
    return (
      <div className="rounded-xl border border-dashed border-border/50 bg-muted/20 p-12 text-center">
        <Bot className="h-12 w-12 text-muted-foreground/50 mx-auto mb-4" />
        <p className="text-muted-foreground">No predictions yet</p>
        <p className="text-sm text-muted-foreground/70 mt-1">
          AI predictions are generated ~30 minutes before kickoff
        </p>
      </div>
    );
  }

  return (
    <div className="overflow-x-auto">
      <table className="w-full">
        <thead>
          {/* Result header row for finished matches */}
          {isFinished && homeScore !== null && awayScore !== null && (
            <tr className="border-b border-border/50 bg-muted/30">
              <td colSpan={4} className="p-3 text-center font-bold">
                Actual Result: {homeTeam} {homeScore} - {awayScore} {awayTeam}
              </td>
            </tr>
          )}
          <tr className="border-b border-border/50">
            <th className="p-3 text-left">
              <SortHeader column="model" label="Model" />
            </th>
            <th className="p-3 text-center">
              <SortHeader column="prediction" label="Prediction" />
            </th>
            {isFinished && (
              <th className="p-3 text-center">
                <SortHeader column="points" label="Points" />
              </th>
            )}
            {isFinished && (
              <th className="p-3 text-center">Result</th>
            )}
          </tr>
        </thead>
        <tbody>
          {sortedPredictions.map((prediction) => (
            <tr
              key={prediction.id}
              className={cn(
                "border-b border-border/30 transition-colors",
                prediction.isExact && "bg-green-500/10",
                prediction.isCorrectResult && !prediction.isExact && "bg-yellow-500/5"
              )}
            >
              <td className="p-3">
                <div className="font-medium">{prediction.modelDisplayName}</div>
                <div className="text-xs text-muted-foreground capitalize">{prediction.provider}</div>
              </td>
              <td className="p-3 text-center font-mono">
                {prediction.predictedHomeScore} - {prediction.predictedAwayScore}
              </td>
              {isFinished && (
                <td className="p-3 text-center">
                  <PointsBadge points={prediction.points} />
                </td>
              )}
              {isFinished && (
                <td className="p-3 text-center">
                  {prediction.isExact ? (
                    <Trophy className="h-5 w-5 text-green-400 mx-auto" aria-label="Exact score" />
                  ) : prediction.isCorrectResult ? (
                    <Target className="h-5 w-5 text-yellow-400 mx-auto" aria-label="Correct result" />
                  ) : (
                    <X className="h-5 w-5 text-muted-foreground mx-auto" aria-label="Incorrect" />
                  )}
                </td>
              )}
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}
```

Key implementation notes:
- Use [...predictions].sort() to avoid mutating original array (pitfall from RESEARCH.md)
- Use prediction.id as key, not index (pitfall from RESEARCH.md)
- Icons provide accessibility alongside colors (pitfall from RESEARCH.md)
- Mobile: table is scrollable horizontally (overflow-x-auto)
  </action>
  <verify>
    - File exists: `ls src/components/match/sortable-predictions-table.tsx`
    - TypeScript compiles: `npx tsc --noEmit`
    - Has useState for sort: `grep "useState.*sort" src/components/match/sortable-predictions-table.tsx`
    - Has useMemo for sorted array: `grep "useMemo" src/components/match/sortable-predictions-table.tsx`
    - Exports component: `grep "export.*SortablePredictionsTable" src/components/match/sortable-predictions-table.tsx`
  </verify>
  <done>
    SortablePredictionsTable component exists with:
    - Clickable column headers for sorting
    - Default sort by points (desc) for finished, alphabetical for upcoming
    - Result header row showing actual score for finished matches
    - Color-coded points badges (green/yellow/orange/gray)
    - Row highlighting for exact scores (green) and correct results (yellow)
    - Icons for accessibility (Trophy/Target/X)
    - Mobile-friendly scrollable table
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PredictionsSummary component</name>
  <files>src/components/match/predictions-summary.tsx</files>
  <action>
Create a summary component that displays prediction stats for finished matches:

```tsx
'use client';

import { Trophy, Target, X } from 'lucide-react';

interface PredictionsSummaryProps {
  predictions: Array<{
    isExact: boolean;
    isCorrectResult: boolean;
  }>;
}

export function PredictionsSummary({ predictions }: PredictionsSummaryProps) {
  const total = predictions.length;
  const exactCount = predictions.filter(p => p.isExact).length;
  const winnerCount = predictions.filter(p => p.isCorrectResult && !p.isExact).length;
  const missCount = total - exactCount - winnerCount;

  if (total === 0) return null;

  return (
    <div className="flex flex-wrap gap-4 text-sm mb-4">
      <div className="flex items-center gap-2">
        <Trophy className="h-4 w-4 text-green-400" />
        <span>
          <strong>{exactCount}</strong> exact score{exactCount !== 1 ? 's' : ''}
        </span>
      </div>
      <div className="flex items-center gap-2">
        <Target className="h-4 w-4 text-yellow-400" />
        <span>
          <strong>{winnerCount}</strong> got winner
        </span>
      </div>
      <div className="flex items-center gap-2">
        <X className="h-4 w-4 text-muted-foreground" />
        <span>
          <strong>{missCount}</strong> missed
        </span>
      </div>
    </div>
  );
}
```

This component:
- Shows "X models got exact score, Y got winner, Z got nothing" per user decision
- Uses consistent icons from lucide-react
- Renders only for finished matches (caller decides when to show)
- Returns null if no predictions
  </action>
  <verify>
    - File exists: `ls src/components/match/predictions-summary.tsx`
    - TypeScript compiles: `npx tsc --noEmit`
    - Exports component: `grep "export.*PredictionsSummary" src/components/match/predictions-summary.tsx`
  </verify>
  <done>
    PredictionsSummary component exists showing exact score count, correct winner count, and miss count with icons.
  </done>
</task>

</tasks>

<verification>
1. SortablePredictionsTable component exists and compiles
2. Table has sortable columns with visual indicators
3. Color-coded points badges work correctly
4. PredictionsSummary shows correct counts
5. TypeScript has no errors: `npx tsc --noEmit`
</verification>

<success_criteria>
- SortablePredictionsTable created with useState/useMemo sorting pattern
- Default sort by points (desc) for finished matches
- Clickable column headers toggle sort
- Result header row shows actual score for finished matches
- Color-coded points: 4+ green, 3 yellow, 2 orange, 0 gray
- Row highlighting for exact scores
- Icons for accessibility alongside colors
- PredictionsSummary shows stats
- Mobile-friendly scrollable table
</success_criteria>

<output>
After completion, create `.planning/phases/28-content-sections/28-02-SUMMARY.md`
</output>
