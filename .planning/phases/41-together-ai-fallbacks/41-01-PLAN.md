---
phase: 41-together-ai-fallbacks
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/db/schema.ts
  - src/lib/llm/index.ts
  - drizzle/migrations/XXXX_add_used_fallback.sql
autonomous: true

must_haves:
  truths:
    - "Predictions table has usedFallback column"
    - "MODEL_FALLBACKS validated at application startup"
    - "Invalid fallback mappings cause startup failure"
  artifacts:
    - path: "src/lib/db/schema.ts"
      provides: "usedFallback boolean column on predictions table"
      contains: "usedFallback"
    - path: "src/lib/llm/index.ts"
      provides: "validateFallbackMapping function and startup call"
      contains: "validateFallbackMapping"
    - path: "drizzle/migrations"
      provides: "Migration file for usedFallback column"
  key_links:
    - from: "src/lib/llm/index.ts"
      to: "MODEL_FALLBACKS"
      via: "validateFallbackMapping checks all entries"
      pattern: "validateFallbackMapping.*MODEL_FALLBACKS"
---

<objective>
Add database tracking for fallbacks and validate fallback configuration at startup.

Purpose: Establish the foundation for fallback tracking (usedFallback column) and ensure fallback mappings are valid before the application starts serving requests. This prevents runtime errors from invalid MODEL_FALLBACKS configuration.

Output:
- predictions.usedFallback column (boolean, default false)
- validateFallbackMapping() function that runs at module load
- Database migration file
</objective>

<execution_context>
@/Users/pieterbos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/41-together-ai-fallbacks/41-CONTEXT.md
@.planning/phases/41-together-ai-fallbacks/41-RESEARCH.md

# Key files to reference
@src/lib/db/schema.ts
@src/lib/llm/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add usedFallback column to predictions schema</name>
  <files>src/lib/db/schema.ts</files>
  <action>
Add usedFallback boolean column to the predictions table definition:

```typescript
usedFallback: boolean('used_fallback').default(false),
```

Add this column AFTER the status column, BEFORE the timestamps section. This tracks whether a prediction was generated using a fallback provider instead of the original model.

User decision: Minimal tracking - boolean flag only, no originalModelId/fallbackModelId tracking. The modelId column always stores the ORIGINAL model (user-facing attribution), usedFallback tracks whether fallback was used internally.
  </action>
  <verify>TypeScript compilation passes: `npx tsc --noEmit`</verify>
  <done>predictions table schema includes usedFallback boolean column with default false</done>
</task>

<task type="auto">
  <name>Task 2: Generate and run database migration</name>
  <files>drizzle/migrations/XXXX_add_used_fallback.sql</files>
  <action>
Generate a Drizzle migration for the schema change:

```bash
npx drizzle-kit generate --name add_used_fallback
```

Review the generated migration SQL to ensure it adds the column correctly:
- Column name: used_fallback
- Type: boolean
- Default: false
- Nullable: no (implicit from default)

Then run the migration against the development database:

```bash
npx drizzle-kit push
```

If push fails with existing data, the migration should handle existing rows by setting default false.
  </action>
  <verify>`npx drizzle-kit push` completes without errors. Verify column exists: connect to database and run `SELECT column_name FROM information_schema.columns WHERE table_name = 'predictions' AND column_name = 'used_fallback';`</verify>
  <done>used_fallback column exists in predictions table with default value false</done>
</task>

<task type="auto">
  <name>Task 3: Add startup validation for MODEL_FALLBACKS</name>
  <files>src/lib/llm/index.ts</files>
  <action>
Add a validateFallbackMapping function that validates MODEL_FALLBACKS at module load time:

```typescript
/**
 * Validate fallback mapping at startup
 * Checks:
 * 1. All fallback target models exist in ALL_PROVIDERS
 * 2. No cycles in fallback chain (though with max depth 1, cycles are unlikely but still bad config)
 */
function validateFallbackMapping(): void {
  const providerIds = new Set(ALL_PROVIDERS.map(p => p.id));

  for (const [syntheticId, fallbackId] of Object.entries(MODEL_FALLBACKS)) {
    // Check fallback target exists
    if (!providerIds.has(fallbackId)) {
      throw new Error(
        `Invalid fallback mapping: ${syntheticId} -> ${fallbackId}. ` +
        `Target model "${fallbackId}" not found in ALL_PROVIDERS. ` +
        `Available providers: ${[...providerIds].join(', ')}`
      );
    }

    // Check for direct self-reference (model can't be its own fallback)
    if (syntheticId === fallbackId) {
      throw new Error(
        `Invalid fallback mapping: ${syntheticId} -> ${fallbackId}. ` +
        `Model cannot be its own fallback.`
      );
    }

    // Check for simple cycle (A -> B -> A)
    // With max depth 1 this is the only cycle pattern that matters
    const fallbackOfFallback = MODEL_FALLBACKS[fallbackId];
    if (fallbackOfFallback === syntheticId) {
      throw new Error(
        `Cycle detected in fallback mapping: ${syntheticId} -> ${fallbackId} -> ${syntheticId}. ` +
        `Fallback chains must not form cycles.`
      );
    }
  }

  loggers.llm.info({
    mappingCount: Object.keys(MODEL_FALLBACKS).length,
    mappings: MODEL_FALLBACKS,
  }, 'Fallback mapping validated successfully');
}

// Run validation at module load time (fails fast if config is invalid)
validateFallbackMapping();
```

Place this function AFTER the MODEL_FALLBACKS constant and getFallbackProvider function, BEFORE the getActiveProviders function. The validation runs when the module is first imported, which happens at application startup.

Note: This validates at import time, not runtime. If MODEL_FALLBACKS references a non-existent provider, the application will fail to start with a clear error message rather than failing silently at prediction time.
  </action>
  <verify>
1. TypeScript compilation passes: `npx tsc --noEmit`
2. Application starts successfully: `npm run dev` (or check that existing tests pass)
3. To verify validation works, temporarily add an invalid mapping like `'test-invalid': 'nonexistent-model'` and confirm the application fails to start with a descriptive error
  </verify>
  <done>validateFallbackMapping function exists, runs at module load, and throws descriptive errors for invalid configurations</done>
</task>

</tasks>

<verification>
1. Schema verification:
   - `npx tsc --noEmit` passes
   - Database has used_fallback column on predictions table

2. Startup validation verification:
   - Application starts normally with valid MODEL_FALLBACKS
   - Invalid mappings cause startup failure with descriptive error

3. No regressions:
   - Existing predictions queries still work
   - Existing provider imports still work
</verification>

<success_criteria>
- predictions.usedFallback column exists with default false
- validateFallbackMapping() runs at module load
- Invalid MODEL_FALLBACKS entries cause application startup failure
- All existing functionality unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/41-together-ai-fallbacks/41-01-SUMMARY.md`
</output>
