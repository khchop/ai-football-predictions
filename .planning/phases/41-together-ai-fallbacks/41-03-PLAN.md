---
phase: 41-together-ai-fallbacks
plan: 03
type: execute
wave: 3
depends_on: ["41-01", "41-02"]
files_modified:
  - src/app/api/admin/fallback-stats/route.ts
  - src/components/admin/fallback-metrics.tsx
  - src/components/admin/admin-dashboard.tsx
autonomous: true

must_haves:
  truths:
    - "Admin dashboard shows per-model fallback rates"
    - "Admin dashboard shows cost warning when fallback >2x original cost"
    - "Fallback statistics aggregated from predictions table"
  artifacts:
    - path: "src/app/api/admin/fallback-stats/route.ts"
      provides: "API endpoint for fallback statistics"
      exports: ["GET"]
    - path: "src/components/admin/fallback-metrics.tsx"
      provides: "FallbackMetrics UI component"
      contains: "FallbackMetrics"
    - path: "src/components/admin/admin-dashboard.tsx"
      provides: "Dashboard integration"
      contains: "FallbackMetrics"
  key_links:
    - from: "src/components/admin/fallback-metrics.tsx"
      to: "/api/admin/fallback-stats"
      via: "fetch in useEffect"
      pattern: "fetch.*fallback-stats"
    - from: "src/components/admin/admin-dashboard.tsx"
      to: "src/components/admin/fallback-metrics.tsx"
      via: "import and render"
      pattern: "import.*FallbackMetrics"
---

<objective>
Add admin dashboard visibility for fallback usage and cost tracking.

Purpose: Give admins visibility into which models are using fallbacks, how often, and at what cost. Show warnings when fallback costs exceed 2x the original model cost (user decision from CONTEXT.md).

Output:
- /api/admin/fallback-stats endpoint
- FallbackMetrics component showing per-model fallback rates
- Cost warning badges when >2x threshold exceeded
</objective>

<execution_context>
@/Users/pieterbos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/41-together-ai-fallbacks/41-CONTEXT.md
@.planning/phases/41-together-ai-fallbacks/41-RESEARCH.md
@.planning/phases/41-together-ai-fallbacks/41-01-SUMMARY.md
@.planning/phases/41-together-ai-fallbacks/41-02-SUMMARY.md

# Key files to reference
@src/app/api/admin/data/route.ts
@src/components/admin/admin-dashboard.tsx
@src/lib/llm/index.ts
@src/lib/llm/providers/together.ts
@src/lib/llm/providers/synthetic.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create fallback stats API endpoint</name>
  <files>src/app/api/admin/fallback-stats/route.ts</files>
  <action>
Create a new API endpoint that returns fallback statistics aggregated from the predictions table.

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { db } from '@/lib/db';
import { predictions } from '@/lib/db/schema';
import { sql, and, gte, eq } from 'drizzle-orm';
import { requireAdminAuth } from '@/lib/utils/admin-auth';
import { checkRateLimit, getRateLimitKey, createRateLimitHeaders, RATE_LIMIT_PRESETS } from '@/lib/utils/rate-limiter';
import { sanitizeError } from '@/lib/utils/error-sanitizer';
import { getProviderById, MODEL_FALLBACKS } from '@/lib/llm';

interface FallbackStats {
  modelId: string;
  displayName: string;
  totalPredictions: number;
  fallbackCount: number;
  fallbackRate: number;
  estimatedOriginalCost: number;
  estimatedFallbackCost: number;
  costMultiplier: number;
  exceeds2x: boolean;
  fallbackModelId: string | null;
  fallbackModelName: string | null;
}

export async function GET(request: NextRequest) {
  // Rate limit check
  const rateLimitKey = getRateLimitKey(request);
  const rateLimitResult = await checkRateLimit(`admin:fallback-stats:${rateLimitKey}`, RATE_LIMIT_PRESETS.admin);

  if (!rateLimitResult.allowed) {
    const retryAfter = Math.ceil((rateLimitResult.resetAt * 1000 - Date.now()) / 1000);
    return NextResponse.json(
      { error: 'Too many requests', retryAfter },
      { status: 429, headers: { ...createRateLimitHeaders(rateLimitResult), 'Retry-After': String(retryAfter) } }
    );
  }

  // Admin auth
  const authError = requireAdminAuth(request);
  if (authError) return authError;

  try {
    // Get today's start timestamp for daily aggregation
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // Aggregate fallback stats from predictions table
    const stats = await db
      .select({
        modelId: predictions.modelId,
        totalPredictions: sql<number>`count(*)::int`,
        fallbackCount: sql<number>`count(*) filter (where ${predictions.usedFallback} = true)::int`,
      })
      .from(predictions)
      .where(
        and(
          gte(predictions.createdAt, today),
          eq(predictions.status, 'scored')  // Only count completed predictions
        )
      )
      .groupBy(predictions.modelId);

    // Enrich with cost estimates and provider info
    const fallbackStats: FallbackStats[] = [];

    for (const stat of stats) {
      const provider = getProviderById(stat.modelId);
      if (!provider) continue;

      // Only include models with fallback configurations
      const fallbackModelId = MODEL_FALLBACKS[stat.modelId];
      if (!fallbackModelId && stat.fallbackCount === 0) continue;

      const fallbackProvider = fallbackModelId ? getProviderById(fallbackModelId) : null;

      // Estimate costs (user decision: ~500 input tokens, ~50 output tokens)
      // Cast to access pricing property
      const originalCost = (provider as { pricing?: { promptPer1M: number; completionPer1M: number } }).pricing
        ? ((500 / 1_000_000) * (provider as any).pricing.promptPer1M +
           (50 / 1_000_000) * (provider as any).pricing.completionPer1M) * stat.fallbackCount
        : 0;

      const fallbackCost = fallbackProvider && (fallbackProvider as any).pricing
        ? ((500 / 1_000_000) * (fallbackProvider as any).pricing.promptPer1M +
           (50 / 1_000_000) * (fallbackProvider as any).pricing.completionPer1M) * stat.fallbackCount
        : 0;

      const costMultiplier = originalCost > 0 ? fallbackCost / originalCost : 0;
      const fallbackRate = stat.totalPredictions > 0 ? stat.fallbackCount / stat.totalPredictions : 0;

      fallbackStats.push({
        modelId: stat.modelId,
        displayName: provider.displayName,
        totalPredictions: stat.totalPredictions,
        fallbackCount: stat.fallbackCount,
        fallbackRate,
        estimatedOriginalCost: originalCost,
        estimatedFallbackCost: fallbackCost,
        costMultiplier,
        exceeds2x: costMultiplier > 2.0,
        fallbackModelId: fallbackModelId || null,
        fallbackModelName: fallbackProvider?.displayName || null,
      });
    }

    // Sort by fallback rate descending (highest fallback rates first)
    fallbackStats.sort((a, b) => b.fallbackRate - a.fallbackRate);

    return NextResponse.json(
      {
        stats: fallbackStats,
        summary: {
          totalModelsWithFallback: fallbackStats.filter(s => s.fallbackModelId).length,
          totalFallbacksToday: fallbackStats.reduce((sum, s) => sum + s.fallbackCount, 0),
          modelsExceeding2x: fallbackStats.filter(s => s.exceeds2x).length,
        },
      },
      { headers: createRateLimitHeaders(rateLimitResult) }
    );
  } catch (error) {
    return NextResponse.json(
      { success: false, error: sanitizeError(error, 'fallback-stats') },
      { status: 500, headers: createRateLimitHeaders(rateLimitResult) }
    );
  }
}
```

Key implementation notes:
1. Only includes models that either have a fallback configured OR have fallback usage
2. Cost estimates use 500 input / 50 output token assumption (matches RESEARCH.md)
3. User decision: estimated costs only, no billing API integration
4. Rate limited and admin-auth protected like other admin endpoints
  </action>
  <verify>TypeScript compilation passes: `npx tsc --noEmit`. Endpoint accessible at /api/admin/fallback-stats (returns JSON or auth error)</verify>
  <done>GET /api/admin/fallback-stats returns FallbackStats array with per-model fallback rates and cost warnings</done>
</task>

<task type="auto">
  <name>Task 2: Create FallbackMetrics dashboard component</name>
  <files>src/components/admin/fallback-metrics.tsx</files>
  <action>
Create a new component that displays fallback statistics with cost warnings:

```typescript
'use client';

import { useState, useEffect, useCallback } from 'react';
import { AlertTriangle, ArrowRight, RefreshCw, Loader2 } from 'lucide-react';

interface FallbackStat {
  modelId: string;
  displayName: string;
  totalPredictions: number;
  fallbackCount: number;
  fallbackRate: number;
  estimatedOriginalCost: number;
  estimatedFallbackCost: number;
  costMultiplier: number;
  exceeds2x: boolean;
  fallbackModelId: string | null;
  fallbackModelName: string | null;
}

interface FallbackStatsResponse {
  stats: FallbackStat[];
  summary: {
    totalModelsWithFallback: number;
    totalFallbacksToday: number;
    modelsExceeding2x: number;
  };
}

export function FallbackMetrics() {
  const [data, setData] = useState<FallbackStatsResponse | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchStats = useCallback(async () => {
    setIsLoading(true);
    setError(null);

    try {
      const storedPassword = sessionStorage.getItem('admin_password');
      const response = await fetch('/api/admin/fallback-stats', {
        headers: {
          'X-Admin-Password': storedPassword || '',
        },
      });

      if (!response.ok) {
        throw new Error('Failed to fetch fallback stats');
      }

      const result = await response.json();
      setData(result);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchStats();
  }, [fetchStats]);

  if (isLoading) {
    return (
      <div className="card-gradient rounded-xl p-6">
        <div className="flex items-center justify-center py-8">
          <Loader2 className="h-6 w-6 animate-spin text-muted-foreground" />
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="card-gradient rounded-xl p-6">
        <p className="text-red-400 text-sm">{error}</p>
        <button
          onClick={fetchStats}
          className="mt-2 text-sm text-primary hover:underline"
        >
          Retry
        </button>
      </div>
    );
  }

  if (!data || data.stats.length === 0) {
    return (
      <div className="card-gradient rounded-xl p-6">
        <h3 className="text-lg font-semibold mb-4 flex items-center gap-2">
          <RefreshCw className="h-5 w-5" />
          Fallback Metrics
        </h3>
        <p className="text-muted-foreground text-sm">No fallback data available today.</p>
      </div>
    );
  }

  const { stats, summary } = data;

  return (
    <div className="card-gradient rounded-xl p-6">
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-lg font-semibold flex items-center gap-2">
          <RefreshCw className="h-5 w-5" />
          Fallback Metrics (Today)
        </h3>
        <button
          onClick={fetchStats}
          className="text-sm text-muted-foreground hover:text-foreground transition-colors"
        >
          Refresh
        </button>
      </div>

      {/* Summary badges */}
      <div className="flex gap-4 mb-4 flex-wrap">
        <div className="px-3 py-1 rounded-full bg-muted text-sm">
          {summary.totalFallbacksToday} fallbacks today
        </div>
        {summary.modelsExceeding2x > 0 && (
          <div className="px-3 py-1 rounded-full bg-amber-500/20 text-amber-400 text-sm flex items-center gap-1">
            <AlertTriangle className="h-3 w-3" />
            {summary.modelsExceeding2x} model(s) &gt;2x cost
          </div>
        )}
      </div>

      {/* Stats table */}
      <div className="overflow-x-auto">
        <table className="w-full text-sm">
          <thead>
            <tr className="text-left text-muted-foreground border-b border-border">
              <th className="pb-2 font-medium">Model</th>
              <th className="pb-2 font-medium">Fallback</th>
              <th className="pb-2 font-medium text-right">Rate</th>
              <th className="pb-2 font-medium text-right">Count</th>
              <th className="pb-2 font-medium text-right">Cost</th>
            </tr>
          </thead>
          <tbody>
            {stats.map((stat) => (
              <tr key={stat.modelId} className="border-b border-border/50">
                <td className="py-2">
                  <span className="font-medium">{stat.displayName}</span>
                </td>
                <td className="py-2">
                  {stat.fallbackModelName ? (
                    <span className="flex items-center gap-1 text-muted-foreground">
                      <ArrowRight className="h-3 w-3" />
                      {stat.fallbackModelName}
                    </span>
                  ) : (
                    <span className="text-muted-foreground">-</span>
                  )}
                </td>
                <td className="py-2 text-right">
                  <span className={stat.fallbackRate > 0.1 ? 'text-amber-400' : ''}>
                    {(stat.fallbackRate * 100).toFixed(1)}%
                  </span>
                </td>
                <td className="py-2 text-right text-muted-foreground">
                  {stat.fallbackCount}/{stat.totalPredictions}
                </td>
                <td className="py-2 text-right">
                  {stat.exceeds2x ? (
                    <span className="inline-flex items-center gap-1 px-2 py-0.5 rounded bg-amber-500/20 text-amber-400">
                      <AlertTriangle className="h-3 w-3" />
                      {stat.costMultiplier.toFixed(1)}x
                    </span>
                  ) : stat.costMultiplier > 0 ? (
                    <span className="text-muted-foreground">{stat.costMultiplier.toFixed(1)}x</span>
                  ) : (
                    <span className="text-muted-foreground">-</span>
                  )}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      <p className="text-xs text-muted-foreground mt-4">
        * Cost estimates based on ~500 input / ~50 output tokens per prediction
      </p>
    </div>
  );
}
```

Key design decisions (Claude's discretion from CONTEXT.md):
1. Table layout for clear per-model visibility
2. Amber color for warnings (>2x cost, >10% fallback rate)
3. Summary badges at top for quick overview
4. Refresh button for on-demand updates
5. Shows fallback chain (Original -> Fallback model names)
  </action>
  <verify>TypeScript compilation passes: `npx tsc --noEmit`</verify>
  <done>FallbackMetrics component displays per-model fallback rates with >2x cost warnings</done>
</task>

<task type="auto">
  <name>Task 3: Integrate FallbackMetrics into admin dashboard</name>
  <files>src/components/admin/admin-dashboard.tsx</files>
  <action>
Add the FallbackMetrics component to the admin dashboard.

1. Import the component at the top:
```typescript
import { FallbackMetrics } from './fallback-metrics';
```

2. Add the FallbackMetrics component after CostSummary and before ModelHealthTable (around line 260):
```typescript
{/* Cost Summary */}
<CostSummary budgetStatus={data.budgetStatus} />

{/* Fallback Metrics - NEW */}
<FallbackMetrics />

{/* Model Health Table */}
<ModelHealthTable
```

The component is self-contained (fetches its own data), so no props needed and no changes to AdminData interface required.
  </action>
  <verify>
1. TypeScript compilation passes: `npx tsc --noEmit`
2. Run dev server and navigate to /admin - FallbackMetrics should appear between Cost Summary and Model Health Table
  </verify>
  <done>Admin dashboard renders FallbackMetrics component, showing fallback statistics to admins</done>
</task>

</tasks>

<verification>
1. API verification:
   - GET /api/admin/fallback-stats returns valid JSON
   - Response includes stats array and summary object
   - exceeds2x flag is true when costMultiplier > 2.0

2. Component verification:
   - FallbackMetrics renders without errors
   - Shows loading state while fetching
   - Displays table with model/fallback/rate/count/cost columns
   - Warning badges appear when >2x cost threshold exceeded

3. Integration verification:
   - FallbackMetrics appears in admin dashboard
   - Component fetches data on mount
   - Refresh button works
</verification>

<success_criteria>
- Admin can see per-model fallback rates in dashboard
- Models exceeding 2x cost threshold show amber warning badges
- Summary shows total fallbacks today and models exceeding threshold
- All data fetched via authenticated admin API
</success_criteria>

<output>
After completion, create `.planning/phases/41-together-ai-fallbacks/41-03-SUMMARY.md`
</output>
