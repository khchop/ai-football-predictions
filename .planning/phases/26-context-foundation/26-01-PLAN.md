---
phase: 26-context-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/match/match-data-provider.tsx
  - src/components/match/use-match.ts
autonomous: true
must_haves:
  truths:
    - "MatchDataProvider context exists and can receive match/competition/analysis props"
    - "useMatch() hook returns context value with non-null guarantee"
    - "Context value is memoized with useMemo to prevent unnecessary re-renders"
    - "Match state (upcoming/live/finished) is derived once in provider"
  artifacts:
    - path: "src/components/match/match-data-provider.tsx"
      provides: "Client Component Context provider with memoized value"
      min_lines: 40
      contains: "'use client', createContext, useMemo, MatchDataProvider"
    - path: "src/components/match/use-match.ts"
      provides: "Type-safe hook with null check error"
      min_lines: 15
      contains: "useMatch, useContext, throw new Error"
  key_links:
    - from: "src/components/match/match-data-provider.tsx"
      to: "@/types"
      via: "type imports"
      pattern: "import.*Match.*Competition.*MatchAnalysis.*from.*@/types"
    - from: "src/components/match/use-match.ts"
      to: "src/components/match/match-data-provider.tsx"
      via: "MatchContext import"
      pattern: "import.*MatchContext.*from.*match-data-provider"
---

<objective>
Create React Context infrastructure for match data distribution

Purpose: Establish single source of truth for match data (ARCH-01, ARCH-03), eliminating prop drilling across match page component tree
Output: MatchDataProvider component and useMatch hook ready for page integration
</objective>

<execution_context>
@/Users/pieterbos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/26-context-foundation/26-RESEARCH.md

# Existing provider pattern reference
@src/app/providers.tsx

# Types available for import
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MatchDataProvider component with Context</name>
  <files>src/components/match/match-data-provider.tsx</files>
  <action>
    Create Client Component that provides match data via React Context:

    1. Add "use client" directive at top (required - Context only works in Client Components)
    2. Import createContext, useMemo from 'react'
    3. Import Match, Competition, MatchAnalysis types from '@/types'
    4. Define MatchContextValue interface:
       - match: Match
       - competition: Competition
       - analysis: MatchAnalysis | null
       - matchState: 'upcoming' | 'live' | 'finished'
    5. Create and export MatchContext with createContext<MatchContextValue | null>(null)
    6. Define MatchDataProviderProps interface:
       - match: Match
       - competition: Competition
       - analysis: MatchAnalysis | null
       - children: React.ReactNode
    7. Export MatchDataProvider function component that:
       a. Derives matchState with useMemo based on match.status:
          - 'finished' if status === 'finished'
          - 'live' if status === 'live'
          - 'upcoming' otherwise
          Dependencies: [match.status]
       b. Memoizes contextValue with useMemo containing:
          { match, competition, analysis, matchState }
          Dependencies: [match, competition, analysis, matchState]
       c. Returns MatchContext.Provider with value={contextValue} wrapping {children}

    Follow research patterns:
    - Pattern 2: Memoized Context Value (prevent re-renders from object identity)
    - Pitfall 1: Object identity causes unnecessary re-renders (use useMemo)
    - Pitfall 5: Derive state once in provider, not in consumers

    DO NOT:
    - Create Context value inline (e.g., value={{ match }}) - causes re-renders
    - Import or use useContext in this file (only create context)
    - Omit "use client" directive (will cause Next.js error)
  </action>
  <verify>
    grep -E "^'use client'" src/components/match/match-data-provider.tsx
    grep -E "createContext.*MatchContextValue" src/components/match/match-data-provider.tsx
    grep -E "useMemo.*matchState" src/components/match/match-data-provider.tsx
    grep -E "useMemo.*contextValue" src/components/match/match-data-provider.tsx
    grep -E "export.*MatchContext" src/components/match/match-data-provider.tsx
    grep -E "export.*MatchDataProvider" src/components/match/match-data-provider.tsx
  </verify>
  <done>MatchDataProvider is a Client Component that creates Context, derives matchState once, memoizes context value, and exports both MatchContext and MatchDataProvider</done>
</task>

<task type="auto">
  <name>Task 2: Create useMatch hook with type safety</name>
  <files>src/components/match/use-match.ts</files>
  <action>
    Create custom hook for type-safe Context consumption:

    1. Import useContext from 'react'
    2. Import MatchContext from './match-data-provider'
    3. Export useMatch function that:
       a. Calls useContext(MatchContext)
       b. Checks if context is null
       c. If null, throws Error with message:
          "useMatch must be used within MatchDataProvider. Make sure your component is wrapped with <MatchDataProvider>."
       d. Returns context (TypeScript will infer non-null type after throw)

    Follow research patterns:
    - Pattern 3: Custom Hook Wrapper (type safety + null check)
    - Pitfall 2: Provider Not in Component Tree (clear error message)

    DO NOT:
    - Return context without null check (allows runtime errors)
    - Use vague error messages (specify MatchDataProvider requirement)
    - Export from index.ts barrel file yet (just create the hook file)
  </action>
  <verify>
    grep -E "export.*function useMatch" src/components/match/use-match.ts
    grep -E "useContext.*MatchContext" src/components/match/use-match.ts
    grep -E "throw new Error.*MatchDataProvider" src/components/match/use-match.ts
    npx tsc --noEmit src/components/match/use-match.ts 2>&1 || echo "Check for type errors"
  </verify>
  <done>useMatch hook provides type-safe access to match context with clear error message if used outside provider</done>
</task>

</tasks>

<verification>
After completion:
1. src/components/match/match-data-provider.tsx exists with "use client", exports MatchContext and MatchDataProvider
2. src/components/match/use-match.ts exists with useMatch hook that throws on null context
3. TypeScript compiles without errors: npx tsc --noEmit
4. No inline Context value creation (useMemo used for both matchState and contextValue)
5. matchState derived once in provider (not left for consumers to derive)
</verification>

<success_criteria>
Context infrastructure ready for integration:
- MatchDataProvider is a Client Component with memoized context value
- useMatch hook provides type-safe access with descriptive error on null
- Match state (upcoming/live/finished) derived once in provider
- Types imported from @/types (Match, Competition, MatchAnalysis)
- Ready for Plan 02 to integrate into match pages
</success_criteria>

<output>
After completion, create `.planning/phases/26-context-foundation/26-01-SUMMARY.md` with:
- What was created (MatchDataProvider, useMatch, MatchContext)
- Context value interface definition
- Memoization strategy used (why useMemo for matchState and contextValue)
- Files created with key exports
</output>
