---
phase: 26-context-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/match/match-data-provider.tsx
  - src/components/match/use-match.ts
autonomous: true
must_haves:
  truths:
    - "MatchDataProvider context exists and can receive match/competition/analysis props"
    - "useMatch() hook returns context value with non-null guarantee"
    - "Context value is memoized with useMemo to prevent unnecessary re-renders"
    - "Match state (upcoming/live/finished) is derived once in provider"
  artifacts:
    - path: "src/components/match/match-data-provider.tsx"
      provides: "Client Component Context provider with memoized value"
      min_lines: 30
      contains: "createContext, useMemo, MatchDataProvider function"
    - path: "src/components/match/use-match.ts"
      provides: "Type-safe hook with null check error"
      min_lines: 10
      contains: "useMatch function, useContext, error throw"
  key_links:
    - from: "src/components/match/match-data-provider.tsx"
      to: "@/types (Match, Competition, MatchAnalysis)"
      via: "type imports from @/types"
      pattern: "import.*from '@/types'"
    - from: "src/components/match/use-match.ts"
      to: "src/components/match/match-data-provider.tsx"
      via: "MatchContext import"
      pattern: "import.*MatchContext.*from.*match-data-provider"
---

<objective>
Create React Context infrastructure for match data distribution

Purpose: Establish single source of truth for match data, eliminating duplicate fetching and prop drilling match pages
Output: MatchDataProvider component and useMatch hook ready for integration
</objective>

<execution_context>
@/Users/pieterbos/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/26-context-foundation/26-RESEARCH.md

# Type imports available
@/Users/pieterbos/Documents/bettingsoccer/src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MatchdataProvider component with Context</name>
  <files>src/components/match/match-data-provider.tsx</files>
  <action>
    Create Client Component with "use client" directive that:
    
    1. Imports createContext, useMemo from 'react'
    2. Imports Match, Competition, MatchAnalysis types from '@/types'
    3. Defines MatchContextValue interface with:
       - match: Match
       - competition: Competition
       - analysis: MatchAnalysis | null
       - matchState: 'upcoming' | 'live' | 'finished'
    4. Creates and exports MatchContext with null default
    5. Defines MatchDataProviderProps interface (match, competition, analysis, children: React.ReactNode)
    6. Derives matchState with useMemo based on match.status:
       - 'finished' if status === 'finished'
       - 'live' if status === 'live'
       - 'upcoming' otherwise
       Dependencies: [match.status]
    7. Memoizes contextValue with useMemo containing match, competition, analysis, matchState
       Dependencies: [match, competition, analysis, matchState]
    8. Exports MatchDataProvider function that returns MatchContext.Provider with contextValue and children

    DO NOT:
    - Create Context value inline (without useMemo)
    - Derive matchState in every consumer (do it once in provider)
    - Try to useContext inside this component (only create context)
    - Mark this as Server Component (must be Client Component with "use client")

    Reference RESEARCH.md patterns:
    - Pattern 2: Memoized Context Value
    - Pattern 3: Custom Hook Wrapper
    - Pitfall 1: Object identity causes unnecessary re-renders
    - Pitfall 5: Deriving state in every consumer
  </action>
  <verify>
    File exists with "use client" directive at top, createContext called, MatchContext exported default, MatchdataProvider function exported, useMemo used for both matchState and contextValue
  </verify>
  <done>MatchDataProvider component is a Client Component that creates Context, derives matchState once, and memoizes context value with all data needed by consumers</done>
</task>

<task type="auto">
  <name>Task 2: Create useMatch hook with type safety</name>
  <files>src/components/match/use-match.ts</files>
  <action>
    Create custom hook that:
    
    1. Imports useContext from 'react'
    2. Imports MatchContext from './match-data-provider'
    3. Exports useMatch function that:
       - Calls useContext(MatchContext)
       - Checks if context is null
       - If null, throws Error: "useMatch must be used within MatchDataProvider. Make sure your component is wrapped with <MatchDataProvider>."
       - Returns context (non-null guaranteed by error check)
    
    DO NOT:
    - Return context without null check (runtime error risk)
    - Use vague error messages (be specific about MatchDataProvider requirement)
    - Try to create Context in this file (only consume via useContext)
    - Make this a component (it's a hook function)

    Reference RESEARCH.md patterns:
    - Pattern 3: Custom Hook Wrapper (Type Safety + Null Check)
    - Pitfall 2: Provider Not in Component Tree (runtime error prevention)
  </action>
  <verify>
    File exists, useMatch function exported, useContext called with MatchContext, null check with specific error message, returns context
  </verify>
  <done>useMatch hook provides type-safe access to match context with clear error message if used outside provider</done>
</task>

</tasks>

<verification>
After completion:
1. Check src/components/match/match-data-provider.tsx has "use client", exports MatchContext and MatchDataProvider
2. Check src/components/match/use-match.ts exports useMatch hook with null check
3. TypeScript compiles without errors (import from '@/types' works)
4. No direct Context value creation (ensure useMemo usage)
</verification>

<success_criteria>
MatchDataProvider Context infrastructure is ready:
- MatchDataProvider is a Client Component with memoized context value
- useMatch hook provides type-safe access with null check
- Match state (upcoming/live/finished) derived once in provider
- All types imported from @/types (Match, Competition, MatchAnalysis)
</success_criteria>

<output>
After completion, create `.planning/phases/26-context-foundation/26-01-SUMMARY.md` with:
- What was created (MatchDataProvider, useMatch, MatchContext)
- Context value interface definition
- Memoization strategy used
- Next plan(s) that depend on this infrastructure
</output>
