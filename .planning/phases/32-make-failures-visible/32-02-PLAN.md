---
phase: 32-make-failures-visible
plan: 02
type: execute
wave: 2
depends_on: ["32-01"]
files_modified:
  - src/lib/queue/workers/content.worker.ts
  - src/lib/content/match-content.ts
  - src/lib/queue/index.ts
autonomous: true

must_haves:
  truths:
    - "Content queue uses 120-second lock duration"
    - "Worker extends lock via heartbeat for long jobs"
    - "Failed jobs reach dead letter queue after retry exhaustion"
    - "Content validation rejects invalid content before database save"
  artifacts:
    - path: "src/lib/queue/workers/content.worker.ts"
      provides: "Worker with lock duration, heartbeat, DLQ handling"
      contains: "lockDuration"
    - path: "src/lib/content/match-content.ts"
      provides: "Content validation before save"
      contains: "validateGeneratedContent"
  key_links:
    - from: "src/lib/queue/workers/content.worker.ts"
      to: "bullmq"
      via: "worker.on('failed', ...)"
      pattern: "worker\\.on\\('failed'"
    - from: "src/lib/content/match-content.ts"
      to: "validateGeneratedContent"
      via: "validation before db insert"
      pattern: "validateGeneratedContent.*throw"
---

<objective>
Configure BullMQ worker with proper lock duration, heartbeat pattern, dead letter queue, and content validation to ensure failed jobs are visible and invalid content is rejected.

Purpose: Complete the error visibility pipeline - Plan 01 made functions throw errors, this plan ensures BullMQ properly retries those errors and moves exhausted jobs to DLQ for visibility.
Output: Production-ready content worker with retry, DLQ, and validation
</objective>

<execution_context>
@/Users/pieterbos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-make-failures-visible/32-CONTEXT.md
@.planning/phases/32-make-failures-visible/32-RESEARCH.md
@.planning/phases/32-make-failures-visible/32-01-SUMMARY.md
@src/lib/queue/workers/content.worker.ts
@src/lib/queue/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add content validation helper</name>
  <files>src/lib/content/match-content.ts</files>
  <action>
Add a validateGeneratedContent function and integrate it into all content generation functions:

1. **Add validation function** after imports, before generatePreMatchContent:
   ```typescript
   /**
    * Validate generated content meets quality thresholds
    * Throws if content is invalid (retryable - LLM may produce valid content on retry)
    */
   function validateGeneratedContent(
     content: string,
     contentType: 'pre-match' | 'betting' | 'post-match' | 'faq',
     minLength: number = 100
   ): void {
     // Length check
     if (content.length < minLength) {
       throw new Error(
         `Content too short: ${content.length} chars (min: ${minLength}) for ${contentType}`
       );
     }

     // Empty/whitespace check
     if (content.trim().length === 0) {
       throw new Error(`Content is empty or whitespace only for ${contentType}`);
     }

     // Placeholder detection
     const placeholders = [
       /\[TEAM NAME\]/gi,
       /\[PLACEHOLDER\]/gi,
       /lorem ipsum/gi,
       /\bTODO\b/gi,
       /\bFIXME\b/gi,
       /\{\{.*?\}\}/g,
       /\[Insert.*?\]/gi,
       /I cannot generate/gi,
       /As an AI/gi,
       /I'm unable to/gi,
     ];

     for (const pattern of placeholders) {
       if (pattern.test(content)) {
         throw new Error(
           `Placeholder detected in ${contentType} content: ${pattern.source}`
         );
       }
     }
   }
   ```

2. **Integrate validation** in each content generation function, AFTER LLM generation but BEFORE database save:

   For generatePreMatchContent (after line 97, before db save):
   ```typescript
   validateGeneratedContent(content, 'pre-match', 100);
   ```

   For generateBettingContent (after line 261, before db save):
   ```typescript
   validateGeneratedContent(content, 'betting', 100);
   ```

   For generatePostMatchContent (after line 430, before db save):
   ```typescript
   validateGeneratedContent(content, 'post-match', 100);
   ```

   For generateFAQContent - validation is different (JSON array), add after existing format check (line 649):
   ```typescript
   // Validate each FAQ answer meets minimum length
   for (const faq of result.content) {
     if (!faq.question || faq.question.length < 10) {
       throw new Error('FAQ question too short or missing');
     }
     if (!faq.answer || faq.answer.length < 20) {
       throw new Error('FAQ answer too short or missing');
     }
   }
   ```

These validations throw regular Errors (not RetryableContentError) because they occur BEFORE the catch block and will be caught by it, then wrapped in RetryableContentError with full context.
  </action>
  <verify>
Run `npx tsc --noEmit` - no TypeScript errors
Run `grep -c "validateGeneratedContent" src/lib/content/match-content.ts` - should return 4 (3 calls + 1 definition)
  </verify>
  <done>
- validateGeneratedContent function defined with length and placeholder checks
- Called before database save in pre-match, betting, and post-match functions
- FAQ validation checks question and answer lengths
- Invalid content triggers retry via error throwing
  </done>
</task>

<task type="auto">
  <name>Task 2: Configure worker with lock duration, heartbeat, and DLQ</name>
  <files>src/lib/queue/workers/content.worker.ts, src/lib/queue/index.ts</files>
  <action>
Update createContentWorker to add lock duration, heartbeat for long jobs, and dead letter queue handling:

1. **Add imports** at top of content.worker.ts:
   ```typescript
   import { Worker, Job, Queue } from 'bullmq';
   ```

2. **Update worker configuration** in createContentWorker (around line 94-101):
   ```typescript
   {
     connection: getQueueConnection(),
     concurrency: 3, // 3 parallel jobs (per CONTEXT.md decision)
     limiter: {
       max: 30,
       duration: 60000,
     },
     // Lock configuration (PIPE-02)
     lockDuration: 120000, // 2 minutes before job considered stalled
     stalledInterval: 30000, // Check for stalled jobs every 30s
     maxStalledCount: 1, // Fail after 1 stall detection
   }
   ```

3. **Add heartbeat for long-running jobs** - wrap the job processor:
   ```typescript
   async (job: Job<GenerateContentPayload>) => {
     const { type, data } = job.data;
     const log = loggers.contentWorker.child({ jobId: job.id, jobName: job.name });

     // Setup heartbeat to extend lock for long-running jobs
     const heartbeatInterval = setInterval(async () => {
       try {
         if (job.token) {
           await job.extendLock(job.token, 120000);
           log.debug({ jobId: job.id }, 'Extended job lock');
         }
       } catch (err) {
         log.warn({ jobId: job.id, err }, 'Lock extension failed');
       }
     }, 30000); // Every 30s (well before 120s lock expiry)

     try {
       log.info(`Generating ${type} content`);
       // ... existing job processing code ...
     } finally {
       clearInterval(heartbeatInterval);
     }
   }
   ```

4. **Add DLQ queue constant** in src/lib/queue/index.ts - find QUEUE_NAMES and add:
   ```typescript
   export const QUEUE_NAMES = {
     // ... existing names ...
     CONTENT_DLQ: 'content-dlq',
   };
   ```

5. **Add DLQ handling** in content.worker.ts, modify setupContentWorkerEvents:
   ```typescript
   export function setupContentWorkerEvents(worker: Worker) {
     const log = loggers.contentWorker;
     const dlqQueue = getQueue(QUEUE_NAMES.CONTENT_DLQ);

     worker.on('completed', (job) => {
       log.info({ jobId: job.id }, 'Job completed');
     });

     worker.on('failed', async (job, err) => {
       if (!job) return;

       log.error({ jobId: job.id, err }, 'Job failed');

       // Move to DLQ if retries exhausted
       if (job.attemptsMade >= (job.opts.attempts || 1)) {
         try {
           await dlqQueue.add('dlq-job', {
             originalJob: {
               id: job.id,
               name: job.name,
               data: job.data,
               attemptsMade: job.attemptsMade,
               failedReason: err.message,
               stackTrace: err.stack,
               timestamp: new Date().toISOString(),
             },
           }, {
             removeOnComplete: {
               age: 604800, // Keep DLQ jobs 7 days
             },
           });
           log.warn({ jobId: job.id }, 'Job moved to DLQ after retry exhaustion');
         } catch (dlqErr) {
           log.error({ jobId: job.id, err: dlqErr }, 'Failed to move job to DLQ');
         }
       }
     });

     worker.on('stalled', (jobId) => {
       log.warn({ jobId }, 'Job stalled');
     });

     worker.on('error', (err) => {
       log.error({ err }, 'Worker error');
     });
   }
   ```

6. **Ensure job retry configuration** - when jobs are added to the content queue, they should have retry settings. Check if getQueue returns a queue with default job options, or if callers need to specify. Add default job options to content queue if not already present.
  </action>
  <verify>
Run `npx tsc --noEmit` - no TypeScript errors
Run `grep "lockDuration" src/lib/queue/workers/content.worker.ts` - should find the setting
Run `grep "CONTENT_DLQ" src/lib/queue/index.ts` - should find the queue name
Run `grep "extendLock" src/lib/queue/workers/content.worker.ts` - should find heartbeat
  </verify>
  <done>
- Worker configured with 120s lockDuration (PIPE-02)
- Heartbeat extends lock every 30s for long jobs
- Concurrency set to 3 (per CONTEXT.md)
- DLQ queue name added to QUEUE_NAMES
- Failed jobs moved to DLQ after retry exhaustion (PIPE-04)
- Stalled job events logged
  </done>
</task>

<task type="auto">
  <name>Task 3: Configure job retry settings</name>
  <files>src/lib/queue/workers/content.worker.ts</files>
  <action>
Ensure content jobs have proper retry configuration when added to the queue.

1. **Update scanMatchesNeedingPreviews** (around line 175-199) to add retry config:
   ```typescript
   await contentQueue.add(
     'generate-match-preview',
     {
       type: 'match_preview',
       data: { ... },
     },
     {
       jobId: `preview-${match.id}`,
       // Retry configuration (per CONTEXT.md decisions)
       attempts: 5, // 5 retry attempts
       backoff: {
         type: 'exponential',
         delay: 30000, // 30s, 1m, 2m, 4m, 8m
       },
       removeOnComplete: {
         age: 86400,
         count: 100,
       },
       removeOnFail: {
         age: 604800, // Keep failed jobs 7 days for DLQ
       },
     }
   );
   ```

2. **Update scanAndGenerateLeagueRoundups** (around line 429-448) with same retry config

3. **Create a shared job options helper** at top of file to avoid duplication:
   ```typescript
   const CONTENT_JOB_OPTIONS = {
     attempts: 5,
     backoff: {
       type: 'exponential' as const,
       delay: 30000, // 30s base, exponential: 30s, 1m, 2m, 4m, 8m
     },
     removeOnComplete: {
       age: 86400,
       count: 100,
     },
     removeOnFail: {
       age: 604800,
     },
   };
   ```

4. **Use shared options** in all queue.add calls:
   ```typescript
   await contentQueue.add(
     'job-name',
     { type: '...', data: { ... } },
     {
       jobId: `unique-id`,
       ...CONTENT_JOB_OPTIONS,
     }
   );
   ```

This ensures all content jobs have consistent retry behavior with 5 attempts and exponential backoff.
  </action>
  <verify>
Run `npx tsc --noEmit` - no TypeScript errors
Run `grep "attempts: 5" src/lib/queue/workers/content.worker.ts` - should find the setting
Run `grep "exponential" src/lib/queue/workers/content.worker.ts` - should find backoff type
  </verify>
  <done>
- CONTENT_JOB_OPTIONS defined with 5 attempts and exponential backoff
- All contentQueue.add calls use shared options
- Jobs will retry 5 times with 30s, 1m, 2m, 4m, 8m delays
- Failed jobs kept 7 days for DLQ visibility
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. TypeScript compilation: `npx tsc --noEmit` passes
2. Content validation: `grep "validateGeneratedContent" src/lib/content/match-content.ts` shows 4 occurrences
3. Lock duration: `grep "lockDuration.*120000" src/lib/queue/workers/content.worker.ts` finds setting
4. DLQ configured: `grep "CONTENT_DLQ" src/lib/queue/index.ts` finds queue name
5. Retry configured: `grep "attempts: 5" src/lib/queue/workers/content.worker.ts` finds setting
6. Heartbeat implemented: `grep "extendLock" src/lib/queue/workers/content.worker.ts` finds implementation
</verification>

<success_criteria>
- PIPE-02 satisfied: Content queue uses 120-second lock duration
- PIPE-03 satisfied: Content validation runs before database save
- PIPE-04 satisfied: Failed jobs reach dead letter queue after retry exhaustion
- Worker has heartbeat pattern for long jobs
- Jobs configured with 5 attempts and exponential backoff
- DLQ jobs kept for 7 days
</success_criteria>

<output>
After completion, create `.planning/phases/32-make-failures-visible/32-02-SUMMARY.md`
</output>
