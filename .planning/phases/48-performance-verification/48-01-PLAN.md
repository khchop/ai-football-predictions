---
phase: 48-performance-verification
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/audit-internal-links.ts
  - src/app/leagues/[slug]/[match]/page.tsx
autonomous: true

must_haves:
  truths:
    - "Audit script includes Pass 6 that measures TTFB for sampled production URLs by page type"
    - "Pass 6 reports average TTFB per page type and flags pages exceeding 2s threshold"
    - "Pass 6 only runs when AUDIT_BASE_URL is set (consistent with Passes 1/4/5)"
    - "Match page generateMetadata parallelizes getMatchWithAnalysis and getOverallStats"
  artifacts:
    - path: "scripts/audit-internal-links.ts"
      provides: "Pass 6 TTFB measurement integrated into existing audit"
      contains: "pass6TTFBMeasurement"
    - path: "src/app/leagues/[slug]/[match]/page.tsx"
      provides: "Parallelized metadata queries"
      contains: "Promise.all"
  key_links:
    - from: "scripts/audit-internal-links.ts"
      to: "runAudit main function"
      via: "pass6 integrated after pass5 in runAudit()"
      pattern: "pass6.*=.*await.*pass6TTFB"
---

<objective>
Add Pass 6 TTFB measurement to the existing build-time audit script and parallelize the one identified sequential query pattern in match page metadata generation.

Purpose: Enables systematic TTFB measurement against production URLs and fixes the one easy-win query optimization found during code review. All other page types already use Promise.all() for data fetching.
Output: Updated audit script with 6 passes, optimized match page metadata generation.
</objective>

<execution_context>
@/Users/pieterbos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/48-performance-verification/48-CONTEXT.md
@.planning/phases/48-performance-verification/48-RESEARCH.md
@scripts/audit-internal-links.ts
@src/app/leagues/[slug]/[match]/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Pass 6 TTFB Measurement to Audit Script</name>
  <files>scripts/audit-internal-links.ts</files>
  <action>
Add Pass 6 TTFB measurement to the existing audit script. This integrates naturally after Pass 5 in the runAudit() function.

1. Add a `Pass6Result` interface extending `AuditResult` with: `totalChecked: number`, `slowPages: Array<{ url: string; ttfb: number; pageType: string }>`, `avgTTFBByType: Record<string, number>`.

2. Create `pass6TTFBMeasurement(baseUrl: string): Promise<Pass6Result>` function:
   - Reuse the same sitemap URL fetching pattern from Pass 1 (fetch /sitemap.xml, extract sub-sitemaps, collect all URLs)
   - Categorize URLs by page type:
     - 'Index pages': URLs matching /, /blog, /models, /matches, /leagues, /leaderboard, /about, /methodology
     - 'League pages': URLs starting with /leagues/ that don't contain a second path segment after the slug (no match sub-paths)
     - 'Match pages': URLs matching /leagues/*/[match-slug] pattern (has two segments after /leagues/)
     - 'Model pages': URLs starting with /models/ and not equal to /models
     - 'Blog pages': URLs starting with /blog/ and not equal to /blog
   - Sample up to 5 URLs per page type (use AUDIT_SAMPLE env var to control sample size, default 5 per type)
   - For each sampled URL, measure TTFB using `performance.now()` around a `fetch(url, { method: 'GET', headers: { 'User-Agent': 'Kroam-Audit/1.0' } })` call. Use GET not HEAD because some servers handle HEAD differently and PPR only works with GET.
   - Use AbortController with 10s timeout per request
   - Flag as FAILURE if TTFB >2000ms (per PERF-01 requirement)
   - Flag as WARNING if TTFB >1000ms
   - Calculate average TTFB per page type
   - TTFB failures should be WARNINGS not hard FAILURES in the audit (per user decision: "TTFB optimization is best-effort, not a blocker"). This means pass6.pass should remain true even if pages exceed 2s, but the slow pages should be reported clearly.

3. Integrate into `runAudit()`:
   - Add `let pass6: Pass6Result | null = null;` alongside existing pass variables
   - After Pass 5 block, add Pass 6 block gated by `if (baseUrl)` (consistent with Pass 1/4/5)
   - Print results: average TTFB per page type, list any slow pages (>2s), list warnings (>1s)
   - If no baseUrl, print: `Pass 6: SKIPPED (set AUDIT_BASE_URL to run TTFB measurement)`
   - Include pass6 warnings in the allWarnings aggregation (but NOT in allFailures since TTFB is best-effort)

4. Update the file header comment to include Pass 6 in the validation list.
  </action>
  <verify>
Run `npx tsx scripts/audit-internal-links.ts` (without AUDIT_BASE_URL) and verify:
- Pass 6 shows as SKIPPED
- All existing passes still work
- No TypeScript errors

Then verify the script compiles: `npx tsc --noEmit scripts/audit-internal-links.ts` or just verify the build succeeds.
  </verify>
  <done>Audit script has Pass 6 that measures TTFB by page type when AUDIT_BASE_URL is set, reports averages and slow pages as warnings (not failures), and skips gracefully without AUDIT_BASE_URL.</done>
</task>

<task type="auto">
  <name>Task 2: Parallelize Match Page Metadata Queries</name>
  <files>src/app/leagues/[slug]/[match]/page.tsx</files>
  <action>
In the `generateMetadata` function of the match page, there are 3 sequential awaits:
1. `getMatchBySlug(competitionSlug, match)` - needed first for existence check and match ID
2. `getMatchWithAnalysis(matchData.id)` - depends on match ID from step 1
3. `getOverallStats()` - INDEPENDENT of match data

Optimize by parallelizing steps 2 and 3:

Replace the current sequential pattern (lines ~46-67):
```typescript
const analysisData = await getMatchWithAnalysis(matchData.id).catch(() => null);
// ... analysis processing ...
const overallStats = await getOverallStats();
```

With parallel execution:
```typescript
const [analysisData, overallStats] = await Promise.all([
  getMatchWithAnalysis(matchData.id).catch(() => null),
  getOverallStats(),
]);
```

Keep the rest of the function identical. The `getMatchBySlug` call must remain first (sequential) because we need `matchData.id` for the analysis query and need to check for null/notFound.

This is a small optimization (saves ~50-100ms per match page metadata generation) but it's the only sequential pattern found in the codebase. All other page types already use Promise.all().
  </action>
  <verify>
Run `npm run build` (or `npx next build --webpack` if turbopack fails locally) to verify:
- Build completes without errors
- Match page compiles correctly
- No TypeScript errors
  </verify>
  <done>Match page generateMetadata uses Promise.all for getMatchWithAnalysis and getOverallStats, eliminating the only identified sequential query pattern.</done>
</task>

</tasks>

<verification>
1. `npx tsx scripts/audit-internal-links.ts` runs successfully with Pass 6 SKIPPED message
2. `npm run build` completes without errors
3. Audit script Pass 6 code follows same patterns as Passes 1-5 (interface, function, conditional execution, logging)
</verification>

<success_criteria>
- Audit script extended from 5 to 6 passes
- Pass 6 measures TTFB by page type with 2s threshold
- Pass 6 reports slow pages as warnings (not failures) per user decision
- Match page metadata queries parallelized
- Build passes
</success_criteria>

<output>
After completion, create `.planning/phases/48-performance-verification/48-01-SUMMARY.md`
</output>
