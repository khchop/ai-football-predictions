---
phase: 35-seo-geo-content-quality
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/MatchPageSchema.tsx
  - src/app/leagues/[slug]/[match]/page.tsx
autonomous: true

must_haves:
  truths:
    - "Match page schema includes Article type with datePublished"
    - "Match page schema includes Article type with dateModified"
    - "dateModified reflects when content was last generated"
  artifacts:
    - path: "src/components/MatchPageSchema.tsx"
      provides: "Article schema with date properties"
      contains: "datePublished"
    - path: "src/app/leagues/[slug]/[match]/page.tsx"
      provides: "Content timestamp passed to schema"
      contains: "contentGeneratedAt"
  key_links:
    - from: "src/app/leagues/[slug]/[match]/page.tsx"
      to: "MatchPageSchema"
      via: "contentGeneratedAt prop"
      pattern: "contentGeneratedAt.*="
---

<objective>
Add Article schema with datePublished and dateModified properties to match pages, passing the content generation timestamp from the database.

Purpose: Content freshness signals for AI search - content updated within 90 days receives 2.7x higher citation rates.
Output: Schema includes Article entity with date properties derived from match kickoffTime and content generation timestamp.
</objective>

<execution_context>
@/Users/pieterbos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/35-seo-geo-content-quality/35-RESEARCH.md

# Source files to modify
@src/components/MatchPageSchema.tsx
@src/app/leagues/[slug]/[match]/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Article schema with date properties to MatchPageSchema</name>
  <files>src/components/MatchPageSchema.tsx</files>
  <action>
Update the MatchPageSchema component to include an Article entity with datePublished and dateModified.

1. Update the interface to accept contentGeneratedAt:
```typescript
interface MatchPageSchemaProps {
  match: Match;
  competition: {
    name: string;
    slug: string;
  };
  url: string;
  faqs: FAQItem[];
  contentGeneratedAt?: string; // ISO timestamp when content was last generated
}
```

2. Update the function signature:
```typescript
export function MatchPageSchema({
  match,
  competition,
  url,
  faqs,
  contentGeneratedAt
}: MatchPageSchemaProps) {
```

3. Add date calculations after existing setup (after line ~48):
```typescript
// Dates for Article schema - content freshness signals
const datePublished = match.kickoffTime; // Initial content created around kickoff
const dateModified = contentGeneratedAt || match.updatedAt || match.kickoffTime;
```

4. Add Article entity to the @graph array (after WebPage, before FAQPage):
```typescript
// Article entity for content freshness signals (GEO optimization)
{
  '@type': 'Article',
  '@id': `${url}#article`,
  headline: `${matchName} - AI Predictions and Analysis`,
  description: pageDescription,
  datePublished: datePublished,
  dateModified: dateModified,
  author: {
    '@type': 'Organization',
    '@id': 'https://kroam.xyz#organization',
  },
  publisher: {
    '@type': 'Organization',
    '@id': 'https://kroam.xyz#organization',
  },
  mainEntityOfPage: { '@id': `${url}#webpage` },
  about: { '@id': url }, // References the SportsEvent
},
```

Note: The Article entity goes in the @graph array alongside existing Organization, WebSite, SportsEvent, WebPage, FAQPage, and BreadcrumbList entities.
  </action>
  <verify>
Read the modified file and confirm:
- Interface includes `contentGeneratedAt?: string`
- Function signature includes contentGeneratedAt parameter
- datePublished and dateModified variables are defined
- Article entity exists in @graph with datePublished and dateModified properties
  </verify>
  <done>
MatchPageSchema includes Article entity with datePublished (kickoffTime) and dateModified (contentGeneratedAt or fallback).
  </done>
</task>

<task type="auto">
  <name>Task 2: Pass contentGeneratedAt from match page to schema</name>
  <files>src/app/leagues/[slug]/[match]/page.tsx</files>
  <action>
Update the match page to fetch and pass the content generation timestamp to MatchPageSchema.

1. Add import for matchContent table (if not already imported via queries):
Check if getMatchFAQContent returns the timestamp, or add a query to get it.

2. Create a function to get content timestamp or modify existing data fetch.
Add to the Stage 2 parallel fetch (around line 97-114):
```typescript
const [
  analysisData,
  predictions,
  aiFaqs,
  contentTimestamp  // NEW: fetch content generation time
] = await Promise.all([
  getMatchWithAnalysis(matchData.id).catch(err => {
    console.error('Failed to fetch analysis:', err);
    return null;
  }),
  getPredictionsForMatchWithDetails(matchData.id).catch(err => {
    console.error('Failed to fetch predictions:', err);
    return [] as Awaited<ReturnType<typeof getPredictionsForMatchWithDetails>>;
  }),
  getMatchFAQContent(matchData.id).catch(err => {
    console.error('Failed to fetch FAQ content:', err);
    return null;
  }),
  // NEW: Get content generation timestamp
  getMatchContentTimestamp(matchData.id).catch(err => {
    console.error('Failed to fetch content timestamp:', err);
    return null;
  })
]);
```

3. If getMatchContentTimestamp doesn't exist, add it. Check if you need to:
   - Add import: `import { getMatchContentTimestamp } from '@/lib/content/match-content';`
   - Or add the function to match-content.ts:
```typescript
export async function getMatchContentTimestamp(matchId: string): Promise<string | null> {
  try {
    const db = getDb();
    const result = await db
      .select({ updatedAt: matchContent.updatedAt })
      .from(matchContent)
      .where(eq(matchContent.matchId, matchId))
      .limit(1);
    return result.length > 0 ? result[0].updatedAt : null;
  } catch {
    return null;
  }
}
```

4. Pass the timestamp to MatchPageSchema (around line 145-150):
```typescript
<MatchPageSchema
  match={matchData}
  competition={{ name: competition.name, slug: competitionSlug }}
  url={`https://kroam.xyz/leagues/${competitionSlug}/${matchData.slug}`}
  faqs={faqs}
  contentGeneratedAt={contentTimestamp || undefined}  // NEW
/>
```
  </action>
  <verify>
Read the modified files and confirm:
- getMatchContentTimestamp function exists in match-content.ts (or similar)
- Import added to page.tsx if needed
- contentTimestamp fetched in parallel with other data
- contentGeneratedAt prop passed to MatchPageSchema
  </verify>
  <done>
Match page fetches content timestamp and passes it to MatchPageSchema for dateModified calculation.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. MatchPageSchema includes Article entity with datePublished and dateModified
3. Match page passes contentGeneratedAt to schema
4. View page source shows Article schema in JSON-LD
</verification>

<success_criteria>
- SGEO-07: Content includes datePublished and dateModified schema properties
- Article schema properly references Organization, WebPage, and SportsEvent via @id
- dateModified reflects actual content generation time, not current time
</success_criteria>

<output>
After completion, create `.planning/phases/35-seo-geo-content-quality/35-03-SUMMARY.md`
</output>
