---
phase: 15-performance-optimization
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/leagues/[slug]/[match]/page.tsx
autonomous: true

must_haves:
  truths:
    - "Match page data fetching completes in ~300ms instead of ~1000ms (3x improvement)"
    - "Independent database queries execute in parallel, not sequentially"
    - "External API call (getMatchEvents) runs parallel with database queries"
    - "Page still renders correctly with all data"
  artifacts:
    - path: "src/app/leagues/[slug]/[match]/page.tsx"
      provides: "Parallel data fetching with Promise.all"
      contains: "Promise.all"
  key_links:
    - from: "MatchPage function"
      to: "getMatchWithAnalysis, getPredictionsForMatchWithDetails, getMatchEvents"
      via: "Promise.all"
      pattern: "await Promise\\.all"
---

<objective>
Parallelize data fetching in match page to eliminate request waterfall, reducing data loading time from ~1000ms to ~300ms.

Purpose: The research identified that match pages fetch 5-7 data sources sequentially (waterfall pattern), multiplying latency. The current pattern awaits each query before starting the next. Using Promise.all to initiate all independent queries simultaneously reduces total fetch time to max(individual query times) instead of sum(individual query times).

Output: Match page with two-stage parallel data fetching pattern
</objective>

<execution_context>
@/Users/pieterbos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-performance-optimization/15-RESEARCH.md

Primary reference:
@src/app/leagues/[slug]/[match]/page.tsx (MatchPage function starting line 92)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement two-stage parallel data fetching in MatchPage</name>
  <files>src/app/leagues/[slug]/[match]/page.tsx</files>
  <action>
    Refactor the MatchPage function to use two-stage parallel data fetching:

    **Stage 1 (Critical Path):** Fetch match data first since it's needed for:
    - notFound() check
    - Determining isFinished/isLive for conditional fetches
    - Extracting matchData.id for subsequent queries

    **Stage 2 (Parallel):** After match data is confirmed, fetch all remaining data in parallel using Promise.all:
    - getMatchWithAnalysis(matchData.id)
    - getPredictionsForMatchWithDetails(matchData.id)
    - getMatchEvents (conditional on isFinished/isLive)
    - getStandingsForTeams (with .catch() for graceful failure)
    - getNextMatchesForTeams (with .catch() for graceful failure)
    - getMatchRoundup (conditional on isFinished, with .catch())

    **Implementation pattern:**
    ```typescript
    export default async function MatchPage({ params }: MatchPageProps) {
      const { slug, match } = await params;

      // Competition config (sync operation)
      const competitionConfig = getCompetitionByIdOrAlias(slug);
      if (competitionConfig && slug !== competitionConfig.id) {
        permanentRedirect(`/leagues/${competitionConfig.id}/${match}`);
      }
      const competitionSlug = competitionConfig?.id || slug;

      // Stage 1: Critical path - match data (needed for conditionals and existence check)
      let result;
      try {
        result = await getMatchBySlug(competitionSlug, match);
      } catch (error) {
        console.error('Match page database error:', error);
        notFound();
      }

      if (!result) {
        notFound();
      }

      const { match: matchData, competition } = result;
      const isFinished = matchData.status === 'finished';
      const isLive = matchData.status === 'live';

      // Stage 2: Parallel fetch all remaining data
      const [
        analysisData,
        predictions,
        matchEvents,
        teamStandings,
        nextMatches,
        roundup
      ] = await Promise.all([
        getMatchWithAnalysis(matchData.id).catch(err => {
          console.error('Failed to fetch analysis:', err);
          return null;
        }),
        getPredictionsForMatchWithDetails(matchData.id).catch(err => {
          console.error('Failed to fetch predictions:', err);
          return [];
        }),
        (isFinished || isLive) && matchData.externalId
          ? getMatchEvents(parseInt(matchData.externalId, 10)).catch(err => {
              console.error('Failed to fetch match events:', err);
              return [];
            })
          : Promise.resolve([]),
        getStandingsForTeams(competition.apiFootballId, [matchData.homeTeam, matchData.awayTeam], competition.season).catch(err => {
          console.error('Failed to fetch team standings:', err);
          return [];
        }),
        getNextMatchesForTeams([matchData.homeTeam, matchData.awayTeam], 4).catch(err => {
          console.error('Failed to fetch next matches:', err);
          return [];
        }),
        isFinished
          ? getMatchRoundup(matchData.id).catch(err => {
              console.error('Failed to fetch match roundup:', err);
              return null;
            })
          : Promise.resolve(null)
      ]);

      const analysis = analysisData?.analysis;
      const kickoff = parseISO(matchData.kickoffTime);
      const homeStanding = teamStandings.find(s => s.teamName === matchData.homeTeam) || null;
      const awayStanding = teamStandings.find(s => s.teamName === matchData.awayTeam) || null;

      // Rest of component unchanged...
    }
    ```

    **Key points:**
    1. Keep critical path (getMatchBySlug) sequential - needed for notFound() and conditionals
    2. Use Promise.all for all independent queries
    3. Add .catch() to each promise for graceful degradation (don't let one failure break the page)
    4. Use Promise.resolve([]) or Promise.resolve(null) for conditional fetches to maintain consistent Promise.all array
    5. Remove the separate try/catch blocks for each data source - .catch() handles errors inline

    **WHY:** Sequential awaits create waterfall: 200ms + 200ms + 200ms + 200ms = 800ms. Parallel fetching: max(200ms, 200ms, 200ms, 200ms) = 200ms. This is ~4x improvement for the data fetching portion.
  </action>
  <verify>
    1. `grep -n "Promise.all" src/app/leagues/[slug]/[match]/page.tsx` returns at least one match
    2. `grep -c "await get" src/app/leagues/[slug]/[match]/page.tsx` shows only 2 awaits before Promise.all (params and getMatchBySlug)
    3. `npm run build` succeeds
    4. TypeScript has no errors: `npx tsc --noEmit`
  </verify>
  <done>
    - Promise.all used for parallel data fetching
    - Only critical path (getMatchBySlug) executed before Promise.all
    - Each promise has .catch() for graceful degradation
    - Build passes with no TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Simplify generateMetadata with parallel fetching</name>
  <files>src/app/leagues/[slug]/[match]/page.tsx</files>
  <action>
    The generateMetadata function (lines 41-83) also has sequential fetching that can be parallelized:

    Current pattern:
    ```typescript
    const result = await getMatchBySlug(competitionSlug, match);
    // ... null check
    const analysisData = await getMatchWithAnalysis(matchData.id);
    ```

    Optimized pattern:
    ```typescript
    const result = await getMatchBySlug(competitionSlug, match);
    if (!result) {
      return { title: 'Match Not Found', description: '...' };
    }
    const { match: matchData, competition } = result;

    // Fetch analysis in parallel with metadata generation
    // (Note: in this case, analysis fetch is the only remaining query,
    // so parallel benefit is minimal, but keeps pattern consistent)
    const analysisData = await getMatchWithAnalysis(matchData.id).catch(() => null);
    ```

    Since generateMetadata only has two sequential queries (match + analysis) and the second depends on the first's result, the main optimization is adding error handling with .catch().

    **WHY:** Consistent error handling pattern across page and metadata functions. If analysis fetch fails, metadata generation still succeeds with base match data.
  </action>
  <verify>
    1. generateMetadata function has .catch() on getMatchWithAnalysis call
    2. No breaking changes to metadata output
    3. Build succeeds
  </verify>
  <done>
    - generateMetadata has consistent error handling
    - Analysis fetch failure doesn't break metadata generation
    - Metadata still includes predicted scores when available
  </done>
</task>

</tasks>

<verification>
1. `grep "Promise.all" src/app/leagues/[slug]/[match]/page.tsx` shows parallel fetching pattern
2. Data fetching is parallelized (only getMatchBySlug awaited before Promise.all)
3. `npm run build` succeeds
4. Page renders correctly with all data sections
</verification>

<success_criteria>
- Promise.all used for parallel data fetching in MatchPage
- Sequential await count reduced from 7+ to 2 (params + critical path)
- Each promise has .catch() for graceful degradation
- Build passes, no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/15-performance-optimization/15-02-SUMMARY.md`
</output>
