---
phase: 15-performance-optimization
plan: 03
type: execute
wave: 2
depends_on: ["15-01", "15-02"]
files_modified:
  - src/app/api/admin/cache-stats/route.ts
autonomous: true

must_haves:
  truths:
    - "Admin can check Redis cache hit rate via API endpoint"
    - "Cache stats show hits, misses, and calculated hit rate percentage"
    - "Endpoint returns health status (healthy if >70%, needs-optimization if <70%)"
  artifacts:
    - path: "src/app/api/admin/cache-stats/route.ts"
      provides: "Cache monitoring API endpoint"
      exports: ["GET"]
      contains: "keyspace_hits"
  key_links:
    - from: "/api/admin/cache-stats"
      to: "Redis INFO stats"
      via: "redis.info('stats')"
      pattern: "info\\('stats'\\)"
---

<objective>
Create cache monitoring endpoint to measure Redis cache hit rate and validate the 70%+ target from success criteria.

Purpose: The research identified that cache metrics cannot be validated without monitoring. The project needs to measure actual cache hit rate to confirm ISR + parallel fetching optimizations are effective. Redis provides keyspace_hits and keyspace_misses via INFO stats command.

Output: Admin API endpoint at /api/admin/cache-stats returning hit rate metrics
</objective>

<execution_context>
@/Users/pieterbos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-performance-optimization/15-RESEARCH.md
@.planning/phases/15-performance-optimization/15-01-SUMMARY.md
@.planning/phases/15-performance-optimization/15-02-SUMMARY.md

Reference implementation from research:
@src/lib/cache/redis.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cache-stats API route</name>
  <files>src/app/api/admin/cache-stats/route.ts</files>
  <action>
    Create new API route to expose Redis cache statistics:

    ```typescript
    // src/app/api/admin/cache-stats/route.ts
    import { getRedis, isRedisAvailable } from '@/lib/cache/redis';
    import { NextResponse } from 'next/server';

    export const dynamic = 'force-dynamic'; // Always fresh stats

    export async function GET() {
      const redis = getRedis();

      if (!redis) {
        return NextResponse.json(
          {
            error: 'Redis not configured',
            status: 'unavailable'
          },
          { status: 503 }
        );
      }

      const available = await isRedisAvailable();
      if (!available) {
        return NextResponse.json(
          {
            error: 'Redis not available',
            status: 'unavailable'
          },
          { status: 503 }
        );
      }

      try {
        const info = await redis.info('stats');

        // Parse INFO output for keyspace metrics
        const hitsMatch = info.match(/keyspace_hits:(\d+)/);
        const missesMatch = info.match(/keyspace_misses:(\d+)/);

        const hits = hitsMatch ? parseInt(hitsMatch[1], 10) : 0;
        const misses = missesMatch ? parseInt(missesMatch[1], 10) : 0;
        const total = hits + misses;
        const hitRate = total > 0 ? (hits / total * 100) : 0;
        const hitRateFormatted = hitRate.toFixed(2);

        // Determine health status based on 70% target
        const status = hitRate >= 70
          ? 'healthy'
          : hitRate >= 50
            ? 'acceptable'
            : 'needs-optimization';

        return NextResponse.json({
          hits,
          misses,
          total,
          hitRate: `${hitRateFormatted}%`,
          hitRateRaw: hitRate,
          target: '70%+',
          status,
          timestamp: new Date().toISOString(),
        });
      } catch (error) {
        console.error('Failed to fetch cache stats:', error);
        return NextResponse.json(
          {
            error: 'Failed to fetch stats',
            message: error instanceof Error ? error.message : 'Unknown error'
          },
          { status: 500 }
        );
      }
    }
    ```

    **Key implementation details:**
    1. Use `force-dynamic` since we always want fresh stats (no caching for monitoring endpoint)
    2. Check both Redis configuration and availability before querying
    3. Parse Redis INFO stats output using regex (standard format: `keyspace_hits:12345`)
    4. Calculate hit rate with division-by-zero protection
    5. Return status based on thresholds: healthy (>=70%), acceptable (>=50%), needs-optimization (<50%)
    6. Include timestamp for monitoring dashboards

    **WHY:** This endpoint enables validation of success criteria "Cache hit rate exceeds 70% for match pages". Without monitoring, we cannot prove the optimization is effective.
  </action>
  <verify>
    1. File exists: `ls src/app/api/admin/cache-stats/route.ts`
    2. No TypeScript errors: `npx tsc --noEmit`
    3. Build succeeds: `npm run build`
  </verify>
  <done>
    - cache-stats route created at /api/admin/cache-stats
    - Endpoint returns hits, misses, hitRate, status
    - Error handling for Redis unavailable
    - TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Document cache monitoring in verification</name>
  <files>src/app/api/admin/cache-stats/route.ts</files>
  <action>
    Add JSDoc comments to the route explaining usage:

    ```typescript
    /**
     * Cache Statistics API
     *
     * Returns Redis cache hit rate metrics for monitoring performance optimization.
     *
     * @example
     * GET /api/admin/cache-stats
     *
     * Response:
     * {
     *   "hits": 12345,
     *   "misses": 1234,
     *   "total": 13579,
     *   "hitRate": "90.91%",
     *   "hitRateRaw": 90.90909090909091,
     *   "target": "70%+",
     *   "status": "healthy",
     *   "timestamp": "2026-02-02T12:00:00.000Z"
     * }
     *
     * Status values:
     * - "healthy": hit rate >= 70% (meets target)
     * - "acceptable": hit rate >= 50% (below target but functional)
     * - "needs-optimization": hit rate < 50% (investigate cache configuration)
     *
     * Success criteria: Phase 15 requires cache hit rate > 70%
     */
    ```

    Add this documentation block before the GET export.
  </action>
  <verify>
    1. JSDoc block present in file
    2. Documentation explains status values and success criteria
  </verify>
  <done>
    - API route documented with JSDoc
    - Status values explained
    - Success criteria referenced
  </done>
</task>

</tasks>

<verification>
1. `curl http://localhost:3000/api/admin/cache-stats` returns JSON with hits, misses, hitRate
2. Build passes: `npm run build`
3. No TypeScript errors: `npx tsc --noEmit`
</verification>

<success_criteria>
- /api/admin/cache-stats endpoint exists and returns cache metrics
- Response includes hits, misses, hitRate (%), and status
- Status reflects 70% target threshold
- Error handling for Redis unavailable
</success_criteria>

<output>
After completion, create `.planning/phases/15-performance-optimization/15-03-SUMMARY.md`
</output>
