---
phase: 04-ux-polish
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/components/error-boundary-provider.tsx
  - src/app/layout.tsx
  - src/components/match/predictions-section.tsx
autonomous: true

must_haves:
  truths:
    - "React rendering failures show error UI, not white screens"
    - "Async errors from data fetching are caught and displayed"
    - "Error UI includes a retry button that works"
  artifacts:
    - path: "src/components/error-boundary-provider.tsx"
      provides: "Reusable error boundary wrapper"
      contains: "ErrorBoundary"
    - path: "package.json"
      provides: "react-error-boundary dependency"
      contains: "react-error-boundary"
  key_links:
    - from: "src/app/layout.tsx"
      to: "src/components/error-boundary-provider.tsx"
      via: "ErrorBoundaryProvider import"
      pattern: "ErrorBoundaryProvider"
---

<objective>
Add react-error-boundary for comprehensive async error catching, preventing white screens from failed data fetches and event handlers.

Purpose: Satisfy UIUX-04 - error boundaries catch all React rendering failures (no white screens)
Output: ErrorBoundaryProvider component wrapping app, ErrorFallback component for consistent error UI
</objective>

<execution_context>
@/Users/pieterbos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-ux-polish/04-RESEARCH.md

# Existing error handling
@src/app/error.tsx
@src/app/layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install react-error-boundary and create ErrorBoundaryProvider</name>
  <files>package.json, src/components/error-boundary-provider.tsx</files>
  <action>
1. Install the package:
   ```bash
   npm install react-error-boundary
   ```

2. Create src/components/error-boundary-provider.tsx:
   ```tsx
   'use client';

   import { ErrorBoundary, FallbackProps } from 'react-error-boundary';
   import { AlertTriangle, RefreshCw } from 'lucide-react';
   import * as Sentry from '@sentry/nextjs';
   import { useEffect } from 'react';

   function ErrorFallback({ error, resetErrorBoundary }: FallbackProps) {
     useEffect(() => {
       // Send to GlitchTip error tracking (same as existing error.tsx)
       Sentry.captureException(error, {
         level: 'error',
         tags: {
           error_boundary: 'react_error_boundary',
         },
       });
       console.error('[ErrorBoundary]', error);
     }, [error]);

     return (
       <div className="rounded-xl border border-red-500/30 bg-red-500/10 p-6 text-center my-4">
         <div className="inline-flex items-center justify-center w-12 h-12 rounded-full bg-red-500/20 mb-4">
           <AlertTriangle className="h-6 w-6 text-red-500" />
         </div>
         <h2 className="text-lg font-semibold mb-2">Something went wrong</h2>
         <p className="text-sm text-muted-foreground mb-4">
           {error.message || 'An unexpected error occurred'}
         </p>
         <button
           onClick={resetErrorBoundary}
           className="inline-flex items-center gap-2 px-4 py-2 rounded-lg bg-primary text-primary-foreground hover:bg-primary/90 transition-colors"
         >
           <RefreshCw className="h-4 w-4" />
           Try again
         </button>
       </div>
     );
   }

   interface ErrorBoundaryProviderProps {
     children: React.ReactNode;
   }

   export function ErrorBoundaryProvider({ children }: ErrorBoundaryProviderProps) {
     return (
       <ErrorBoundary
         FallbackComponent={ErrorFallback}
         onReset={() => {
           // Clear any cached data that might be stale
           // For now, just let the component remount
         }}
       >
         {children}
       </ErrorBoundary>
     );
   }

   // Export ErrorFallback for use in more granular boundaries
   export { ErrorFallback };
   ```
  </action>
  <verify>
    1. `npm list react-error-boundary` shows ^4.x installed
    2. `npm run build` completes without TypeScript errors on new component
  </verify>
  <done>
    - react-error-boundary ^4.x installed
    - ErrorBoundaryProvider component created with ErrorFallback
    - Sentry integration for error tracking
  </done>
</task>

<task type="auto">
  <name>Task 2: Wrap app layout with ErrorBoundaryProvider</name>
  <files>src/app/layout.tsx</files>
  <action>
Wrap the children in RootLayout with ErrorBoundaryProvider:

1. Add import:
   ```tsx
   import { ErrorBoundaryProvider } from '@/components/error-boundary-provider';
   ```

2. Wrap the body children:
   ```tsx
   <body className={...}>
     <ThemeProvider ...>
       <NavBar />
       <main className="...">
         <ErrorBoundaryProvider>
           {children}
         </ErrorBoundaryProvider>
       </main>
       <Footer />
     </ThemeProvider>
   </body>
   ```

Note: Keep ErrorBoundaryProvider inside ThemeProvider and main so the error UI inherits theming and layout. Keep NavBar/Footer outside so navigation still works during errors.
  </action>
  <verify>
    1. `npm run build` completes without errors
    2. App still renders normally at localhost:3000
  </verify>
  <done>
    - RootLayout wraps children with ErrorBoundaryProvider
    - Navigation and footer remain accessible during errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Add granular error boundary to PredictionsSection</name>
  <files>src/components/match/predictions-section.tsx</files>
  <action>
Wrap the PredictionTable in a client-side error boundary for async data errors:

1. Since PredictionsSection is a Server Component, we need a client wrapper.
   Create an inline client component or use ErrorBoundary directly in the parent.

Actually, since PredictionsSection uses Suspense in the parent (match page), async errors in the server component should be caught by Next.js error.tsx.

For client-side interaction errors within PredictionTable (which is 'use client'), we can wrap it:

Option A: The ErrorBoundaryProvider at root level should catch most errors.

Option B: For more granular control, modify predictions-section.tsx to use a client wrapper:

The simpler approach: Leave PredictionsSection as-is since:
- It's a Server Component wrapped in Suspense
- Errors during server render go to error.tsx
- The root ErrorBoundaryProvider catches client-side errors in PredictionTable

If needed for finer control later, a PredictionsErrorBoundary can be added.

For this task: Verify the existing setup catches errors properly by:
1. Temporarily add a throw statement in PredictionTable
2. Confirm ErrorBoundaryProvider catches it
3. Remove the test throw

Actually, let's add a simple test to verify. No code change needed to predictions-section.tsx - the root ErrorBoundaryProvider already covers it.

Verification only - no files modified in this task.
  </action>
  <verify>
    1. Temporarily add `if (true) throw new Error('Test error')` at top of PredictionTable component
    2. Visit any match page
    3. Verify error UI appears (not white screen)
    4. Click "Try again" - should reload and work
    5. Remove the test throw statement
  </verify>
  <done>
    - Error boundary coverage verified for prediction components
    - Client-side errors caught by root ErrorBoundaryProvider
    - No white screens on render failures
  </done>
</task>

</tasks>

<verification>
1. Dependency installed: `npm list react-error-boundary` shows version
2. Build passes: `npm run build` exits 0
3. Error boundary works: Add temporary `throw new Error('test')` in any client component, verify error UI shows
4. Recovery works: Click "Try again" button in error UI, verify component re-renders
5. Sentry reports: Check GlitchTip for test error (if configured)
</verification>

<success_criteria>
- [ ] react-error-boundary ^4.x installed in package.json
- [ ] ErrorBoundaryProvider component exists at src/components/error-boundary-provider.tsx
- [ ] ErrorFallback shows error message and retry button
- [ ] RootLayout wraps children with ErrorBoundaryProvider
- [ ] Build passes without errors
- [ ] Intentional error shows error UI, not white screen
</success_criteria>

<output>
After completion, create `.planning/phases/04-ux-polish/04-03-SUMMARY.md`
</output>
