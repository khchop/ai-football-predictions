---
phase: 03-infrastructure-performance
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/lib/db/schema.ts
  - src/lib/utils/circuit-breaker.ts
autonomous: true

must_haves:
  truths:
    - "Circuit breaker state persists through Redis restarts"
    - "Circuit state is recovered from database when Redis unavailable"
    - "State transitions are logged for monitoring"
    - "App starts correctly even if Redis is down"
  artifacts:
    - path: "src/lib/db/schema.ts"
      provides: "circuitBreakerStates table definition"
      contains: "circuitBreakerStates"
    - path: "src/lib/utils/circuit-breaker.ts"
      provides: "Dual persistence (Redis + DB)"
      contains: "saveCircuitToDatabase"
  key_links:
    - from: "src/lib/utils/circuit-breaker.ts"
      to: "src/lib/db/schema.ts"
      via: "database insert/update for circuit state"
      pattern: "circuitBreakerStates"
    - from: "src/lib/utils/circuit-breaker.ts"
      to: "src/lib/cache/redis.ts"
      via: "Redis cache for fast access"
      pattern: "cacheSet|cacheGet"
---

<objective>
Add database fallback for circuit breaker state persistence to survive Redis restarts.

Purpose: Currently circuit breaker state is only in Redis. When Redis restarts, all circuits reset to closed, potentially flooding external APIs. Database fallback ensures state survives.

Output: Circuit breaker with Redis primary + database fallback persistence.
</objective>

<execution_context>
@/Users/pieterbos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-infrastructure-performance/03-RESEARCH.md

@src/lib/utils/circuit-breaker.ts
@src/lib/db/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add circuit breaker states table to database schema</name>
  <files>src/lib/db/schema.ts</files>
  <action>
Add a new table definition for circuit breaker state persistence:

```typescript
// Circuit breaker state persistence (survives Redis restarts)
export const circuitBreakerStates = pgTable('circuit_breaker_states', {
  service: text('service').primaryKey(), // 'api-football', 'together-predictions', etc.
  state: text('state').notNull().default('closed'), // 'closed', 'open', 'half-open'
  failures: integer('failures').default(0),
  successes: integer('successes').default(0),
  lastFailureAt: timestamp('last_failure_at'),
  lastStateChange: timestamp('last_state_change').defaultNow(),
  totalFailures: integer('total_failures').default(0),
  totalSuccesses: integer('total_successes').default(0),
  updatedAt: timestamp('updated_at').defaultNow(),
});

export type CircuitBreakerState = typeof circuitBreakerStates.$inferSelect;
export type NewCircuitBreakerState = typeof circuitBreakerStates.$inferInsert;
```

Place this after the modelUsage table definition.

Then run: `npx drizzle-kit push` to apply the schema change.
  </action>
  <verify>
    - Schema compiles: `npx tsc --noEmit`
    - Table exists: `npx drizzle-kit push` succeeds or shows table already exists
  </verify>
  <done>
    - circuitBreakerStates table defined in schema
    - Types exported for application use
    - Database migration applied
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement dual persistence in circuit breaker</name>
  <files>src/lib/utils/circuit-breaker.ts</files>
  <action>
Refactor circuit breaker to persist to both Redis and database:

1. Add database imports at top:
```typescript
import { db } from '@/lib/db';
import { circuitBreakerStates } from '@/lib/db/schema';
import { eq } from 'drizzle-orm';
```

2. Add database persistence functions:
```typescript
/**
 * Save circuit state to database (fallback for Redis failure)
 */
async function saveCircuitToDatabase(service: ServiceName, status: CircuitStatus): Promise<void> {
  try {
    await db.insert(circuitBreakerStates).values({
      service,
      state: status.state,
      failures: status.failures,
      successes: status.successes,
      lastFailureAt: status.lastFailureAt ? new Date(status.lastFailureAt) : null,
      lastStateChange: new Date(status.lastStateChange),
      totalFailures: status.totalFailures,
      totalSuccesses: status.totalSuccesses,
      updatedAt: new Date(),
    }).onConflictDoUpdate({
      target: circuitBreakerStates.service,
      set: {
        state: status.state,
        failures: status.failures,
        successes: status.successes,
        lastFailureAt: status.lastFailureAt ? new Date(status.lastFailureAt) : null,
        lastStateChange: new Date(status.lastStateChange),
        totalFailures: status.totalFailures,
        totalSuccesses: status.totalSuccesses,
        updatedAt: new Date(),
      },
    });
  } catch (error) {
    loggers.circuitBreaker.error({ service, error }, 'Failed to save circuit state to database');
  }
}

/**
 * Load circuit state from database (fallback for Redis miss)
 */
async function loadCircuitFromDatabase(service: ServiceName): Promise<CircuitStatus | null> {
  try {
    const dbState = await db.query.circuitBreakerStates.findFirst({
      where: eq(circuitBreakerStates.service, service),
    });

    if (dbState) {
      return {
        state: dbState.state as CircuitState,
        failures: dbState.failures ?? 0,
        successes: dbState.successes ?? 0,
        lastFailureAt: dbState.lastFailureAt?.getTime() ?? 0,
        lastStateChange: dbState.lastStateChange?.getTime() ?? Date.now(),
        totalFailures: dbState.totalFailures ?? 0,
        totalSuccesses: dbState.totalSuccesses ?? 0,
      };
    }
  } catch (error) {
    loggers.circuitBreaker.error({ service, error }, 'Failed to load circuit state from database');
  }
  return null;
}
```

3. Modify `persistCircuitToRedis` to also save to database:
```typescript
async function persistCircuitToRedis(service: ServiceName, circuit: CircuitStatus): Promise<void> {
  // Try Redis first (fast)
  try {
    await cacheSet(getCircuitKey(service), circuit, CIRCUIT_BREAKER_TTL);
  } catch (error) {
    loggers.circuitBreaker.warn({ service, error }, 'Failed to persist circuit state to Redis');
  }

  // Always save to database (durable)
  await saveCircuitToDatabase(service, circuit);
}
```

4. Modify `loadCircuitFromRedis` to fall back to database:
```typescript
async function loadCircuitFromRedis(service: ServiceName): Promise<CircuitStatus | null> {
  // Try Redis first (fast)
  try {
    const cached = await cacheGet<CircuitStatus>(getCircuitKey(service));
    if (cached) {
      loggers.circuitBreaker.debug({ service }, 'Loaded circuit state from Redis');
      return cached;
    }
  } catch (error) {
    loggers.circuitBreaker.warn({ service, error }, 'Failed to load circuit state from Redis');
  }

  // Fall back to database
  const dbState = await loadCircuitFromDatabase(service);
  if (dbState) {
    loggers.circuitBreaker.info({ service }, 'Loaded circuit state from database (Redis fallback)');
    // Repopulate Redis cache
    await cacheSet(getCircuitKey(service), dbState, CIRCUIT_BREAKER_TTL).catch(() => {
      // Ignore cache errors, DB is source of truth
    });
    return dbState;
  }

  return null;
}
```

5. Update `initializeCircuitsFromRedis` to use the updated load function (already uses loadCircuitFromRedis, so it will get fallback automatically).
  </action>
  <verify>
    - TypeScript compiles: `npx tsc --noEmit`
    - Database functions exist: `grep -l "saveCircuitToDatabase\|loadCircuitFromDatabase" src/lib/utils/circuit-breaker.ts`
  </verify>
  <done>
    - Circuit breaker persists to both Redis and database
    - Load falls back to database when Redis unavailable
    - State survives Redis restarts
  </done>
</task>

</tasks>

<verification>
1. Build passes: `npm run build`
2. TypeScript compiles: `npx tsc --noEmit`
3. Database table exists: Check via Drizzle Studio or psql
4. Dual persistence in code: `grep -A5 "persistCircuitToRedis" src/lib/utils/circuit-breaker.ts` shows database save
5. Fallback in code: `grep -A5 "loadCircuitFromRedis" src/lib/utils/circuit-breaker.ts` shows database fallback
</verification>

<success_criteria>
- circuitBreakerStates table exists in database
- Circuit state is saved to both Redis and database on every state change
- Circuit state loads from database when Redis unavailable
- No runtime errors when Redis is temporarily down
- Build and typecheck pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-infrastructure-performance/03-02-SUMMARY.md`
</output>
