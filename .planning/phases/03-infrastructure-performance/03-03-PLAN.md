---
phase: 03-infrastructure-performance
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/football/api-budget.ts
  - src/lib/football/api-client.ts
  - src/lib/cache/redis.ts
autonomous: true

must_haves:
  truths:
    - "API-Football requests are tracked against 100/day budget"
    - "Budget exceeded throws clear error with reset time"
    - "System continues working when Redis unavailable (degraded mode)"
    - "Budget resets automatically at midnight UTC"
  artifacts:
    - path: "src/lib/football/api-budget.ts"
      provides: "Budget tracking with Redis atomic counters"
      exports: ["checkAndIncrementBudget", "getBudgetStatus", "BudgetExceededError"]
    - path: "src/lib/football/api-client.ts"
      provides: "Budget check integration in fetch"
      contains: "checkAndIncrementBudget"
  key_links:
    - from: "src/lib/football/api-client.ts"
      to: "src/lib/football/api-budget.ts"
      via: "budget check before API call"
      pattern: "checkAndIncrementBudget"
    - from: "src/lib/football/api-budget.ts"
      to: "src/lib/cache/redis.ts"
      via: "Redis INCR for atomic counting"
      pattern: "getRedis|redis\\.incr"
---

<objective>
Add API budget enforcement for API-Football and improve Redis graceful degradation.

Purpose: API-Football free tier has 100 requests/day limit. Without tracking, we can exceed budget and get blocked. Also need to ensure system continues when Redis is temporarily unavailable.

Output: Budget tracking with automatic reset and graceful Redis degradation.
</objective>

<execution_context>
@/Users/pieterbos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-infrastructure-performance/03-RESEARCH.md

@src/lib/football/api-client.ts
@src/lib/cache/redis.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create API budget tracking module</name>
  <files>src/lib/football/api-budget.ts</files>
  <action>
Create a new module for API budget enforcement using Redis atomic counters:

```typescript
/**
 * API Budget Enforcement
 *
 * Tracks daily API request count using Redis atomic counters.
 * - Uses INCR for atomic counting (no race conditions)
 * - Uses TTL for automatic midnight UTC reset
 * - Fails open when Redis unavailable (availability > strict enforcement)
 */

import { getRedis } from '@/lib/cache/redis';
import { loggers } from '@/lib/logger/modules';

const log = loggers.apiFootball;

// API-Football free tier: 100 requests per day
const API_FOOTBALL_DAILY_LIMIT = 100;

export interface BudgetStatus {
  used: number;
  limit: number;
  remaining: number;
  resetsAt: Date;
}

export class BudgetExceededError extends Error {
  constructor(
    message: string,
    public readonly used: number,
    public readonly limit: number,
    public readonly resetsAt: Date
  ) {
    super(message);
    this.name = 'BudgetExceededError';
  }
}

/**
 * Get seconds until next midnight UTC
 */
function getSecondsUntilMidnightUTC(): number {
  const now = new Date();
  const midnight = new Date(Date.UTC(
    now.getUTCFullYear(),
    now.getUTCMonth(),
    now.getUTCDate() + 1,
    0, 0, 0, 0
  ));
  return Math.floor((midnight.getTime() - now.getTime()) / 1000);
}

/**
 * Get next midnight UTC as Date
 */
function getNextMidnightUTC(): Date {
  const now = new Date();
  return new Date(Date.UTC(
    now.getUTCFullYear(),
    now.getUTCMonth(),
    now.getUTCDate() + 1,
    0, 0, 0, 0
  ));
}

/**
 * Get Redis key for today's API budget counter
 */
function getBudgetKey(apiName: string): string {
  const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
  return `api:budget:${apiName}:${today}`;
}

/**
 * Check and increment API budget atomically
 *
 * @throws BudgetExceededError if daily limit exceeded
 * @returns Current budget status
 */
export async function checkAndIncrementBudget(apiName: string = 'api-football'): Promise<BudgetStatus> {
  const limit = API_FOOTBALL_DAILY_LIMIT;
  const resetsAt = getNextMidnightUTC();

  const redis = getRedis();
  if (!redis) {
    // Redis unavailable: fail open (allow request, log warning)
    log.warn({ apiName }, 'Budget tracking unavailable (Redis down), allowing request');
    return { used: 0, limit, remaining: limit, resetsAt };
  }

  const key = getBudgetKey(apiName);

  try {
    // Atomic increment
    const used = await redis.incr(key);

    // Set TTL on first request of the day (key didn't exist before)
    if (used === 1) {
      const ttl = getSecondsUntilMidnightUTC();
      await redis.expire(key, ttl);
      log.info({ apiName, ttl }, 'Budget counter initialized for new day');
    }

    // Check if budget exceeded
    if (used > limit) {
      throw new BudgetExceededError(
        `API-Football daily budget exceeded: ${used}/${limit}. Resets at ${resetsAt.toISOString()}`,
        used,
        limit,
        resetsAt
      );
    }

    const status: BudgetStatus = {
      used,
      limit,
      remaining: limit - used,
      resetsAt,
    };

    // Log budget status periodically (every 10 requests or when low)
    if (used % 10 === 0 || status.remaining <= 10) {
      log.info({ apiName, ...status }, 'API budget status');
    }

    return status;

  } catch (error) {
    if (error instanceof BudgetExceededError) {
      throw error;
    }

    // Redis error: fail open (log and allow)
    log.error({ apiName, error }, 'Budget check failed (Redis error), allowing request');
    return { used: 0, limit, remaining: limit, resetsAt };
  }
}

/**
 * Get current budget status without incrementing
 */
export async function getBudgetStatus(apiName: string = 'api-football'): Promise<BudgetStatus> {
  const limit = API_FOOTBALL_DAILY_LIMIT;
  const resetsAt = getNextMidnightUTC();

  const redis = getRedis();
  if (!redis) {
    return { used: 0, limit, remaining: limit, resetsAt };
  }

  try {
    const key = getBudgetKey(apiName);
    const usedStr = await redis.get(key);
    const used = usedStr ? parseInt(usedStr, 10) : 0;

    return {
      used,
      limit,
      remaining: Math.max(0, limit - used),
      resetsAt,
    };
  } catch (error) {
    log.error({ apiName, error }, 'Failed to get budget status');
    return { used: 0, limit, remaining: limit, resetsAt };
  }
}
```
  </action>
  <verify>
    - File exists: `ls src/lib/football/api-budget.ts`
    - TypeScript compiles: `npx tsc --noEmit`
    - Exports correct: `grep -l "checkAndIncrementBudget\|BudgetExceededError" src/lib/football/api-budget.ts`
  </verify>
  <done>
    - api-budget.ts module created
    - Atomic INCR-based counting implemented
    - TTL-based automatic reset at midnight UTC
    - Fail-open on Redis errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate budget check into API client</name>
  <files>src/lib/football/api-client.ts</files>
  <action>
Add budget enforcement to the API client:

1. Add import at top:
```typescript
import { checkAndIncrementBudget, BudgetExceededError } from './api-budget';
```

2. Modify `fetchFromAPIFootball` to check budget BEFORE making request:
```typescript
export async function fetchFromAPIFootball<T>({ endpoint, params }: FetchOptions): Promise<T> {
  const apiKey = process.env.API_FOOTBALL_KEY;

  if (!apiKey) {
    throw new Error('API_FOOTBALL_KEY is not configured');
  }

  // Check and increment budget BEFORE making request
  // This ensures we don't exceed limit even if request fails
  try {
    const budget = await checkAndIncrementBudget('api-football');
    log.debug({
      remaining: budget.remaining,
      used: budget.used,
      endpoint
    }, 'Budget check passed');
  } catch (error) {
    if (error instanceof BudgetExceededError) {
      log.warn({
        endpoint,
        used: error.used,
        limit: error.limit,
        resetsAt: error.resetsAt.toISOString()
      }, 'API request blocked - daily budget exceeded');
      throw error;
    }
    // Other errors logged in checkAndIncrementBudget, continue with request
  }

  // ... rest of existing function unchanged ...
```

3. Add re-export for convenience:
```typescript
export { BudgetExceededError } from './api-budget';
```

NOTE: The budget check happens BEFORE the fetch, so we count the attempt not the success. This is intentional - failed attempts still count against quota.
  </action>
  <verify>
    - TypeScript compiles: `npx tsc --noEmit`
    - Budget check in code: `grep -l "checkAndIncrementBudget" src/lib/football/api-client.ts`
  </verify>
  <done>
    - Budget check integrated into API client
    - Requests blocked when budget exceeded
    - BudgetExceededError propagated for handling
  </done>
</task>

<task type="auto">
  <name>Task 3: Improve Redis graceful degradation in cache module</name>
  <files>src/lib/cache/redis.ts</files>
  <action>
Enhance graceful degradation for all cache operations:

1. Add a centralized Redis health check with in-memory fallback state:
```typescript
// In-memory fallback for Redis unavailability
let lastKnownRedisState: 'available' | 'unavailable' = 'available';

/**
 * Check if Redis should be used (with circuit breaker behavior)
 * If Redis was recently unavailable, short-circuit to avoid blocking
 */
export function shouldUseRedis(): boolean {
  const redis = getRedis();
  if (!redis) return false;

  // If we know Redis is down, don't even try for 5 seconds
  if (lastKnownRedisState === 'unavailable') {
    return false;
  }

  return true;
}

/**
 * Mark Redis as unavailable (called on connection failures)
 */
export function markRedisUnavailable(): void {
  if (lastKnownRedisState !== 'unavailable') {
    lastKnownRedisState = 'unavailable';
    loggers.cache.warn('Redis marked as unavailable - operating in degraded mode');

    // Schedule recovery check after 5 seconds
    setTimeout(() => {
      lastKnownRedisState = 'available'; // Allow retry
    }, 5000);
  }
}
```

2. Update `cacheGet` to use graceful degradation:
```typescript
export async function cacheGet<T>(key: string): Promise<T | null> {
  if (!shouldUseRedis()) return null;

  const redis = getRedis();
  if (!redis) return null;

  try {
    const cached = await redis.get(key);
    if (cached === null) return null;
    if (cached === CACHE_NULL_SENTINEL) return null;
    return JSON.parse(cached) as T;
  } catch (error) {
    markRedisUnavailable();
    loggers.cache.error({ key, error: error instanceof Error ? error.message : String(error) }, 'Cache get failed');
    return null;
  }
}
```

3. Update `cacheSet` similarly:
```typescript
export async function cacheSet<T>(
  key: string,
  value: T,
  ttlSeconds: number
): Promise<boolean> {
  if (!shouldUseRedis()) return false;

  const redis = getRedis();
  if (!redis) return false;

  // ... existing serialization logic ...

  try {
    await redis.setex(key, ttlSeconds, serialized);
    return true;
  } catch (error) {
    markRedisUnavailable();
    loggers.cache.error({ key, ttl: ttlSeconds, error: error instanceof Error ? error.message : String(error) }, 'Cache set failed');
    return false;
  }
}
```

4. Update `cacheDelete` and `cacheDeletePattern` with same pattern:
- Add `if (!shouldUseRedis()) return ...;` at start
- Add `markRedisUnavailable()` in catch blocks

5. Update `withCache` to handle degradation:
```typescript
export async function withCache<T>(
  key: string,
  ttlSeconds: number,
  fetchFn: () => Promise<T>
): Promise<T> {
  // Try cache only if Redis is healthy
  if (shouldUseRedis()) {
    const redis = getRedis();
    if (redis) {
      try {
        const cached = await redis.get(key);
        if (cached !== null) {
          if (cached === CACHE_NULL_SENTINEL) {
            return null as T;
          }
          return JSON.parse(cached) as T;
        }
      } catch (error) {
        markRedisUnavailable();
        loggers.cache.warn({ key, error: error instanceof Error ? error.message : String(error) }, 'Cache read failed, fetching fresh');
      }
    }
  }

  // Cache miss or Redis unavailable - fetch fresh
  const data = await fetchFn();

  // Try to cache (fire and forget)
  if (shouldUseRedis()) {
    cacheSet(key, data, ttlSeconds).catch(() => {
      // Error already logged in cacheSet
    });
  }

  return data;
}
```

This ensures:
- No blocking calls to Redis when it's known to be down
- Automatic retry after 5 seconds cooldown
- Application continues serving requests without cache
  </action>
  <verify>
    - TypeScript compiles: `npx tsc --noEmit`
    - Graceful degradation in code: `grep -l "shouldUseRedis\|markRedisUnavailable" src/lib/cache/redis.ts`
  </verify>
  <done>
    - All cache operations fail gracefully when Redis unavailable
    - 5-second cooldown prevents repeated connection attempts
    - Application continues serving (uncached) when Redis is down
    - Clear logging of degraded mode
  </done>
</task>

</tasks>

<verification>
1. Build passes: `npm run build`
2. TypeScript compiles: `npx tsc --noEmit`
3. Budget module exists: `ls src/lib/football/api-budget.ts`
4. Budget integrated: `grep "checkAndIncrementBudget" src/lib/football/api-client.ts`
5. Graceful degradation: `grep "shouldUseRedis" src/lib/cache/redis.ts`
6. Start dev server and check logs for budget tracking on API calls
</verification>

<success_criteria>
- API requests tracked against 100/day budget
- Budget exceeded throws BudgetExceededError with reset time
- Application continues when Redis unavailable
- No crashes or hanging when Redis connection fails
- Build and typecheck pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-infrastructure-performance/03-03-SUMMARY.md`
</output>
