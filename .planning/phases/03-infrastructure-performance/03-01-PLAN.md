---
phase: 03-infrastructure-performance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/matches/[id]/page.tsx
  - src/components/match/predictions-section.tsx
  - src/components/match/match-header.tsx
  - src/components/match/match-odds.tsx
autonomous: true

must_haves:
  truths:
    - "Match page renders header and metadata within 500ms"
    - "Predictions section streams in after initial render"
    - "Skeleton shows during prediction load"
    - "Page does not flash or reflow after streaming completes"
  artifacts:
    - path: "src/app/matches/[id]/page.tsx"
      provides: "Streaming SSR with Suspense boundaries"
      contains: "<Suspense"
    - path: "src/components/match/predictions-section.tsx"
      provides: "Async Server Component for predictions"
      exports: ["PredictionsSection"]
    - path: "src/components/match/match-header.tsx"
      provides: "Fast match metadata component"
      exports: ["MatchHeader"]
  key_links:
    - from: "src/app/matches/[id]/page.tsx"
      to: "src/components/match/predictions-section.tsx"
      via: "Suspense boundary wrapping async component"
      pattern: "Suspense.*PredictionsSection"
---

<objective>
Optimize match detail page with streaming SSR using React Suspense boundaries.

Purpose: Match pages with 35+ predictions currently block on all data loading. Streaming allows fast initial render while slow predictions load in background.

Output: Match page with sub-500ms TTFB and streaming predictions.
</objective>

<execution_context>
@/Users/pieterbos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-infrastructure-performance/03-RESEARCH.md

@src/app/matches/[id]/page.tsx
@src/components/prediction-table.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract match header and odds into separate components</name>
  <files>
    src/components/match/match-header.tsx
    src/components/match/match-odds.tsx
  </files>
  <action>
Create two new Server Components extracted from the current page:

1. `src/components/match/match-header.tsx`:
   - Takes match, competition, isLive, isFinished as props
   - Renders: back link, competition/status header, team logos/names, score (or VS), date/time/venue
   - This is FAST data (already fetched by page)
   - Export as `MatchHeader`

2. `src/components/match/match-odds.tsx`:
   - Takes analysis, likelyScores as props
   - Renders: betting odds panel, predictions, over/under, BTTS, likely scores
   - This is FAST data (already in analysis object)
   - Export as `MatchOddsPanel`

Keep existing styling and structure - just extract into components for composition.
  </action>
  <verify>
    - Files exist and export correctly: `grep -l "export.*MatchHeader\|export.*MatchOddsPanel" src/components/match/*.tsx`
    - TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>
    - MatchHeader and MatchOddsPanel components exist
    - Components are typed Server Components (no 'use client')
    - All existing UI preserved
  </done>
</task>

<task type="auto">
  <name>Task 2: Create async predictions section with Suspense</name>
  <files>
    src/components/match/predictions-section.tsx
    src/components/match/predictions-skeleton.tsx
  </files>
  <action>
1. Create `src/components/match/predictions-section.tsx`:
   - Async Server Component that takes matchId as prop
   - Fetches predictions internally: `const predictions = await getPredictionsForMatchWithDetails(matchId)`
   - Renders the PredictionTable with fetched data
   - Includes the MatchRoundup at bottom (also async)
   - Export as `PredictionsSection`

2. Create `src/components/match/predictions-skeleton.tsx`:
   - Client component with loading skeleton for 35 prediction cards
   - Use existing skeleton patterns from the codebase
   - Fixed height to prevent layout shift (estimate based on actual card sizes)
   - Export as `PredictionsSkeleton`

Pattern from research:
```tsx
// predictions-section.tsx
export async function PredictionsSection({ matchId, homeTeam, awayTeam, isFinished }: Props) {
  const predictions = await getPredictionsForMatchWithDetails(matchId);
  return (
    <>
      <Card className="bg-card/50 border-border/50">
        <CardContent className="p-6">
          <h2>AI Model Predictions</h2>
          <PredictionTable predictions={...} />
        </CardContent>
      </Card>
      <MatchRoundup matchId={matchId} isFinished={isFinished} />
    </>
  );
}
```
  </action>
  <verify>
    - Files exist: `ls src/components/match/predictions-*.tsx`
    - TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>
    - PredictionsSection is async Server Component
    - PredictionsSkeleton provides loading state
    - No 'use client' directive on PredictionsSection
  </done>
</task>

<task type="auto">
  <name>Task 3: Refactor match page to use Suspense streaming</name>
  <files>src/app/matches/[id]/page.tsx</files>
  <action>
Refactor the page to use streaming SSR:

1. Import new components:
   - `import { MatchHeader } from '@/components/match/match-header'`
   - `import { MatchOddsPanel } from '@/components/match/match-odds'`
   - `import { PredictionsSection } from '@/components/match/predictions-section'`
   - `import { PredictionsSkeleton } from '@/components/match/predictions-skeleton'`
   - `import { Suspense } from 'react'`

2. Restructure the page component:
   - Keep fast data fetching at top: getMatchWithAnalysis, getMatchEvents (these are cached/fast)
   - Remove getPredictionsForMatchWithDetails call (moved to PredictionsSection)
   - Render MatchHeader and MatchOddsPanel immediately (fast)
   - Wrap PredictionsSection in Suspense with PredictionsSkeleton fallback

3. Streaming structure:
```tsx
export default async function MatchPage({ params }: Props) {
  const { id } = await params;
  const result = await getMatchWithAnalysis(id);
  // ... existing redirect/notFound logic

  const matchEvents = (isFinished || isLive) && match.externalId
    ? await getMatchEvents(parseInt(match.externalId, 10))
    : [];

  return (
    <>
      <script type="application/ld+json">...</script>
      <div className="max-w-4xl mx-auto space-y-8">
        <MatchHeader match={match} competition={competition} isLive={isLive} isFinished={isFinished} />

        {(isFinished || isLive) && matchEvents.length > 0 && (
          <MatchEvents events={matchEvents} ... />
        )}

        <MatchOddsPanel analysis={analysis} likelyScores={likelyScores} isFinished={isFinished} isLive={isLive} />

        {/* Slow predictions stream in */}
        <Suspense fallback={<PredictionsSkeleton />}>
          <PredictionsSection
            matchId={match.id}
            homeTeam={match.homeTeam}
            awayTeam={match.awayTeam}
            isFinished={isFinished}
          />
        </Suspense>
      </div>
    </>
  );
}
```

4. Keep force-dynamic and revalidate settings.
  </action>
  <verify>
    - Page renders without errors: `npm run build` completes
    - Suspense boundary exists: `grep -l "Suspense" src/app/matches/\[id\]/page.tsx`
    - Dev server shows streaming: `npm run dev` and check Network tab for chunked response
  </verify>
  <done>
    - Match page uses Suspense for predictions
    - Header and odds render immediately
    - Predictions stream in with skeleton fallback
    - Build passes without errors
  </done>
</task>

</tasks>

<verification>
1. Build completes: `npm run build`
2. Match page loads: Visit any match page in dev mode
3. Check streaming: Network tab shows chunked transfer-encoding
4. Skeleton visible: Initial render shows prediction skeleton before data loads
5. No hydration errors in console
</verification>

<success_criteria>
- Match page header renders within 500ms (TTFB)
- Predictions stream in separately (visible skeleton first)
- No layout shift when predictions replace skeleton
- Build passes without errors
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/03-infrastructure-performance/03-01-SUMMARY.md`
</output>
