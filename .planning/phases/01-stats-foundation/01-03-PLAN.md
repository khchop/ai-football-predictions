---
wave: 3
depends_on:
  - 01-01-PLAN
  - 01-02-PLAN
files_modified:
  - src/lib/queue/workers/stats-worker.ts
  - src/lib/queue/jobs/calculate-stats.ts
  - src/app/api/cron/update-stats/route.ts
autonomous: true
---

# Plan: BullMQ Stats Worker Integration

## Goal
Implement BullMQ worker for automated stats calculation and view refreshes triggered by match completions.

## Background
Stats are updated within 1 hour of match completion. Worker listens for job queue events, calculates points for all predictions, then refreshes materialized views.

## Tasks

### Task 3.1: Define job types and interfaces
```typescript
// src/lib/queue/jobs/calculate-stats.ts

export interface CalculateStatsJob {
  matchId: string;
  priority?: 'high' | 'normal';
}

export const STATS_QUEUE_NAME = 'stats-calculation';

export const STATS_JOB_IDS = {
  calculatePoints: 'calculate-points',
  refreshViews: 'refresh-views',
};
```

### Task 3.2: Create points calculation job handler
```typescript
// src/lib/queue/jobs/calculate-stats.ts

import { calculateAndSavePoints } from '@/lib/services/points-calculator';
import { getDb } from '@/lib/db';
import { matches } from '@/lib/db/schema';
import { eq } from 'drizzle-orm';

export async function enqueuePointsCalculation(
  matchId: string,
  options?: { priority?: 'high' | 'normal'; delay?: number }
): Promise<void> {
  const queue = getStatsQueue();
  await queue.add(STATS_JOB_IDS.calculatePoints, { matchId }, {
    priority: options?.priority === 'high' ? 1 : 2,
    delay: options?.delay ?? 0,
  });
}

export async function handleCalculatePoints(job: BullMQJob<CalculateStatsJob>): Promise<void> {
  const { matchId } = job.data;
  
  const db = getDb();
  
  // Verify match is completed
  const match = await db.query.matches.findFirst({
    where: (m, { eq }) => eq(m.id, matchId),
  });
  
  if (!match || match.status !== 'completed') {
    throw new Error(`Match ${matchId} is not completed`);
  }
  
  // Calculate and save points with row locking
  await db.transaction(async (tx) => {
    await calculateAndSavePoints(matchId, tx);
  });
  
  // Enqueue view refresh after points are saved
  await enqueueViewRefresh();
}
```

### Task 3.3: Create view refresh job handler
```typescript
// src/lib/queue/jobs/calculate-stats.ts

export async function enqueueViewRefresh(
  scope: 'all' = 'all',
  delay: number = 60000  // Default 1 minute delay
): Promise<void> {
  const queue = getStatsQueue();
  await queue.add(STATS_JOB_IDS.refreshViews, { scope }, {
    delay,  // Wait before refreshing to batch multiple match completions
  });
}

export async function handleRefreshViews(job: BullMQJob<{ scope: 'all' }>): Promise<void> {
  const { scope } = job.data;
  
  const db = getDb();
  
  await db.transaction(async (tx) => {
    // CRITICAL: Calculate points BEFORE refreshing views
    // This ensures view data is consistent
    
    await refreshStatsViews(tx, scope);
  });
  
  logger.info({ scope }, 'Stats views refreshed');
}
```

### Task 3.4: Create BullMQ worker
```typescript
// src/lib/queue/workers/stats-worker.ts

import { Worker, Job } from 'bullmq';
import { handleCalculatePoints } from '@/lib/queue/jobs/calculate-stats';
import { STATS_QUEUE_NAME, CalculateStatsJob } from '@/lib/queue/jobs/calculate-stats';
import { connection } from '@/lib/queue/redis';
import { logger } from '@/lib/logger';

const worker = new Worker<CalculateStatsJob>(
  STATS_QUEUE_NAME,
  async (job) => {
    logger.info({ jobId: job.id, data: job.data }, 'Processing stats job');
    
    switch (job.name) {
      case STATS_JOB_IDS.calculatePoints:
        return handleCalculatePoints(job);
      case STATS_JOB_IDS.refreshViews:
        return handleRefreshViews(job);
      default:
        logger.warn({ jobName: job.name }, 'Unknown job type');
    }
  },
  {
    connection,
    concurrency: 5,  // Process up to 5 jobs concurrently
    removeOnComplete: { count: 100 },  // Keep last 100 completed jobs
    removeOnFail: { count: 50 },  // Keep last 50 failed jobs
  }
);

worker.on('completed', (job) => {
  logger.info({ jobId: job.id }, 'Stats job completed');
});

worker.on('failed', (job, err) => {
  logger.error({ jobId: job?.id, error: err.message }, 'Stats job failed');
});

export { worker };
```

### Task 3.5: Create cron endpoint for scheduled refresh
```typescript
// src/app/api/cron/update-stats/route.ts

import { NextResponse } from 'next/server';
import { enqueueViewRefresh } from '@/lib/queue/jobs/calculate-stats';
import { CRON_SECRET } from '@/lib/validation/env';

export async function POST(request: Request) {
  const authHeader = request.headers.get('authorization');
  
  if (authHeader !== `Bearer ${CRON_SECRET}`) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
  
  // Trigger view refresh
  await enqueueViewRefresh('all', 0);  // No delay for cron-triggered refresh
  
  return NextResponse.json({ 
    status: 'queued',
    timestamp: new Date().toISOString(),
  });
}
```

### Task 3.6: Integrate with match completion
```typescript
// In existing match completion logic (e.g., src/lib/queue/workers/live-score-worker.ts)

import { enqueuePointsCalculation } from '@/lib/queue/jobs/calculate-stats';

async function handleMatchCompleted(matchId: string): Promise<void> {
  // Existing logic to update match status...
  
  // NEW: Enqueue points calculation
  await enqueuePointsCalculation(matchId, {
    priority: 'high',  // High priority for recent matches
  });
}
```

## Verification
- [ ] Worker starts without errors: `npm run dev` (queues initialize)
- [ ] Jobs process within 1 minute of match completion
- [ ] View refresh completes without blocking reads
- [ ] Failed jobs retry correctly (BullMQ retry mechanism)
- [ ] Cron endpoint returns 200 with auth

## must_haves
- BullMQ worker processes stats jobs within 1 hour SLA
- Points calculated before view refresh (transaction order)
- Concurrent refresh doesn't block production queries
- Failed jobs retry with exponential backoff

## Dependencies
- Wave 1: Materialized views exist
- Wave 2: Points calculation service implemented

## Notes
- Set reasonable retry attempts (e.g., 3) with backoff
- Use job idempotency keys to prevent duplicate processing
- Monitor queue depth for performance tuning
