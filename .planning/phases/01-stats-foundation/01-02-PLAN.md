---
wave: 2
depends_on:
  - 01-01-PLAN
files_modified:
  - src/lib/services/points-calculator.ts
  - src/lib/db/queries/stats.ts
autonomous: true
---

# Plan: Stats Calculation Services

## Goal
Implement points calculation logic with rarity scoring and query helpers for accessing aggregated stats.

## Background
Points are calculated when match results are confirmed. Rarity scoring awards 2-6 points based on how frequently other models made the same prediction. Stats views must be refreshed AFTER points are calculated.

## Tasks

### Task 2.1: Create rarity scoring constants
```typescript
// src/lib/services/points-calculator.ts

export const RARITY_POINTS = {
  COMMON: 2,     // >75% of models predicted this outcome
  UNCOMMON: 3,   // 50-75% of models
  RARE: 4,       // 25-50% of models
  VERY_RARE: 5,  // 10-25% of models
  UNIQUE: 6,     // <10% of models (or only model)
} as const;

export type RarityScore = typeof RARITY_POINTS[keyof typeof RARITY_POINTS];
```

### Task 2.2: Implement calculatePoints function
```typescript
// src/lib/services/points-calculator.ts

export async function calculatePointsForPrediction(
  prediction: Prediction,
  allModelPredictions: Prediction[]
): Promise<number> {
  // 1. Count frequency of each outcome (home_win, draw, away_win)
  // 2. Calculate percentage for this model's prediction
  // 3. Return points based on rarity thresholds
  // 4. Apply bonus multiplier for correct predictions
}

export async function calculateAndSavePoints(
  matchId: string,
  tx: Transaction
): Promise<void> {
  // Transactional: update all predictions for match with calculated points
  // Use row locking: SELECT ... FOR UPDATE on predictions
}
```

### Task 2.3: Implement row locking for race conditions
```typescript
// src/lib/services/points-calculator.ts

async function lockPredictionsForMatch(
  tx: Transaction,
  matchId: string
): Promise<Prediction[]> {
  return tx.select()
    .from(predictions)
    .where(eq(predictions.matchId, matchId))
    .forUpdate();  // Row-level lock prevents concurrent updates
}
```

### Task 2.4: Create stats query helpers
```typescript
// src/lib/db/queries/stats.ts

export async function getModelOverallStats(modelId: string): Promise<ModelStatsOverall> {
  return db.query.mv_model_stats_overall.findFirst({
    where: (view, { eq }) => eq(view.modelId, modelId),
  });
}

export async function getModelCompetitionStats(
  modelId: string,
  competitionId: string,
  season: string
): Promise<ModelStatsCompetition> {
  return db.query.mv_model_stats_competition.findFirst({
    where: (view, { and, eq }) => and(
      eq(view.modelId, modelId),
      eq(view.competitionId, competitionId),
      eq(view.season, season)
    ),
  });
}

export async function getModelClubStats(
  modelId: string,
  clubId: string,
  season: string,
  isHome?: boolean
): Promise<ModelStatsClub[]> {
  let query = db.query.mv_model_stats_club.findMany({
    where: (view, { and, eq }) => and(
      eq(view.modelId, modelId),
      eq(view.clubId, clubId),
      eq(view.season, season)
    ),
  });
  if (isHome !== undefined) {
    // Filter by is_home
  }
  return query;
}

export async function getLeaderboard(
  limit: number = 10,
  metric: 'win_rate' | 'avg_points' = 'avg_points'
): Promise<ModelLeaderboardEntry[]> {
  // Order by metric desc, return top N models
}
```

### Task 2.5: Create view refresh helpers
```typescript
// src/lib/db/queries/stats.ts

export async function refreshStatsViews(
  tx: Transaction,
  scope: 'overall' | 'competition' | 'club' | 'all'
): Promise<void> {
  switch (scope) {
    case 'overall':
      await tx.execute(sql`REFRESH MATERIALIZED VIEW CONCURRENTLY mv_model_stats_overall`);
      break;
    case 'competition':
      await tx.execute(sql`REFRESH MATERIALIZED VIEW CONCURRENTLY mv_model_stats_competition`);
      break;
    // ... etc
  }
}
```

### Task 2.6: Create recent form query helper
```typescript
// src/lib/db/queries/stats.ts

export interface RecentFormEntry {
  matchId: string;
  matchDate: Date;
  homeTeam: string;
  awayTeam: string;
  homeGoals: number;
  awayGoals: number;
  predictedHomeGoals: number;
  predictedAwayGoals: number;
  points: number;
  tendencyCorrect: boolean;
  goalDiffCorrect: boolean;
  exactScore: boolean;
}

export async function getModelRecentForm(
  modelId: string,
  limit: number = 10,
  season?: string
): Promise<RecentFormEntry[]> {
  // Query predictions joined with matches, filtered by completed matches
  // ORDER BY match.date DESC, LIMIT to specified number
  // Returns up to 10 most recent matches for the model
}
```

## Verification
- [ ] Points calculation returns correct values for all rarity tiers
- [ ] Row locking prevents concurrent modification errors
- [ ] Query helpers return data matching raw SQL queries
- [ ] View refresh helper executes without errors
- [ ] Recent form returns up to 10 matches, ordered by date DESC

## must_haves
- Points calculation with rarity scoring (2-6 points)
- Row-level locking for race condition prevention
- Stats queries return in <100ms
- View refresh works within transaction
- Recent form query returns last N completed matches

## Dependencies
- Wave 1: Materialized views and indexes must exist
