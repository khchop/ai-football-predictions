---
phase: 04-content-pipeline
plan: "03"
type: execute
wave: 2
depends_on: ["04-02"]
files_modified:
  - src/lib/db/schema.ts
  - src/lib/content/deduplication.ts
  - src/lib/content/generator.ts
autonomous: true
must_haves:
  truths:
    - "Roundup content is stored in database with all fields"
    - "Content deduplication prevents duplicate roundups"
    - "Similarity detection compares new roundups against recent ones"
  artifacts:
    - path: "src/lib/db/schema.ts"
      provides: "matchRoundups table with full roundup structure"
    - path: "src/lib/content/deduplication.ts"
      provides: "Jaccard similarity or MinHash implementation"
    - path: "src/lib/content/generator.ts"
      provides: "Content deduplication check before storage"
  key_links:
    - from: "generator.ts"
      to: "deduplication.ts"
      via: "checkForDuplicates before storing roundup"
      pattern: "checkForDuplicates"
---

<objective>
Add content storage schema and similarity detection to ensure unique roundups.

**Purpose:** Store roundups with all metadata and prevent duplicate/similar content from being generated.

**Output:** Database schema for roundups and deduplication service to ensure content uniqueness.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/04-content-pipeline/04-RESEARCH.md (sections 4.1-4.5)
@src/lib/db/schema.ts
@src/lib/db/queries.ts
@src/lib/content/generator.ts
</context>

<tasks>

<task type="auto">
  <name>Add matchRoundups table to database schema</name>
  <files>src/lib/db/schema.ts</files>
  <action>
    Add new table for storing full post-match roundups:

    Create `matchRoundups` table with fields:
    - `id`: uuid, primary key
    - `matchId`: uuid, foreign key to matches.id, unique (one roundup per match)
    - `title`: text, SEO title
    - `scoreboard`: jsonb, { homeTeam, awayTeam, homeScore, awayScore, competition, venue, kickoff }
    - `events`: jsonb, Array of { minute, type, description }
    - `stats`: jsonb, { possession, shots, shotsOnTarget, corners, xG, fouls, offsides, ... }
    - `modelPredictions`: text, HTML table string
    - `topPerformers`: jsonb, Array of { modelName, prediction, points }
    - `narrative`: text, Full HTML content (1000+ words)
    - `keywords`: text, comma-separated keywords
    - `similarityHash`: text, hash for deduplication
    - `generationCost`: decimal
    - `promptTokens`: integer
    - `completionTokens`: integer
    - `generatedBy`: text, model name
    - `status`: enum ('pending', 'published', 'failed')
    - `publishedAt`: timestamp
    - `createdAt` / `updatedAt`: timestamps

    Reference existing matchPreviews table pattern for consistency.
  </action>
  <verify>
    grep -n "matchRoundups" src/lib/db/schema.ts
  </verify>
  <done>
    Database schema includes matchRoundups table with all required fields
  </done>
</task>

<task type="auto">
  <name>Implement content deduplication service</name>
  <files>src/lib/content/deduplication.ts</files>
  <action>
    Create deduplication service based on RESEARCH.md section 4:

    **Option A (Simple):** Jaccard similarity implementation
    - Tokenize text (lowercase, remove punctuation, split on whitespace)
    - Compute Jaccard similarity: |intersection| / |union|
    - Threshold: > 0.7 similarity = too similar, regenerate with different angle
    - Store hash of content for quick exact-match check

    **Option B (Advanced):** MinHash with LSH (from RESEARCH.md 4.1)
    - Implement MinHash signature generation with configurable number of hash functions
    - Implement LSH for bucketing similar documents
    - Use for larger content corpus, better performance

    Choose Option A (Jaccard) for simplicity unless codebase already has MinHash.

    Create functions:
    - `tokenize(text: string): string[]`
    - `computeJaccardSimilarity(tokens1: string[], tokens2: string[]): number`
    - `computeContentHash(content: string): string`
    - `findSimilarRoundups(content: string, excludeMatchId?: string): Promise<Array<{ matchId: string, similarity: number }>>`
    - `isTooSimilar(content: string, threshold?: number): Promise<boolean>`

    Reference existing patterns in src/lib/content/ for file structure.
  </action>
  <verify>
    grep -n "Jaccard\|deduplication\|similarity" src/lib/content/deduplication.ts
  </verify>
  <done>
    Deduplication service can detect similar content using Jaccard similarity
  </done>
</task>

<task type="auto">
  <name>Integrate deduplication into roundup generation</name>
  <files>src/lib/content/generator.ts</files>
  <action>
    Update generatePostMatchRoundup to include deduplication:

    1. After LLM generation, before storage:
       - Compute content hash of narrative section
       - Check for exact duplicate via hash lookup
       - If exact match found, skip generation (return existing)
       - If not exact, compute Jaccard similarity against recent roundups (last 10 matches)
       - If similarity > 0.7, trigger regeneration with different angle

    2. On regeneration:
       - If content was too similar, call LLM again with modified prompt
       - Add instruction: "Take a different narrative angle than typical match reports"
       - Rotate between angle options: tactical analysis, player focus, historical context

    3. Store similarity data:
       - Store content hash in matchRoundups.similarityHash
       - Log deduplication decisions for monitoring

    4. Add to error handling:
       - If max retries reached due to similarity, store with warning flag
       - Log for investigation

    This ensures uniqueness as required by CONTEXT.md.
  </action>
  <verify>
    grep -n "deduplication\|similarity\|tooSimilar" src/lib/content/generator.ts
  </verify>
  <done>
    Roundup generation checks for duplicates before storage
  </done>
</task>

<task type="auto">
  <name>Generate and run database migration</name>
  <files>drizzle/</files>
  <action>
    Create and run database migration for matchRoundups table:

    1. Run `npm run db:generate` to create migration file
    2. Run `npm run db:migrate` to apply migration to database
    3. Verify migration: check drizzle/_meta table for new table
    4. Verify schema: query information_schema to confirm columns

    This is a required step before roundup storage will work.
  </action>
  <verify>
    ls -la drizzle/*.sql | grep -c "match_roundups" && npm run db:migrate
  </verify>
  <done>
    Database has matchRoundups table ready for content storage
  </done>
</task>

</tasks>

<verification>
1. `npm run build` completes without type errors
2. Database migration runs successfully
3. matchRoundups table exists and has all required columns
4. Deduplication service can tokenize text and compute similarity
5. Roundups are checked for duplicates before storage
</verification>

<success_criteria>
- [ ] matchRoundups table stores complete roundup content
- [ ] Content deduplication prevents exact duplicates
- [ ] Similarity detection flags content > 70% similar
- [ ] Regeneration triggers on excessive similarity
- [ ] Storage includes similarity hash for future comparisons
</success_criteria>

<output>
After completion, create `.planning/phases/04-content-pipeline/04-03-SUMMARY.md`
</output>
