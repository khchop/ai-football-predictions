---
phase: 04-content-pipeline
plan: "04"
type: execute
wave: 3
depends_on: ["04-03"]
files_modified:
  - src/app/api/matches/[id]/roundup/route.ts
  - src/app/matches/[slug]/page.tsx
  - src/components/match/roundup-viewer.tsx
  - src/lib/cache/redis.ts
autonomous: true
must_haves:
  truths:
    - "Match page displays full roundup with scoreboard, events, predictions, and narrative"
    - "Roundup is served from cache for performance"
    - "Page includes model predictions table with accuracy columns"
  artifacts:
    - path: "src/app/api/matches/[id]/roundup/route.ts"
      provides: "API endpoint for fetching roundup data"
    - path: "src/app/matches/[slug]/page.tsx"
      provides: "Match page with roundup display"
    - path: "src/components/match/roundup-viewer.tsx"
      provides: "Roundup display component with HTML rendering"
    - path: "src/lib/cache/redis.ts"
      provides: "CACHE_TTL.ROUNDUP constant"
  key_links:
    - from: "page.tsx"
      to: "api/matches/[id]/roundup/route.ts"
      via: "fetch roundup data server-side"
      pattern: "api/matches.*roundup"
    - from: "roundup-viewer.tsx"
      to: "matchRoundups table"
      via: "dangerouslySetInnerHTML for narrative rendering"
      pattern: "dangerouslySetInnerHTML"
---

<objective>
Integrate roundup content into match pages with HTML rendering and caching.

**Purpose:** Display generated roundups on match pages with proper structure, rich formatting, and cached delivery.

**Output:** Match pages show complete roundups with scoreboard, events, model predictions, and narrative analysis.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/04-content-pipeline/04-CONTEXT.md
@src/app/matches/[slug]/page.tsx
@src/components/match/match-content.tsx
@src/lib/cache/redis.ts
</context>

<tasks>

<task type="auto">
  <name>Add roundup caching constants</name>
  <files>src/lib/cache/redis.ts</files>
  <action>
    Extend CACHE_TTL constants for roundup content:

    Add to CACHE_TTL object:
    - `ROUNDUP: 86400` (24 hours - roundups are static once generated)
    - Or `ROUNDUP_DETAIL: 300` (5 minutes for match page, then cache longer)

    Add to cacheKeys object:
    - `roundup(matchId: string): string` - returns `roundup:{matchId}`
    - `roundupBySlug(slug: string): string` - returns `roundup:slug:{slug}`

    Reference existing cacheKeys pattern for consistency.
  </action>
  <verify>
    grep -n "ROUNDUP\|roundup" src/lib/cache/redis.ts | head -10
  </verify>
  <done>
    Redis caching configured for roundup content
  </done>
</task>

<task type="auto">
  <name>Create roundup API endpoint</name>
  <files>src/app/api/matches/[id]/roundup/route.ts</files>
  <action>
    Create API endpoint to serve roundup data:

    Create GET /api/matches/{matchId}/roundup endpoint:

    1. Accept matchId as URL parameter
    2. Check cache first using cacheKeys.roundup(matchId)
    3. If cache miss, query matchRoundups table
    4. If no roundup exists, return 404 with { exists: false }
    5. If exists, return:
       - All roundup fields (title, scoreboard, events, stats, etc.)
       - Include model predictions HTML table
       - Include narrative HTML
       - Include metadata (generatedAt, keywords)
    6. Cache successful response for 24 hours
    7. Include cache headers: Cache-Control: public, max-age=86400

    Reference existing API route patterns in src/app/api/.
  </action>
  <verify>
    ls -la src/app/api/matches/[id]/roundup/route.ts
  </verify>
  <done>
    API endpoint serves roundup data with caching headers
  </done>
</task>

<task type="auto">
  <name>Create RoundupViewer component</name>
  <files>src/components/match/roundup-viewer.tsx</files>
  <action>
    Create component to display roundup content:

    Build `RoundupViewer` component that accepts roundup data props and renders:

    **Props interface:**
    ```typescript
    interface RoundupViewerProps {
      title: string;
      scoreboard: { homeTeam: string; awayTeam: string; homeScore: number; awayScore: number; competition: string };
      events: Array<{ minute: number; type: string; description: string }>;
      stats: { possession: number; shots: number; shotsOnTarget: number; corners: number; xG: number };
      modelPredictions: string; // HTML table
      topPerformers: Array<{ modelName: string; prediction: string; points: number }>;
      narrative: string; // HTML content
      keywords: string[];
    }
    ```

    **Render sections:**
    1. **Scoreboard header:** Team names, score, competition badge
    2. **Events timeline:** Chronological list with minute badges
    3. **Stats grid:** Cards for possession, shots, corners, xG
    4. **Model predictions:** Render HTML table (dangerouslySetInnerHTML)
    5. **Top performers:** List with model names, predictions, points
    6. **Narrative:** Render HTML content (dangerouslySetInnerHTML)
    7. **Keywords:** Meta tags or footer with SEO keywords

    Use Tailwind CSS matching existing match-content.tsx styling.
  </action>
  <verify>
    grep -n "RoundupViewer\|roundup-viewer" src/components/match/roundup-viewer.tsx
  </verify>
  <done>
    Component displays all roundup sections with proper styling
  </done>
</task>

<task type="auto">
  <name>Integrate roundup into match page</name>
  <files>src/app/matches/[slug]/page.tsx</files>
  <action>
    Update match page to display roundup:

    1. Import RoundupViewer component
    2. Fetch roundup data alongside match data (use server-side fetch with caching)
    3. Conditionally render roundup section if exists:
       - Place after existing match info and before/after existing content sections
       - Use proper section structure with h2/h3 headings
       - Handle loading state with Suspense
       - Handle missing roundup gracefully (don't break page)

    4. Update metadata:
       - If roundup exists, use roundup.title for page title
       - Include roundup.keywords in SEO metadata

    5. Add ISR revalidation:
       - Set `export const revalidate = 300` (5 minutes) for match page
       - On-demand revalidation when roundup is generated

    Reference existing page structure and ISR patterns.
  </action>
  <verify>
    grep -n "RoundupViewer\|roundup" src/app/matches/[slug]/page.tsx
  </verify>
  <done>
    Match page displays full roundup content
  </done>
</task>

<task type="auto">
  <name>Add roundup query helper</name>
  <files>src/lib/db/queries.ts</files>
  <action>
    Add database query for fetching roundups:

    Create `getMatchRoundup(matchId: string)` function that:
    - Queries matchRoundups table by matchId
    - Returns all fields including modelPredictions HTML and narrative HTML
    - Returns null if no roundup exists

    Create `getMatchRoundupBySlug(slug: string)` function that:
    - Joins matchRoundups with matches table
    - Queries by match slug
    - Returns roundup data with matchId

    These will be used by the API endpoint.
  </action>
  <verify>
    grep -n "getMatchRoundup" src/lib/db/queries.ts
  </verify>
  <done>
    Database queries fetch roundup data for match pages
  </done>
</task>

</tasks>

<verification>
1. `npm run build` completes without type errors
2. API endpoint returns roundup data with proper caching
3. RoundupViewer component renders all sections
4. Match page displays roundup with proper styling
5. Cache headers set correctly (24 hours for static content)
</verification>

<success_criteria>
- [ ] Match page displays scoreboard with team names and final score
- [ ] Events timeline shows goals, cards, key incidents with minutes
- [ ] Extended stats grid shows possession, shots, corners, xG
- [ ] Model predictions table shows each model's prediction with accuracy columns
- [ ] Narrative section renders HTML with 1000+ words of analysis
- [ ] Top performers listed with model names and points
- [ ] Page loads with cached roundup data
- [ ] SEO keywords included in page metadata
</success_criteria>

<output>
After completion, create `.planning/phases/04-content-pipeline/04-04-SUMMARY.md`
</output>
