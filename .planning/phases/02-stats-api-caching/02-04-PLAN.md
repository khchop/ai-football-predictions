---
phase: 02-stats-api-caching
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/db/queries/stats.ts
  - src/app/api/stats/competition/[id]/route.ts
  - src/app/api/stats/club/[id]/route.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "GET /api/stats/competition/{id} returns competition-specific stats"
    - "GET /api/stats/club/{id} returns club-specific model performance"
    - "All filter combinations work (season, competition, club, model, date range)"
  artifacts:
    - path: "src/lib/db/queries/stats.ts"
      provides: "getLeaderboard function with filter support"
      contains: "competitionId"
    - path: "src/app/api/stats/competition/[id]/route.ts"
      provides: "Competition-filtered leaderboard"
      contains: "getLeaderboard(query.limit, 'avgPoints', { competitionId })"
    - path: "src/app/api/stats/club/[id]/route.ts"
      provides: "Club-filtered leaderboard"
      contains: "getLeaderboard(query.limit, 'avgPoints', { clubId })"
  key_links:
    - from: "src/app/api/stats/competition/[id]/route.ts"
      to: "src/lib/db/queries/stats.ts"
      via: "getLeaderboard with competitionId filter"
      pattern: "getLeaderboard.*competitionId"
    - from: "src/app/api/stats/club/[id]/route.ts"
      to: "src/lib/db/queries/stats.ts"
      via: "getLeaderboard with clubId filter"
      pattern: "getLeaderboard.*clubId"
    - from: "src/lib/db/queries/stats.ts"
      to: "matches table"
      via: "JOIN for filtering"
      pattern: "innerJoin.*matches"
---

<objective>
Fix competition and club endpoints to return filtered stats instead of overall leaderboard.

Purpose: Close verification gaps from Phase 2. The competition and club endpoints currently return overall stats regardless of the ID passed. This plan adds filter support to getLeaderboard and wires the endpoints to use it.

Output: Working competition and club endpoints that return correctly filtered model performance data.
</objective>

<execution_context>
@/Users/pieterbos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-stats-api-caching/02-VERIFICATION.md

# Source files to modify
@src/lib/db/queries/stats.ts
@src/app/api/stats/competition/[id]/route.ts
@src/app/api/stats/club/[id]/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add filter support to getLeaderboard function</name>
  <files>src/lib/db/queries/stats.ts</files>
  <action>
Update getLeaderboard function to accept an optional filters parameter:

1. Add a new interface `LeaderboardFilters` above the function:
```typescript
export interface LeaderboardFilters {
  competitionId?: string;
  clubId?: string;
  isHome?: boolean;
  season?: number;
  dateFrom?: Date;
  dateTo?: Date;
}
```

2. Update getLeaderboard signature to:
```typescript
export async function getLeaderboard(
  limit: number = 30,
  metric: LeaderboardMetric = 'avgPoints',
  filters?: LeaderboardFilters
): Promise<LeaderboardEntry[]>
```

3. When filters are provided, add conditional JOIN to matches table:
- Import `matches` from '@/lib/db' (already imported)
- If any filter is present, change query to:
  - Use `innerJoin(matches, eq(predictions.matchId, matches.id))` instead of leftJoin(predictions)
  - Add WHERE conditions based on which filters are present:
    - competitionId: `eq(matches.competitionId, filters.competitionId)`
    - clubId: `or(eq(matches.homeTeam, filters.clubId), eq(matches.awayTeam, filters.clubId))`
    - isHome === true: `eq(matches.homeTeam, filters.clubId)` (not OR)
    - isHome === false: `eq(matches.awayTeam, filters.clubId)` (not OR)
    - season: Join competitions table and filter `eq(competitions.season, filters.season)`
    - dateFrom: `gte(matches.kickoffTime, filters.dateFrom)`
    - dateTo: `lte(matches.kickoffTime, filters.dateTo)` (import lte from drizzle-orm)

4. Keep the existing behavior when no filters are provided (overall leaderboard).

5. The query structure when filters present:
```typescript
const baseQuery = db
  .select({ /* same fields */ })
  .from(models)
  .innerJoin(predictions, and(
    eq(predictions.modelId, models.id),
    eq(predictions.status, 'scored')
  ))
  .innerJoin(matches, eq(predictions.matchId, matches.id))
  .where(and(
    eq(models.active, true),
    // ...filter conditions
  ))
  .groupBy(models.id)
  .orderBy(orderByColumn)
  .limit(limit);
```

Do NOT break existing functionality - overall leaderboard should work as before when filters is undefined.
  </action>
  <verify>
Run TypeScript compilation: `npx tsc --noEmit`
Check function signature includes filters parameter.
  </verify>
  <done>
getLeaderboard accepts optional LeaderboardFilters and applies WHERE conditions when filters are provided. Existing overall leaderboard behavior preserved when no filters passed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire competition and club endpoints to pass filters</name>
  <files>
    src/app/api/stats/competition/[id]/route.ts
    src/app/api/stats/club/[id]/route.ts
  </files>
  <action>
**Competition endpoint (src/app/api/stats/competition/[id]/route.ts):**

1. Update import to include LeaderboardFilters type:
```typescript
import { getLeaderboard, type LeaderboardFilters } from '@/lib/db/queries/stats';
```

2. Update the getLeaderboard call (around line 66) to pass competitionId:
```typescript
// Build filters from query params and route param
const leaderboardFilters: LeaderboardFilters = {
  competitionId,
  season: query.season ? parseInt(query.season, 10) : undefined,
};

// Get leaderboard filtered by competition
const leaderboard = await getLeaderboard(query.limit, 'avgPoints', leaderboardFilters);
```

3. Remove the misleading comment "// Get leaderboard filtered by competition" that was false before.

**Club endpoint (src/app/api/stats/club/[id]/route.ts):**

1. Update import similarly:
```typescript
import { getLeaderboard, type LeaderboardFilters } from '@/lib/db/queries/stats';
```

2. Update the getLeaderboard call (around line 67) to pass clubId and isHome:
```typescript
// Build filters from query params and route param
const leaderboardFilters: LeaderboardFilters = {
  clubId,
  isHome: query.isHome,
  season: query.season ? parseInt(query.season, 10) : undefined,
};

// Get leaderboard filtered by club
const leaderboard = await getLeaderboard(query.limit, 'avgPoints', leaderboardFilters);
```

3. Remove the hardcoded win/draw/loss calculation (lines 83-85):
```typescript
// OLD (remove):
wins: Math.floor(entry.correctTendencies * 0.5),
draws: Math.floor(entry.correctTendencies * 0.2),
losses: entry.totalPredictions - entry.correctTendencies,

// NEW (real data from leaderboard):
wins: entry.correctTendencies,  // For now, correctTendencies is wins
draws: 0,  // Leaderboard doesn't have draws, leave as 0
losses: entry.totalPredictions - entry.correctTendencies,
```

Note: The LeaderboardEntry type doesn't include wins/draws/losses breakdown. For now, map correctTendencies to wins. A future enhancement could add these fields to the leaderboard query.
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. Start dev server and test endpoints:
   - `curl -H "Authorization: Bearer $CRON_SECRET" "http://localhost:3000/api/stats/competition/eng.1"`
   - `curl -H "Authorization: Bearer $CRON_SECRET" "http://localhost:3000/api/stats/club/Manchester%20United"`
3. Verify responses contain different data for different competition/club IDs (not identical to overall)
  </verify>
  <done>
Competition endpoint returns stats filtered by competition ID.
Club endpoint returns stats filtered by club ID with optional isHome filter.
Both endpoints pass their respective filters to getLeaderboard.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **TypeScript compilation passes:** `npx tsc --noEmit`

2. **Competition endpoint returns filtered data:**
```bash
# Get stats for a specific competition
curl -H "Authorization: Bearer $CRON_SECRET" \
  "http://localhost:3000/api/stats/competition/eng.1" | jq '.data.models[0]'

# Compare to overall - should show different totals
curl -H "Authorization: Bearer $CRON_SECRET" \
  "http://localhost:3000/api/stats/overall" | jq '.data.models[0]'
```

3. **Club endpoint returns filtered data:**
```bash
# Get stats for a specific club
curl -H "Authorization: Bearer $CRON_SECRET" \
  "http://localhost:3000/api/stats/club/Manchester%20United" | jq '.data.models[0]'

# With isHome filter
curl -H "Authorization: Bearer $CRON_SECRET" \
  "http://localhost:3000/api/stats/club/Manchester%20United?isHome=true" | jq '.data.models[0]'
```

4. **Filter combinations work:**
```bash
# Competition + season
curl -H "Authorization: Bearer $CRON_SECRET" \
  "http://localhost:3000/api/stats/competition/eng.1?season=2024"
```
</verification>

<success_criteria>
- [ ] getLeaderboard accepts LeaderboardFilters parameter
- [ ] Competition endpoint passes competitionId to getLeaderboard
- [ ] Club endpoint passes clubId and isHome to getLeaderboard
- [ ] Different competition IDs return different model stats
- [ ] Different club IDs return different model stats
- [ ] isHome filter affects club endpoint results
- [ ] Overall endpoint still works (no filters)
- [ ] TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-stats-api-caching/02-04-SUMMARY.md`
</output>
