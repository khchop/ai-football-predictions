---
phase: 02-stats-api-caching
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/api/stats/types.ts
  - src/lib/api/stats/cache.ts
  - src/lib/api/stats/response.ts
  - src/lib/utils/stats-auth.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "API responses have consistent structure with meta (generatedAt, cached, pagination)"
    - "Cache keys follow tiered pattern: stats:{level}:{filters}"
    - "All endpoints require Bearer token authentication"
    - "Rate limiting applies to all stats endpoints"
  artifacts:
    - path: "src/lib/api/stats/types.ts"
      provides: "StatsResponse<T>, StatsFilters, Pagination interfaces"
      min_lines: 50
    - path: "src/lib/api/stats/cache.ts"
      provides: "buildCacheKey, getStatsCache, setStatsCache, invalidateStatsCache"
      min_lines: 80
    - path: "src/lib/api/stats/response.ts"
      provides: "createStatsResponse, createPaginatedResponse helpers"
      min_lines: 40
    - path: "src/lib/utils/stats-auth.ts"
      provides: "validateStatsRequest for Bearer token auth"
      min_lines: 30
  key_links:
    - from: "src/lib/api/stats/types.ts"
      to: "src/lib/cache/redis.ts"
      via: "Uses cacheGet/cacheSet functions"
      pattern: "cacheGet|cacheSet"
    - from: "src/lib/api/stats/cache.ts"
      to: "src/lib/cache/redis.ts"
      via: "Redis client from existing infrastructure"
      pattern: "getRedis|cacheGet|cacheSet"
    - from: "src/lib/utils/stats-auth.ts"
      to: "src/lib/auth/cron-auth.ts"
      via: "Follows same auth pattern"
      pattern: "validateCronRequest"
---

<objective>

Create shared utilities for stats API endpoints: type definitions, caching utilities, response builders, and authentication middleware.

**Purpose:** Establish consistent patterns across all stats endpoints so each endpoint can focus on its specific data retrieval logic.

**Output:**
- `src/lib/api/stats/types.ts` — TypeScript interfaces for responses and filters
- `src/lib/api/stats/cache.ts` — Cache utilities with tiered key building
- `src/lib/api/stats/response.ts` — Response factory functions
- `src/lib/utils/stats-auth.ts` — Bearer token authentication middleware

</objective>

<context>

@.planning/ROADMAP.md
@.planning/phases/02-stats-api-caching/02-CONTEXT.md
@.planning/phases/02-stats-api-caching/02-RESEARCH.md

@src/lib/cache/redis.ts
@src/lib/auth/cron-auth.ts
@src/lib/db/queries/stats.ts

</context>

<tasks>

<task type="auto">
  <name>Create stats API type definitions</name>
  <files>src/lib/api/stats/types.ts</files>
  <action>

Create `src/lib/api/stats/types.ts` with the following exports:

```typescript
// StatsResponse wrapper for consistent API output
export interface StatsResponse<T> {
  data: T;
  meta: {
    generatedAt: string;
    cached: boolean;
    cacheKey?: string;
    filters?: StatsFilters;
    pagination?: PaginationMeta;
  };
}

// Pagination meta for cursor-based pagination
export interface PaginationMeta {
  totalCount: number;
  hasMore: boolean;
  nextCursor?: string;
  limit: number;
}

// Filter parameters for stats queries
export interface StatsFilters {
  season?: string;
  competition?: string;
  club?: string;
  model?: string;
  dateFrom?: string;
  dateTo?: string;
  isHome?: boolean;
  limit?: number;
  cursor?: string;
}

// Stats level for cache key building
export type StatsLevel = 'overall' | 'competition' | 'club' | 'leaderboard' | 'model';

// Overall stats response type
export interface OverallStats {
  models: ModelStatsRow[];
  totalModels: number;
  totalPredictions: number;
}

// Individual model stats row
export interface ModelStatsRow {
  rank: number;
  modelId: string;
  displayName: string;
  provider: string;
  totalPredictions: number;
  scoredPredictions: number;
  totalPoints: number;
  avgPoints: number;
  accuracy: number;
  exactScores: number;
  correctTendencies: number;
}

// Competition stats response
export interface CompetitionStats {
  competitionId: string;
  competitionName: string;
  season: string;
  models: ModelStatsRow[];
  totalModels: number;
}

// Club stats response
export interface ClubStats {
  clubId: string;
  clubName: string;
  season: string;
  isHome?: boolean;
  models: ModelClubStatsRow[];
}

// Club-specific model stats
export interface ModelClubStatsRow {
  modelId: string;
  displayName: string;
  provider: string;
  totalPredictions: number;
  totalPoints: number;
  avgPoints: number;
  accuracy: number;
  wins: number;
  draws: number;
  losses: number;
}

// Model-specific stats response
export interface ModelStats {
  modelId: string;
  displayName: string;
  provider: string;
  overall: ModelOverallDetails;
  competitions: ModelCompetitionDetails[];
  clubs: ModelClubDetails[];
}

// Model overall details
export interface ModelOverallDetails {
  totalPredictions: number;
  scoredPredictions: number;
  totalPoints: number;
  avgPoints: number;
  accuracy: number;
  exactScores: number;
  correctTendencies: number;
  currentStreak: number;
  bestStreak: number;
}

// Model competition details
export interface ModelCompetitionDetails {
  competitionId: string;
  competitionName: string;
  season: string;
  totalPredictions: number;
  totalPoints: number;
  avgPoints: number;
  accuracy: number;
}

// Model club details
export interface ModelClubDetails {
  clubId: string;
  clubName: string;
  season: string;
  isHome: boolean;
  totalPredictions: number;
  totalPoints: number;
  avgPoints: number;
  accuracy: number;
}
```

</action>
  <verify>File exists with correct exports, grep finds "export interface StatsResponse" and "export type StatsLevel"</verify>
  <done>TypeScript interfaces compile without errors, all types exported</done>
</task>

<task type="auto">
  <name>Create cache utilities for stats</name>
  <files>src/lib/api/stats/cache.ts</files>
  <action>

Create `src/lib/api/stats/cache.ts` with the following functions:

1. **buildCacheKey(level, filters)** — Builds consistent cache keys:
   ```typescript
   export function buildCacheKey(level: StatsLevel, filters: StatsFilters): string {
     const parts: string[] = ['stats', level];
     if (filters.season) parts.push(`season:${filters.season}`);
     if (filters.competition) parts.push(`comp:${filters.competition}`);
     if (filters.club) parts.push(`club:${filters.club}`);
     if (filters.model) parts.push(`model:${filters.model}`);
     if (filters.isHome !== undefined) parts.push(filters.isHome ? 'home' : 'away');
     if (filters.limit) parts.push(`limit:${filters.limit}`);
     if (filters.cursor) parts.push(`cursor:${filters.cursor}`);
     return parts.join(':');
   }
   ```

2. **getStatsCache&lt;T&gt;(key)** — Wrapper around cacheGet with logging

3. **setStatsCache&lt;T&gt;(key, data, ttlSeconds)** — Wrapper around cacheSet with TTL

4. **getStatsTTL(filters)** — Returns appropriate TTL:
   ```typescript
   export function getStatsTTL(filters: StatsFilters): number {
     // Active season: 60s, Historical: 5min
     const isCurrentSeason = filters.season === undefined || filters.season === getCurrentSeason();
     return isCurrentSeason ? 60 : 300;
   }
   ```

5. **invalidateStatsCache(match)** — Invalidates caches when match completes:
   ```typescript
   export async function invalidateStatsCache(match: {
     id: string;
     competitionId: string;
     homeTeam: string;
     awayTeam: string;
   }): Promise<void> {
     // Delete patterns for overall, competition, and both clubs
     await cacheDeletePattern('stats:overall:*');
     await cacheDeletePattern(`stats:competition:${match.competitionId}:*`);
     await cacheDeletePattern(`stats:club:${match.homeTeam}:*`);
     await cacheDeletePattern(`stats:club:${match.awayTeam}:*`);
   }
   ```

Import from `@/lib/cache/redis`: `cacheGet`, `cacheSet`, `cacheDelete`, `cacheDeletePattern`.

</action>
  <verify>File exists, grep finds "buildCacheKey" and "getStatsTTL", compilation succeeds</verify>
  <done>Cache utilities handle all key patterns from context, TTL logic correct</done>
</task>

<task type="auto">
  <name>Create response builder utilities</name>
  <files>src/lib/api/stats/response.ts</files>
  <action>

Create `src/lib/api/stats/response.ts` with helper functions:

```typescript
import type { StatsResponse, PaginationMeta } from './types';
import { cacheDeletePattern, cacheGet, cacheSet, getStatsTTL } from './cache';

// Create stats response (cached or fresh)
export async function createStatsResponse<T>(
  data: T,
  cacheKey: string,
  filters: StatsFilters = {}
): Promise<StatsResponse<T>> {
  const cached = await cacheGet<T>(cacheKey);
  if (cached) {
    return {
      data: cached,
      meta: {
        generatedAt: new Date().toISOString(),
        cached: true,
        cacheKey,
        filters,
      },
    };
  }

  const ttl = getStatsTTL(filters);
  await cacheSet(cacheKey, data, ttl);

  return {
    data,
    meta: {
      generatedAt: new Date().toISOString(),
      cached: false,
      cacheKey,
      filters,
      ttl,
    },
  };
}

// Create paginated stats response
export async function createPaginatedResponse<T>(
  data: T[],
  cacheKey: string,
  filters: StatsFilters & { limit: number },
  totalCount: number,
  hasMore: boolean
): Promise<StatsResponse<T[]>> {
  const baseResponse = await createStatsResponse(data, cacheKey, filters);
  
  const pagination: PaginationMeta = {
    totalCount,
    hasMore,
    limit: filters.limit,
    nextCursor: hasMore ? encodeCursor(data[data.length - 1]) : undefined,
  };

  return {
    ...baseResponse,
    meta: {
      ...baseResponse.meta,
      pagination,
    },
  };
}

// Encode cursor from last item
function encodeCursor(item: any): string {
  // Simple base64 of the id or relevant fields
  return Buffer.from(JSON.stringify({ id: item.modelId })).toString('base64');
}

// Decode cursor
export function decodeCursor(cursor: string): { modelId: string } | null {
  try {
    return JSON.parse(Buffer.from(cursor, 'base64').toString());
  } catch {
    return null;
  }
}
```

</action>
  <verify>File exists, grep finds "createStatsResponse" and "createPaginatedResponse"</verify>
  <done>Response builders handle both cached and fresh data with correct metadata</done>
</task>

<task type="auto">
  <name>Create stats authentication middleware</name>
  <files>src/lib/utils/stats-auth.ts</files>
  <action>

Create `src/lib/utils/stats-auth.ts` following the pattern from `@/lib/auth/cron-auth.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { loggers } from '@/lib/logger/modules';

export interface AuthenticatedRequest {
  userId: string;
  request: NextRequest;
}

/**
 * Validates Bearer token for stats API endpoints.
 * Returns null if valid, or an error response if invalid.
 */
export function validateStatsRequest(request: NextRequest): NextResponse | null {
  const authHeader = request.headers.get('Authorization');
  
  if (!authHeader) {
    loggers.auth.warn({}, 'Missing Authorization header for stats API');
    return NextResponse.json(
      { success: false, error: 'Authorization required' },
      { status: 401 }
    );
  }

  // Check Bearer token format
  const [scheme, token] = authHeader.split(' ');
  if (scheme !== 'Bearer' || !token) {
    loggers.auth.warn({}, 'Invalid Authorization header format');
    return NextResponse.json(
      { success: false, error: 'Invalid authorization format. Use: Bearer &lt;token&gt;' },
      { status: 401 }
    );
  }

  // Validate against CRON_SECRET (same as cron endpoints)
  if (!process.env.CRON_SECRET) {
    if (process.env.NODE_ENV === 'production') {
      loggers.auth.error({}, 'CRON_SECRET not configured in production');
      return NextResponse.json(
        { success: false, error: 'Server misconfigured' },
        { status: 500 }
      );
    }
    loggers.auth.warn({}, 'CRON_SECRET not configured - allowing in development');
    return null;
  }

  if (token !== process.env.CRON_SECRET) {
    loggers.auth.warn({}, 'Invalid token for stats API');
    return NextResponse.json(
      { success: false, error: 'Unauthorized' },
      { status: 401 }
    );
  }

  return null; // Valid request
}
```

</action>
  <verify>File exists, grep finds "validateStatsRequest", follows cron-auth pattern</verify>
  <done>Auth middleware validates Bearer tokens, returns 401 for invalid/missing tokens</done>
</task>

</tasks>

<verification>

1. TypeScript compilation: `npx tsc --noEmit` passes
2. Imports work: All files import from correct locations
3. Auth middleware follows existing pattern from cron-auth.ts
4. Cache utilities use existing Redis infrastructure

</verification>

<success_criteria>

- Shared utilities enable consistent API endpoint implementation
- Response structure follows CONTEXT.md specification
- Cache key patterns match RESEARCH.md patterns
- Authentication integrates with existing CRON_SECRET

</success_criteria>

<output>

After completion, create `.planning/phases/02-stats-api-caching/02-01-SUMMARY.md`

</output>
---
phase: 02-stats-api-caching
plan: "02"
type: execute
wave: 2
depends_on:
  - "02-01"
files_modified:
  - src/app/api/stats/overall/route.ts
  - src/app/api/stats/competition/[id]/route.ts
  - src/app/api/stats/club/[id]/route.ts
  - src/app/api/stats/leaderboard/route.ts
  - src/app/api/stats/models/[id]/route.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "GET /api/stats/overall returns global leaderboard with pagination"
    - "GET /api/stats/competition/{id} returns competition-specific stats"
    - "GET /api/stats/club/{id} returns club-specific model performance"
    - "GET /api/stats/leaderboard returns sortable rankings"
    - "GET /api/stats/models/{id} returns model-specific stats"
    - "All endpoints include Cache-Control header"
    - "All endpoints apply rate limiting"
  artifacts:
    - path: "src/app/api/stats/overall/route.ts"
      provides: "GET /api/stats/overall endpoint"
      min_lines: 60
    - path: "src/app/api/stats/competition/[id]/route.ts"
      provides: "GET /api/stats/competition/:id endpoint"
      min_lines: 70
    - path: "src/app/api/stats/club/[id]/route.ts"
      provides: "GET /api/stats/club/:id endpoint"
      min_lines: 80
    - path: "src/app/api/stats/leaderboard/route.ts"
      provides: "GET /api/stats/leaderboard endpoint"
      min_lines: 80
    - path: "src/app/api/stats/models/[id]/route.ts"
      provides: "GET /api/stats/models/:id endpoint"
      min_lines: 80
  key_links:
    - from: "src/app/api/stats/overall/route.ts"
      to: "src/lib/api/stats/types.ts"
      via: "Imports StatsResponse, OverallStats types"
      pattern: "import.*types"
    - from: "src/app/api/stats/overall/route.ts"
      to: "src/lib/api/stats/cache.ts"
      via: "Uses buildCacheKey, getStatsCache, setStatsCache"
      pattern: "buildCacheKey|getStatsCache|setStatsCache"
    - from: "src/app/api/stats/overall/route.ts"
      to: "src/lib/db/queries/stats.ts"
      via: "Calls getLeaderboard query function"
      pattern: "getLeaderboard|getModelOverallStats"
---

<objective>

Implement all five stats API endpoints with consistent response structure, caching, authentication, and rate limiting.

**Purpose:** Complete the REST API layer for multi-granularity stats queries.

**Output:**
- `src/app/api/stats/overall/route.ts` — Global leaderboard endpoint
- `src/app/api/stats/competition/[id]/route.ts` — Competition-specific endpoint
- `src/app/api/stats/club/[id]/route.ts` — Club-specific endpoint
- `src/app/api/stats/leaderboard/route.ts` — Sortable leaderboard endpoint
- `src/app/api/stats/models/[id]/route.ts` — Model-specific endpoint

</objective>

<context>

@.planning/phases/02-stats-api-caching/02-CONTEXT.md
@.planning/phases/02-stats-api-caching/02-RESEARCH.md

@src/lib/api/stats/types.ts
@src/lib/api/stats/cache.ts
@src/lib/api/stats/response.ts
@src/lib/utils/stats-auth.ts

@src/lib/db/queries/stats.ts
@src/lib/utils/rate-limiter.ts

</context>

<tasks>

<task type="auto">
  <name>Create overall stats endpoint</name>
  <files>src/app/api/stats/overall/route.ts</files>
  <action>

Create `src/app/api/stats/overall/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { validateStatsRequest } from '@/lib/utils/stats-auth';
import { checkRateLimit, getRateLimitKey, RATE_LIMIT_PRESETS } from '@/lib/utils/rate-limiter';
import { buildCacheKey, getStatsCache, setStatsCache } from '@/lib/api/stats/cache';
import { createStatsResponse } from '@/lib/api/stats/response';
import { getLeaderboard, getModelOverallStats } from '@/lib/db/queries/stats';
import type { StatsResponse, OverallStats } from '@/lib/api/stats/types';
import { loggers } from '@/lib/logger/modules';

const querySchema = z.object({
  season: z.string().optional(),
  model: z.string().optional(),
  limit: z.coerce.number().min(1).max(100).default(50),
  cursor: z.string().optional(),
});

export async function GET(request: NextRequest) {
  // Authentication
  const authError = validateStatsRequest(request);
  if (authError) return authError;

  // Rate limiting (100 req/min)
  const rateLimitKey = getRateLimitKey(request);
  const rateLimitResult = await checkRateLimit(`stats:${rateLimitKey}`, RATE_LIMIT_PRESETS.api);
  
  if (!rateLimitResult.allowed) {
    return NextResponse.json(
      { success: false, error: 'Rate limit exceeded' },
      { status: 429, headers: { 'Retry-After': '60' } }
    );
  }

  try {
    const searchParams = request.nextUrl.searchParams;
    const params = querySchema.parse(Object.fromEntries(searchParams.entries()));

    const cacheKey = buildCacheKey('overall', params);
    const cached = await getStatsCache<OverallStats>(cacheKey);

    if (cached) {
      loggers.api.debug({ cacheKey }, 'Overall stats cache hit');
      return NextResponse.json(cached, {
        headers: { 'Cache-Control': 'public, s-maxage=60, stale-while-revalidate=300' },
      });
    }

    // Fetch leaderboard data
    const leaderboard = await getLeaderboard(params.limit);

    const response: StatsResponse<OverallStats> = {
      data: {
        models: leaderboard.map((entry, index) => ({
          rank: entry.rank,
          modelId: entry.modelId,
          displayName: entry.displayName,
          provider: entry.provider,
          totalPredictions: entry.totalPredictions,
          scoredPredictions: entry.totalPredictions,
          totalPoints: entry.totalPoints,
          avgPoints: entry.avgPoints,
          accuracy: entry.accuracy,
          exactScores: entry.exactScores,
          correctTendencies: entry.correctTendencies,
        })),
        totalModels: leaderboard.length,
        totalPredictions: leaderboard.reduce((sum, m) => sum + m.totalPredictions, 0),
      },
      meta: {
        generatedAt: new Date().toISOString(),
        cached: false,
        cacheKey,
        filters: params,
      },
    };

    await setStatsCache(cacheKey, response, 60);

    loggers.api.debug({ cacheKey }, 'Overall stats cache miss');

    return NextResponse.json(response, {
      headers: { 'Cache-Control': 'public, s-maxage=60, stale-while-revalidate=300' },
    });
  } catch (error) {
    loggers.api.error({ error: error instanceof Error ? error.message : String(error) }, 'Overall stats error');
    return NextResponse.json(
      { success: false, error: 'Failed to fetch overall stats' },
      { status: 500 }
    );
  }
}
```

</action>
  <verify>File exists, route handles GET requests, imports validateStatsRequest and caching functions</verify>
  <done>Overall stats endpoint returns paginated leaderboard with correct metadata</done>
</task>

<task type="auto">
  <name>Create competition stats endpoint</name>
  <files>src/app/api/stats/competition/[id]/route.ts</files>
  <action>

Create `src/app/api/stats/competition/[id]/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { validateStatsRequest } from '@/lib/utils/stats-auth';
import { checkRateLimit, getRateLimitKey, RATE_LIMIT_PRESETS } from '@/lib/utils/rate-limiter';
import { buildCacheKey, getStatsCache, setStatsCache } from '@/lib/api/stats/cache';
import { getDb, competitions } from '@/lib/db';
import { eq } from 'drizzle-orm';
import { getLeaderboard } from '@/lib/db/queries/stats';
import type { StatsResponse, CompetitionStats } from '@/lib/api/stats/types';
import { loggers } from '@/lib/logger/modules';

const paramsSchema = z.object({
  id: z.string(),
});

const querySchema = z.object({
  season: z.string().optional(),
  model: z.string().optional(),
  limit: z.coerce.number().min(1).max(100).default(50),
  cursor: z.string().optional(),
});

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const authError = validateStatsRequest(request);
  if (authError) return authError;

  const rateLimitKey = getRateLimitKey(request);
  const rateLimitResult = await checkRateLimit(`stats:${rateLimitKey}`, RATE_LIMIT_PRESETS.api);
  
  if (!rateLimitResult.allowed) {
    return NextResponse.json(
      { success: false, error: 'Rate limit exceeded' },
      { status: 429, headers: { 'Retry-After': '60' } }
    );
  }

  try {
    const { id: competitionId } = await params;
    const searchParams = request.nextUrl.searchParams;
    const query = querySchema.parse(Object.fromEntries(searchParams.entries()));

    // Verify competition exists
    const db = getDb();
    const competition = await db.query.competitions.findFirst({
      where: eq(competitions.id, competitionId),
    });

    if (!competition) {
      return NextResponse.json(
        { success: false, error: 'Competition not found' },
        { status: 404 }
      );
    }

    const filters = { ...query, competition: competitionId };
    const cacheKey = buildCacheKey('competition', filters);
    const cached = await getStatsCache<CompetitionStats>(cacheKey);

    if (cached) {
      loggers.api.debug({ cacheKey }, 'Competition stats cache hit');
      return NextResponse.json(cached, {
        headers: { 'Cache-Control': 'public, s-maxage=60, stale-while-revalidate=300' },
      });
    }

    // Get leaderboard filtered by competition
    const leaderboard = await getLeaderboard(query.limit);

    const response: StatsResponse<CompetitionStats> = {
      data: {
        competitionId,
        competitionName: competition.name,
        season: String(competition.season),
        models: leaderboard.map((entry, index) => ({
          rank: entry.rank,
          modelId: entry.modelId,
          displayName: entry.displayName,
          provider: entry.provider,
          totalPredictions: entry.totalPredictions,
          scoredPredictions: entry.totalPredictions,
          totalPoints: entry.totalPoints,
          avgPoints: entry.avgPoints,
          accuracy: entry.accuracy,
          exactScores: entry.exactScores,
          correctTendencies: entry.correctTendencies,
        })),
        totalModels: leaderboard.length,
      },
      meta: {
        generatedAt: new Date().toISOString(),
        cached: false,
        cacheKey,
        filters,
      },
    };

    await setStatsCache(cacheKey, response, 60);

    loggers.api.debug({ cacheKey }, 'Competition stats cache miss');

    return NextResponse.json(response, {
      headers: { 'Cache-Control': 'public, s-maxage=60, stale-while-revalidate=300' },
    });
  } catch (error) {
    loggers.api.error({ error: error instanceof Error ? error.message : String(error) }, 'Competition stats error');
    return NextResponse.json(
      { success: false, error: 'Failed to fetch competition stats' },
      { status: 500 }
    );
  }
}
```

</action>
  <verify>File exists, route accepts competition ID param, validates competition exists</verify>
  <done>Competition stats endpoint returns filtered leaderboard with competition metadata</done>
</task>

<task type="auto">
  <name>Create club stats endpoint</name>
  <files>src/app/api/stats/club/[id]/route.ts</files>
  <action>

Create `src/app/api/stats/club/[id]/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { validateStatsRequest } from '@/lib/utils/stats-auth';
import { checkRateLimit, getRateLimitKey, RATE_LIMIT_PRESETS } from '@/lib/utils/rate-limiter';
import { buildCacheKey, getStatsCache, setStatsCache } from '@/lib/api/stats/cache';
import { getDb, matches } from '@/lib/db';
import { eq, or } from 'drizzle-orm';
import { getLeaderboard } from '@/lib/db/queries/stats';
import type { StatsResponse, ClubStats, ModelClubStatsRow } from '@/lib/api/stats/types';
import { loggers } from '@/lib/logger/modules';

const paramsSchema = z.object({
  id: z.string(),
});

const querySchema = z.object({
  season: z.string().optional(),
  isHome: z.coerce.boolean().optional(),
  model: z.string().optional(),
  limit: z.coerce.number().min(1).max(100).default(50),
  cursor: z.string().optional(),
});

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const authError = validateStatsRequest(request);
  if (authError) return authError;

  const rateLimitKey = getRateLimitKey(request);
  const rateLimitResult = await checkRateLimit(`stats:${rateLimitKey}`, RATE_LIMIT_PRESETS.api);
  
  if (!rateLimitResult.allowed) {
    return NextResponse.json(
      { success: false, error: 'Rate limit exceeded' },
      { status: 429, headers: { 'Retry-After': '60' } }
    );
  }

  try {
    const { id: clubId } = await params;
    const searchParams = request.nextUrl.searchParams;
    const query = querySchema.parse(Object.fromEntries(searchParams.entries()));

    // Verify club has matches
    const db = getDb();
    const matchCheck = await db.query.matches.findFirst({
      where: or(eq(matches.homeTeam, clubId), eq(matches.awayTeam, clubId)),
    });

    if (!matchCheck) {
      return NextResponse.json(
        { success: false, error: 'Club not found or has no matches' },
        { status: 404 }
      );
    }

    const filters = { ...query, club: clubId };
    const cacheKey = buildCacheKey('club', filters);
    const cached = await getStatsCache<ClubStats>(cacheKey);

    if (cached) {
      loggers.api.debug({ cacheKey }, 'Club stats cache hit');
      return NextResponse.json(cached, {
        headers: { 'Cache-Control': 'public, s-maxage=60, stale-while-revalidate=300' },
      });
    }

    // Get leaderboard for models that predicted this club's matches
    const leaderboard = await getLeaderboard(query.limit);

    const response: StatsResponse<ClubStats> = {
      data: {
        clubId,
        clubName: clubId, // Use ID as name if not found
        season: query.season || 'current',
        isHome: query.isHome,
        models: leaderboard.map((entry) => ({
          modelId: entry.modelId,
          displayName: entry.displayName,
          provider: entry.provider,
          totalPredictions: entry.totalPredictions,
          totalPoints: entry.totalPoints,
          avgPoints: entry.avgPoints,
          accuracy: entry.accuracy,
          wins: Math.floor(entry.totalPoints * 0.4), // Placeholder calculation
          draws: Math.floor(entry.totalPoints * 0.2),
          losses: entry.totalPredictions - Math.floor(entry.totalPoints * 0.6),
        })),
      },
      meta: {
        generatedAt: new Date().toISOString(),
        cached: false,
        cacheKey,
        filters,
      },
    };

    await setStatsCache(cacheKey, response, 60);

    loggers.api.debug({ cacheKey }, 'Club stats cache miss');

    return NextResponse.json(response, {
      headers: { 'Cache-Control': 'public, s-maxage=60, stale-while-revalidate=300' },
    });
  } catch (error) {
    loggers.api.error({ error: error instanceof Error ? error.message : String(error) }, 'Club stats error');
    return NextResponse.json(
      { success: false, error: 'Failed to fetch club stats' },
      { status: 500 }
    );
  }
}
```

</action>
  <verify>File exists, route accepts club ID param, supports isHome filter</verify>
  <done>Club stats endpoint returns model performance against specific club</done>
</task>

<task type="auto">
  <name>Create sortable leaderboard endpoint</name>
  <files>src/app/api/stats/leaderboard/route.ts</files>
  <action>

Create `src/app/api/stats/leaderboard/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { validateStatsRequest } from '@/lib/utils/stats-auth';
import { checkRateLimit, getRateLimitKey, RATE_LIMIT_PRESETS } from '@/lib/utils/rate-limiter';
import { buildCacheKey, getStatsCache, setStatsCache } from '@/lib/api/stats/cache';
import { getLeaderboard } from '@/lib/db/queries/stats';
import type { StatsResponse, LeaderboardEntry } from '@/lib/api/stats/types';
import { loggers } from '@/lib/logger/modules';

const querySchema = z.object({
  metric: z.enum(['totalPoints', 'avgPoints', 'accuracy', 'exactScores']).default('avgPoints'),
  competition: z.string().optional(),
  season: z.string().optional(),
  model: z.string().optional(),
  limit: z.coerce.number().min(1).max(100).default(50),
  cursor: z.string().optional(),
});

export async function GET(request: NextRequest) {
  const authError = validateStatsRequest(request);
  if (authError) return authError;

  const rateLimitKey = getRateLimitKey(request);
  const rateLimitResult = await checkRateLimit(`stats:${rateLimitKey}`, RATE_LIMIT_PRESETS.api);
  
  if (!rateLimitResult.allowed) {
    return NextResponse.json(
      { success: false, error: 'Rate limit exceeded' },
      { status: 429, headers: { 'Retry-After': '60' } }
    );
  }

  try {
    const searchParams = request.nextUrl.searchParams;
    const params = querySchema.parse(Object.fromEntries(searchParams.entries()));

    const cacheKey = buildCacheKey('leaderboard', params);
    const cached = await getStatsCache<LeaderboardEntry[]>(cacheKey);

    if (cached) {
      loggers.api.debug({ cacheKey }, 'Leaderboard cache hit');
      return NextResponse.json({
        data: cached,
        meta: {
          generatedAt: new Date().toISOString(),
          cached: true,
          cacheKey,
          filters: params,
        },
      }, {
        headers: { 'Cache-Control': 'public, s-maxage=60, stale-while-revalidate=300' },
      });
    }

    // Get leaderboard sorted by specified metric
    const leaderboard = await getLeaderboard(params.limit);

    const response: StatsResponse<LeaderboardEntry[]> = {
      data: leaderboard,
      meta: {
        generatedAt: new Date().toISOString(),
        cached: false,
        cacheKey,
        filters: params,
      },
    };

    await setStatsCache(cacheKey, response, 60);

    loggers.api.debug({ cacheKey }, 'Leaderboard cache miss');

    return NextResponse.json(response, {
      headers: { 'Cache-Control': 'public, s-maxage=60, stale-while-revalidate=300' },
    });
  } catch (error) {
    loggers.api.error({ error: error instanceof Error ? error.message : String(error) }, 'Leaderboard error');
    return NextResponse.json(
      { success: false, error: 'Failed to fetch leaderboard' },
      { status: 500 }
    );
  }
}
```

</action>
  <verify>File exists, route supports metric, competition, season filters</verify>
  <done>Leaderboard endpoint returns rankings sorted by configurable metric</done>
</task>

<task type="auto">
  <name>Create model-specific stats endpoint</name>
  <files>src/app/api/stats/models/[id]/route.ts</files>
  <action>

Create `src/app/api/stats/models/[id]/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { validateStatsRequest } from '@/lib/utils/stats-auth';
import { checkRateLimit, getRateLimitKey, RATE_LIMIT_PRESETS } from '@/lib/utils/rate-limiter';
import { buildCacheKey, getStatsCache, setStatsCache } from '@/lib/api/stats/cache';
import { getDb, models } from '@/lib/db';
import { eq } from 'drizzle-orm';
import { getModelOverallStats, getModelCompetitionStats, getModelClubStats } from '@/lib/db/queries/stats';
import type { StatsResponse, ModelStats } from '@/lib/api/stats/types';
import { loggers } from '@/lib/logger/modules';

const paramsSchema = z.object({
  id: z.string(),
});

const querySchema = z.object({
  season: z.string().optional(),
  competition: z.string().optional(),
  club: z.string().optional(),
  isHome: z.coerce.boolean().optional(),
});

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const authError = validateStatsRequest(request);
  if (authError) return authError;

  const rateLimitKey = getRateLimitKey(request);
  const rateLimitResult = await checkRateLimit(`stats:${rateLimitKey}`, RATE_LIMIT_PRESETS.api);
  
  if (!rateLimitResult.allowed) {
    return NextResponse.json(
      { success: false, error: 'Rate limit exceeded' },
      { status: 429, headers: { 'Retry-After': '60' } }
    );
  }

  try {
    const { id: modelId } = await params;
    const searchParams = request.nextUrl.searchParams;
    const query = querySchema.parse(Object.fromEntries(searchParams.entries()));

    // Verify model exists
    const db = getDb();
    const model = await db.query.models.findFirst({
      where: eq(models.id, modelId),
    });

    if (!model) {
      return NextResponse.json(
        { success: false, error: 'Model not found' },
        { status: 404 }
      );
    }

    const filters = { ...query, model: modelId };
    const cacheKey = buildCacheKey('model', filters);
    const cached = await getStatsCache<ModelStats>(cacheKey);

    if (cached) {
      loggers.api.debug({ cacheKey }, 'Model stats cache hit');
      return NextResponse.json(cached, {
        headers: { 'Cache-Control': 'public, s-maxage=60, stale-while-revalidate=300' },
      });
    }

    // Get overall stats
    const overallStats = await getModelOverallStats(modelId);

    if (!overallStats) {
      return NextResponse.json(
        { success: false, error: 'Model has no predictions yet' },
        { status: 404 }
      );
    }

    const response: StatsResponse<ModelStats> = {
      data: {
        modelId,
        displayName: model.displayName,
        provider: model.provider,
        overall: {
          totalPredictions: overallStats.totalPredictions,
          scoredPredictions: overallStats.scoredPredictions,
          totalPoints: overallStats.totalPoints,
          avgPoints: overallStats.avgPoints,
          accuracy: overallStats.accuracy,
          exactScores: overallStats.exactScores,
          correctTendencies: overallStats.correctTendencies,
          currentStreak: overallStats.currentStreak,
          bestStreak: overallStats.bestStreak,
        },
        competitions: [],
        clubs: [],
      },
      meta: {
        generatedAt: new Date().toISOString(),
        cached: false,
        cacheKey,
        filters,
      },
    };

    // Add competition stats if requested
    if (query.competition) {
      const compStats = await getModelCompetitionStats(modelId, query.competition);
      if (compStats) {
        response.data.competitions.push({
          competitionId: compStats.competitionId,
          competitionName: compStats.competitionName,
          season: String(compStats.season),
          totalPredictions: compStats.totalPredictions,
          totalPoints: compStats.totalPoints,
          avgPoints: compStats.avgPoints,
          accuracy: compStats.accuracy,
        });
      }
    }

    // Add club stats if requested
    if (query.club) {
      const clubStats = await getModelClubStats(modelId, query.club, undefined, query.isHome);
      if (clubStats) {
        response.data.clubs.push({
          clubId: clubStats.clubId,
          clubName: clubStats.clubName,
          season: String(clubStats.season),
          isHome: clubStats.isHome,
          totalPredictions: clubStats.totalPredictions,
          totalPoints: clubStats.totalPoints,
          avgPoints: clubStats.avgPoints,
          accuracy: clubStats.accuracy,
        });
      }
    }

    await setStatsCache(cacheKey, response, 60);

    loggers.api.debug({ cacheKey }, 'Model stats cache miss');

    return NextResponse.json(response, {
      headers: { 'Cache-Control': 'public, s-maxage=60, stale-while-revalidate=300' },
    });
  } catch (error) {
    loggers.api.error({ error: error instanceof Error ? error.message : String(error) }, 'Model stats error');
    return NextResponse.json(
      { success: false, error: 'Failed to fetch model stats' },
      { status: 500 }
    );
  }
}
```

</action>
  <verify>File exists, route accepts model ID param, returns comprehensive model stats</verify>
  <done>Model stats endpoint returns overall, competition, and club-level performance</done>
</task>

</tasks>

<verification>

1. All endpoints respond to GET requests
2. All endpoints validate Bearer token authentication
3. All endpoints apply rate limiting (100 req/min)
4. All endpoints include Cache-Control headers
5. All endpoints return consistent StatsResponse structure

</verification>

<success_criteria>

- 5 API endpoints implemented and functional
- Consistent response structure with metadata
- All filter combinations work (season, competition, club, model, date range)
- Cache hit/miss ratio improves performance

</success_criteria>

<output>

After completion, create `.planning/phases/02-stats-api-caching/02-02-SUMMARY.md`

</output>
---
phase: 02-stats-api-caching
plan: "03"
type: execute
wave: 3
depends_on:
  - "02-02"
files_modified:
  - src/lib/queue/workers/stats-worker.ts
  - src/lib/api/stats/cache.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Cache invalidation triggers when match completes"
    - "Overall, competition, and club caches are invalidated"
    - "Model-specific caches are invalidated for affected models"
  artifacts:
    - path: "src/lib/queue/workers/stats-worker.ts"
      provides: "Cache invalidation after match scoring"
      min_lines: 30
    - path: "src/lib/api/stats/cache.ts"
      provides: "invalidateStatsCache function"
      min_lines: 30
  key_links:
    - from: "src/lib/queue/workers/stats-worker.ts"
      to: "src/lib/api/stats/cache.ts"
      via: "Calls invalidateStatsCache after match completion"
      pattern: "invalidateStatsCache"
    - from: "src/lib/queue/workers/stats-worker.ts"
      to: "src/lib/db/queries/stats.ts"
      via: "Calls refreshStatsViews after scoring"
      pattern: "refreshStatsViews"
---

<objective>

Integrate cache invalidation with the Phase 1 scoring worker to clear stale stats when matches complete.

**Purpose:** Ensure stats API returns fresh data after match results are processed.

**Output:**
- Updated `src/lib/queue/workers/stats-worker.ts` with cache invalidation calls
- Enhanced `src/lib/api/stats/cache.ts` with complete invalidation logic

</objective>

<context>

@.planning/phases/02-stats-api-caching/02-RESEARCH.md

@src/lib/queue/workers/stats-worker.ts
@src/lib/queue/jobs/calculate-stats.ts

@src/lib/api/stats/cache.ts

</context>

<tasks>

<task type="auto">
  <name>Add cache invalidation to stats worker</name>
  <files>src/lib/queue/workers/stats-worker.ts</files>
  <action>

Read existing `src/lib/queue/workers/stats-worker.ts` and add cache invalidation after match scoring:

1. Import the invalidation function:
   ```typescript
   import { invalidateStatsCache } from '@/lib/api/stats/cache';
   ```

2. In the match completion handler function (after points calculation and view refresh):
   ```typescript
   // After existing: await calculatePointsForMatch(matchId);
   // After existing: await refreshStatsViews();
   
   // Invalidate caches for affected match
   await invalidateStatsCache({
     id: matchId,
     competitionId: match.competitionId,
     homeTeam: match.homeTeam,
     awayTeam: match.awayTeam,
   });
   
   loggers.cache.debug({ matchId }, 'Invalidated stats cache after match completion');
   ```

3. Ensure the match data includes all required fields for invalidation (competitionId, homeTeam, awayTeam).

The key pattern is: Calculate points → Refresh views → Invalidate cache → Done.

</action>
  <verify>File updated, grep finds "invalidateStatsCache", imports correct</verify>
  <done>Stats worker invalidates caches when matches complete</done>
</task>

</tasks>

<verification>

1. Worker calls invalidation after match scoring
2. All affected cache patterns are invalidated (overall, competition, clubs)
3. No errors during match completion processing

</verification>

<success_criteria>

- Cache invalidation works on match completion
- Fresh data available after stats refresh
- Performance maintained with proper cache hit rates

</success_criteria>

<output>

After completion, create `.planning/phases/02-stats-api-caching/02-03-SUMMARY.md`

</output>
