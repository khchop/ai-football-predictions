---
phase: 22-navigation-internal-linking
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/content/entity-linking.ts
  - src/components/content/entity-linked-text.tsx
autonomous: true

must_haves:
  truths:
    - "Entity names in content become clickable links to their pages"
    - "Each entity is linked only once per content block"
    - "Maximum 5 entity links per content block"
  artifacts:
    - path: "src/lib/content/entity-linking.ts"
      provides: "Entity dictionary builder and text linking utility"
      exports: ["buildEntityDictionary", "linkEntitiesInText", "Entity"]
    - path: "src/components/content/entity-linked-text.tsx"
      provides: "Server component that renders text with entity links"
      exports: ["EntityLinkedText"]
  key_links:
    - from: "src/lib/content/entity-linking.ts"
      to: "src/lib/football/competitions.ts"
      via: "COMPETITIONS array for competition entities"
      pattern: "COMPETITIONS"
---

<objective>
Create entity linking utilities that automatically convert team names, competition names, and model names in content into clickable links.

Purpose: NAVL-04 requires automated entity linking in content. Research shows simple string matching with known entities is faster and more accurate than NLP for structured sports data. This enables internal linking without manual effort.

Output: Entity linking utilities and component ready for use in match content, blog posts, and AI roundups.
</objective>

<execution_context>
@/Users/pieterbos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-navigation-internal-linking/22-RESEARCH.md

# Entity sources
@src/lib/football/competitions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create entity linking utilities</name>
  <files>src/lib/content/entity-linking.ts</files>
  <action>
Create entity dictionary builder and text linking function:

1. Create src/lib/content/entity-linking.ts
2. Define Entity interface:
```typescript
export interface Entity {
  name: string;
  aliases: string[];
  href: string;
  type: 'competition' | 'team' | 'model';
}
```

3. Create buildEntityDictionary function:
```typescript
import { COMPETITIONS } from '@/lib/football/competitions';

export function buildEntityDictionary(
  teams: string[] = [],
  models: Array<{ id: string; displayName: string }> = []
): Entity[] {
  const entities: Entity[] = [];

  // Add competitions from config
  COMPETITIONS.forEach((comp) => {
    entities.push({
      name: comp.name,
      aliases: comp.aliases || [],
      href: `/leagues/${comp.id}`,
      type: 'competition',
    });
  });

  // Add teams (unique only)
  const uniqueTeams = [...new Set(teams)];
  uniqueTeams.forEach((team) => {
    entities.push({
      name: team,
      aliases: [],
      href: `/matches?team=${encodeURIComponent(team)}`,
      type: 'team',
    });
  });

  // Add models
  models.forEach((model) => {
    entities.push({
      name: model.displayName,
      aliases: [],
      href: `/models/${model.id}`,
      type: 'model',
    });
  });

  // Sort by name length descending (match longer names first to avoid partial matches)
  return entities.sort((a, b) => b.name.length - a.name.length);
}
```

4. Create linkEntitiesInText function that returns React nodes:
```typescript
import Link from 'next/link';
import type { ReactNode } from 'react';

export function linkEntitiesInText(
  text: string,
  entities: Entity[],
  maxLinks: number = 5
): ReactNode[] {
  if (!text || entities.length === 0) {
    return [text];
  }

  let linkedCount = 0;
  const linkedEntities = new Set<string>();
  const result: ReactNode[] = [];
  let lastIndex = 0;

  // Build regex with word boundaries
  const allNames = entities.flatMap(e => [e.name, ...e.aliases]);
  if (allNames.length === 0) return [text];

  // Escape special regex characters
  const escapedNames = allNames.map(n =>
    n.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
  );
  const pattern = new RegExp(`\\b(${escapedNames.join('|')})\\b`, 'gi');

  let match;
  while ((match = pattern.exec(text)) !== null) {
    if (linkedCount >= maxLinks) break;

    const matchedName = match[0];
    const entity = entities.find(
      e => e.name.toLowerCase() === matchedName.toLowerCase() ||
           e.aliases.some(a => a.toLowerCase() === matchedName.toLowerCase())
    );

    if (entity && !linkedEntities.has(entity.name.toLowerCase())) {
      // Add text before match
      if (match.index > lastIndex) {
        result.push(text.slice(lastIndex, match.index));
      }

      // Add linked entity
      result.push(
        <Link
          key={`${entity.name}-${match.index}`}
          href={entity.href}
          className="text-primary hover:underline"
        >
          {matchedName}
        </Link>
      );

      linkedEntities.add(entity.name.toLowerCase());
      linkedCount++;
      lastIndex = match.index + matchedName.length;
    }
  }

  // Add remaining text
  if (lastIndex < text.length) {
    result.push(text.slice(lastIndex));
  }

  return result.length > 0 ? result : [text];
}
```

Key design decisions:
- Sort entities by length descending to match "Champions League" before "League"
- Word boundary regex prevents matching "Arsenal" in "Arsenaler"
- Track linked entities to link each entity only once
- maxLinks parameter prevents over-linking (default 5)
- Preserve original casing of matched text
  </action>
  <verify>
1. File compiles: `npx tsc --noEmit`
2. Exports Entity type: `grep "export interface Entity" src/lib/content/entity-linking.ts`
3. Exports buildEntityDictionary: `grep "export function buildEntityDictionary" src/lib/content/entity-linking.ts`
4. Exports linkEntitiesInText: `grep "export function linkEntitiesInText" src/lib/content/entity-linking.ts`
5. Uses word boundaries: `grep "\\\\b" src/lib/content/entity-linking.ts`
  </verify>
  <done>
Entity linking utilities exist with dictionary builder and text processor supporting competitions, teams, and models.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create EntityLinkedText server component</name>
  <files>src/components/content/entity-linked-text.tsx</files>
  <action>
Create a server component that renders text with entity links:

1. Create src/components/content/entity-linked-text.tsx
2. NO 'use client' - this is a server component for SEO
3. Import utilities from entity-linking.ts
4. Accept text, teams array, models array, and maxLinks prop

```typescript
import { buildEntityDictionary, linkEntitiesInText } from '@/lib/content/entity-linking';

interface EntityLinkedTextProps {
  /** The text content to process for entity linking */
  text: string;
  /** Team names to link (from match data) */
  teams?: string[];
  /** Models to link (from getActiveModels or similar) */
  models?: Array<{ id: string; displayName: string }>;
  /** Maximum number of entity links (default: 5) */
  maxLinks?: number;
  /** Optional wrapper className */
  className?: string;
}

export function EntityLinkedText({
  text,
  teams = [],
  models = [],
  maxLinks = 5,
  className,
}: EntityLinkedTextProps) {
  if (!text) return null;

  const entities = buildEntityDictionary(teams, models);
  const linkedContent = linkEntitiesInText(text, entities, maxLinks);

  if (className) {
    return <span className={className}>{linkedContent}</span>;
  }

  return <>{linkedContent}</>;
}
```

Usage example (for documentation in JSDoc):
```tsx
// In a match page
<EntityLinkedText
  text={matchContent.preview}
  teams={[match.homeTeam, match.awayTeam]}
  models={activeModels}
  maxLinks={5}
/>
```
  </action>
  <verify>
1. File compiles: `npx tsc --noEmit`
2. No 'use client': `! grep "'use client'" src/components/content/entity-linked-text.tsx`
3. Exports component: `grep "export function EntityLinkedText" src/components/content/entity-linked-text.tsx`
4. Has maxLinks prop: `grep "maxLinks" src/components/content/entity-linked-text.tsx`
  </verify>
  <done>
EntityLinkedText server component exists, ready for use in match content and blog posts.
  </done>
</task>

</tasks>

<verification>
1. Entity dictionary includes competitions, teams, and models
2. Entities sorted by length to prevent partial matches
3. Word boundary matching prevents false positives
4. Each entity linked only once per text block
5. maxLinks parameter limits total links
6. Server component for SEO-friendly rendering
</verification>

<success_criteria>
- buildEntityDictionary creates entity list from competitions config, teams, and models
- linkEntitiesInText converts text to React nodes with links
- EntityLinkedText component ready for use in content sections
- No client-side JavaScript required (server component)
</success_criteria>

<output>
After completion, create `.planning/phases/22-navigation-internal-linking/22-03-SUMMARY.md`
</output>
