---
phase: 34-pipeline-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/queue/circuit-breaker/queue-circuit-breaker.ts
  - src/lib/queue/workers/content.worker.ts
autonomous: true

must_haves:
  truths:
    - "Queue pauses automatically after 5 consecutive rate limit errors"
    - "Queue auto-resumes after 60 second cooldown"
    - "Consecutive error counter resets on successful job completion"
    - "Sentry alert fires when queue is paused"
  artifacts:
    - path: "src/lib/queue/circuit-breaker/queue-circuit-breaker.ts"
      provides: "Queue-level circuit breaker with pause/resume"
      exports: ["recordQueueRateLimitError", "recordQueueSuccess", "getQueueCircuitStatus"]
    - path: "src/lib/queue/workers/content.worker.ts"
      provides: "Content worker with rate limit detection"
      contains: "recordQueueRateLimitError"
  key_links:
    - from: "content.worker.ts"
      to: "queue-circuit-breaker.ts"
      via: "import and call on 429 errors"
      pattern: "recordQueueRateLimitError"
    - from: "queue-circuit-breaker.ts"
      to: "BullMQ queue.pause()"
      via: "threshold reached triggers pause"
      pattern: "queue\\.pause\\(\\)"
---

<objective>
Implement queue-level circuit breaker that pauses the content queue after 5 consecutive rate limit (429) errors from Together AI, with automatic resume after 60 seconds.

Purpose: Prevents wasted retries and API budget burn when Together AI is rate limiting. The queue pauses to let the rate limit window reset, then auto-resumes.

Output: New queue-circuit-breaker.ts module and updated content worker with rate limit detection.
</objective>

<execution_context>
@/Users/pieterbos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-pipeline-hardening/34-RESEARCH.md

# Key source files
@src/lib/queue/index.ts
@src/lib/queue/workers/content.worker.ts
@src/lib/utils/circuit-breaker.ts
@src/lib/utils/retry-config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create queue-level circuit breaker module</name>
  <files>src/lib/queue/circuit-breaker/queue-circuit-breaker.ts</files>
  <action>
Create a new circuit breaker module specifically for queue-level pause/resume based on rate limit errors.

Implementation requirements:
1. Track consecutive rate limit errors per queue using in-memory Map (no persistence needed - transient state)
2. After 5 consecutive 429 errors, call `queue.pause()` on the content queue
3. Schedule auto-resume after 60 seconds via `setTimeout`
4. On successful job completion, reset consecutive error counter to 0
5. Log state transitions with pino logger (loggers.circuitBreaker)
6. Fire Sentry alert when queue is paused (level: warning)

Interface:
```typescript
interface QueueCircuitConfig {
  rateLimitThreshold: number;      // 5
  autoResumeAfterMs: number;       // 60000
}

// Track per-queue state
interface QueueCircuitState {
  consecutiveRateLimitErrors: number;
  lastRateLimitAt: number;
  isPaused: boolean;
  pausedAt: number | null;
  resumeTimeoutId: NodeJS.Timeout | null;
}

// Exported functions
export async function recordQueueRateLimitError(queueName: string): Promise<void>;
export function recordQueueSuccess(queueName: string): void;
export function getQueueCircuitStatus(queueName: string): QueueCircuitState | undefined;
export function isQueuePaused(queueName: string): boolean;
```

Use atomic Redis INCR for counting if needed for multi-worker safety (research suggested this), but start simple with in-memory since content worker runs concurrency 3 in single process.

Import getQueue from '../index' to get queue reference for pause/resume calls.
  </action>
  <verify>
File exists at src/lib/queue/circuit-breaker/queue-circuit-breaker.ts and exports the required functions. TypeScript compiles without errors: `npx tsc --noEmit src/lib/queue/circuit-breaker/queue-circuit-breaker.ts`
  </verify>
  <done>
Module exports recordQueueRateLimitError, recordQueueSuccess, getQueueCircuitStatus, and isQueuePaused. Pause triggers after 5 errors, auto-resume scheduled for 60s later.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate rate limit detection into content worker</name>
  <files>src/lib/queue/workers/content.worker.ts</files>
  <action>
Update the content worker to detect rate limit errors and notify the queue circuit breaker.

1. Import from new module:
   ```typescript
   import { recordQueueRateLimitError, recordQueueSuccess } from '../circuit-breaker/queue-circuit-breaker';
   ```

2. In the worker's error handler (the catch block inside createContentWorker), detect rate limit errors:
   ```typescript
   // After: log.error({ err: error }, `Error generating ${type}`);
   // Check if this is a rate limit error
   if (error instanceof Error && (error.message.includes('429') || error.message.toLowerCase().includes('rate limit'))) {
     await recordQueueRateLimitError(QUEUE_NAMES.CONTENT);
   }
   ```

3. Add success tracking in the try block after successful generation (before the return):
   ```typescript
   // After successful processing, reset consecutive error count
   recordQueueSuccess(QUEUE_NAMES.CONTENT);
   ```

4. Also update setupContentWorkerEvents to track via QueueEvents:
   ```typescript
   // In the 'failed' event handler, after moving to DLQ
   if (err.message.includes('429') || err.message.toLowerCase().includes('rate limit')) {
     await recordQueueRateLimitError(QUEUE_NAMES.CONTENT);
   }

   // Add completed event handler that records success
   worker.on('completed', (job) => {
     log.info({ jobId: job.id }, 'Job completed');
     recordQueueSuccess(QUEUE_NAMES.CONTENT);
   });
   ```

Do NOT change concurrency, lock duration, or other worker settings - those are already correct from Phase 32.
  </action>
  <verify>
Content worker imports and calls the circuit breaker functions. Build succeeds: `npm run build` (or `npx tsc --noEmit`).
  </verify>
  <done>
Content worker detects 429 errors and calls recordQueueRateLimitError. Successful jobs call recordQueueSuccess to reset counter.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add index export and verify integration</name>
  <files>src/lib/queue/circuit-breaker/index.ts</files>
  <action>
1. Create barrel export file:
   ```typescript
   // src/lib/queue/circuit-breaker/index.ts
   export {
     recordQueueRateLimitError,
     recordQueueSuccess,
     getQueueCircuitStatus,
     isQueuePaused,
   } from './queue-circuit-breaker';
   ```

2. Verify the full flow compiles:
   - Run `npm run build` or `npx tsc --noEmit`
   - Check no import errors

3. Add a simple manual test in a scratch file or comment (not committed) to verify logic:
   - Import functions
   - Call recordQueueRateLimitError 5 times
   - Verify isQueuePaused returns true
  </action>
  <verify>
`npm run build` succeeds with no TypeScript errors. Circuit breaker module is importable from 'src/lib/queue/circuit-breaker'.
  </verify>
  <done>
Circuit breaker module has clean exports, integrates with content worker, and the project builds successfully.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npm run build` passes
2. New file exists: `src/lib/queue/circuit-breaker/queue-circuit-breaker.ts`
3. Content worker updated: imports and uses circuit breaker functions
4. Grep confirms integration: `grep -r "recordQueueRateLimitError" src/lib/queue/workers/content.worker.ts`
</verification>

<success_criteria>
- [ ] queue-circuit-breaker.ts exports recordQueueRateLimitError, recordQueueSuccess
- [ ] Content worker calls recordQueueRateLimitError on 429 errors
- [ ] Content worker calls recordQueueSuccess on job completion
- [ ] Sentry.captureMessage called when queue pauses
- [ ] setTimeout schedules auto-resume after 60s
- [ ] npm run build passes
</success_criteria>

<output>
After completion, create `.planning/phases/34-pipeline-hardening/34-01-SUMMARY.md`
</output>
