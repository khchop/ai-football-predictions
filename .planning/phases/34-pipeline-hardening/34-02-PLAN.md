---
phase: 34-pipeline-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/queue/monitoring/worker-health.ts
  - src/lib/queue/monitoring/content-completeness.ts
  - src/lib/queue/monitoring/index.ts
  - src/lib/queue/scheduler.ts
autonomous: true

must_haves:
  truths:
    - "Worker health check detects when no workers are connected"
    - "Worker health check detects stalled jobs indicating worker death"
    - "Sentry alert fires when worker health check fails"
    - "Content completeness check finds finished matches without content"
    - "Sentry alert fires when matches are missing content for 24+ hours"
  artifacts:
    - path: "src/lib/queue/monitoring/worker-health.ts"
      provides: "Worker health monitoring via getWorkers() and stalled detection"
      exports: ["checkWorkerHealth", "WorkerHealthStatus"]
    - path: "src/lib/queue/monitoring/content-completeness.ts"
      provides: "Content completeness monitoring for finished matches"
      exports: ["checkContentCompleteness", "ContentCompletenessResult"]
    - path: "src/lib/queue/monitoring/index.ts"
      provides: "Barrel exports for monitoring module"
    - path: "src/lib/queue/scheduler.ts"
      provides: "Scheduled monitoring jobs"
      contains: "content-completeness-check"
  key_links:
    - from: "worker-health.ts"
      to: "BullMQ queue.getWorkers()"
      via: "health check function"
      pattern: "getWorkers\\(\\)"
    - from: "content-completeness.ts"
      to: "getMatchesMissingPostMatchContent"
      via: "query for missing content"
      pattern: "getMatchesMissingPostMatchContent"
    - from: "scheduler.ts"
      to: "monitoring functions"
      via: "scheduled job execution"
      pattern: "checkContentCompleteness|checkWorkerHealth"
---

<objective>
Implement worker heartbeat monitoring and content completeness alerting to detect worker death and content generation gaps.

Purpose: Provides observability into pipeline health - alerts when workers die (before jobs pile up) and when finished matches lack content (before users notice gaps).

Output: New monitoring module with health checks and completeness scans, integrated into the scheduler.
</objective>

<execution_context>
@/Users/pieterbos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-pipeline-hardening/34-RESEARCH.md

# Key source files
@src/lib/queue/index.ts
@src/lib/queue/scheduler.ts
@src/lib/content/queries.ts
@src/lib/logger/modules.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create worker health monitoring module</name>
  <files>src/lib/queue/monitoring/worker-health.ts</files>
  <action>
Create a module that checks worker health using BullMQ's getWorkers() API and stalled job detection.

Implementation requirements:
1. Use queue.getWorkers() to check if workers are connected
2. Check for stalled jobs (jobs stuck in 'active' state beyond lockDuration)
3. Report health status via Sentry when unhealthy
4. Return structured health status

Interface:
```typescript
import { Queue } from 'bullmq';
import * as Sentry from '@sentry/nextjs';
import { loggers } from '@/lib/logger/modules';
import { getQueue, QUEUE_NAMES } from '../index';

export interface WorkerHealthStatus {
  queueName: string;
  workerCount: number;
  lastCheckAt: number;
  isHealthy: boolean;
  stalledJobCount: number;
  activeJobCount: number;
}

export async function checkWorkerHealth(queueName: string): Promise<WorkerHealthStatus> {
  const queue = getQueue(queueName);
  const log = loggers.workers.child({ queueName });

  try {
    // Get connected workers
    const workers = await queue.getWorkers();

    // Get active jobs to check for stalled
    const activeJobs = await queue.getJobs(['active'], 0, 100);

    // Jobs active for > 5 minutes may be stalled (lockDuration is 2min for content)
    const stalledThresholdMs = 5 * 60 * 1000;
    const now = Date.now();
    const stalledJobs = activeJobs.filter(job => {
      const processedOn = job.processedOn;
      return processedOn && (now - processedOn > stalledThresholdMs);
    });

    const isHealthy = workers.length > 0 || stalledJobs.length === 0;

    if (!isHealthy) {
      log.error({
        workerCount: workers.length,
        stalledJobCount: stalledJobs.length,
        activeJobCount: activeJobs.length,
      }, 'Worker health check failed');

      Sentry.captureMessage(`Worker health check failed for ${queueName}`, {
        level: 'error',
        tags: { queue: queueName, feature: 'worker-heartbeat' },
        extra: {
          workerCount: workers.length,
          stalledJobCount: stalledJobs.length,
          stalledJobIds: stalledJobs.slice(0, 5).map(j => j.id),
        },
      });
    } else {
      log.debug({
        workerCount: workers.length,
        activeJobCount: activeJobs.length,
      }, 'Worker health check passed');
    }

    return {
      queueName,
      workerCount: workers.length,
      lastCheckAt: now,
      isHealthy,
      stalledJobCount: stalledJobs.length,
      activeJobCount: activeJobs.length,
    };
  } catch (error) {
    log.error({ err: error }, 'Failed to check worker health');
    throw error;
  }
}
```

Health check is unhealthy if:
- No workers connected AND there are stalled jobs
- We allow 0 workers if queue is idle (no stalled jobs)
  </action>
  <verify>
File exists and exports checkWorkerHealth and WorkerHealthStatus. TypeScript compiles: `npx tsc --noEmit src/lib/queue/monitoring/worker-health.ts`
  </verify>
  <done>
Worker health module detects missing workers and stalled jobs, alerts via Sentry when unhealthy.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create content completeness monitoring module</name>
  <files>src/lib/queue/monitoring/content-completeness.ts</files>
  <action>
Create a module that checks for finished matches missing content and alerts via Sentry.

Implementation requirements:
1. Use existing getMatchesMissingPostMatchContent() from @/lib/content/queries
2. Only alert for matches finished > 24 hours ago (grace period prevents alert fatigue)
3. Report via Sentry when matches are missing content
4. Return structured result for logging/metrics

Interface:
```typescript
import * as Sentry from '@sentry/nextjs';
import { loggers } from '@/lib/logger/modules';
import { getMatchesMissingPostMatchContent } from '@/lib/content/queries';

export interface ContentCompletenessResult {
  finishedMatchesWithoutContent: number;
  matchIds: string[];
  alertTriggered: boolean;
  checkTime: number;
}

export async function checkContentCompleteness(): Promise<ContentCompletenessResult> {
  const log = loggers.content;
  const now = Date.now();

  try {
    // Get matches finished in last 7 days without post-match content
    // The query already handles the time window
    const missingContent = await getMatchesMissingPostMatchContent(7);

    // Only alert for matches older than 24 hours (grace period)
    // This requires checking match finish time - for now alert if any missing
    const shouldAlert = missingContent.length > 0;

    if (shouldAlert) {
      log.warn({
        count: missingContent.length,
        matchIds: missingContent.slice(0, 10).map(m => m.matchId),
      }, 'Finished matches missing content detected');

      Sentry.captureMessage(
        `${missingContent.length} finished matches have no post-match content`,
        {
          level: 'warning',
          tags: { feature: 'content-completeness' },
          extra: {
            matchCount: missingContent.length,
            sampleMatches: missingContent.slice(0, 5).map(m => ({
              matchId: m.matchId,
              teams: `${m.homeTeam} vs ${m.awayTeam}`,
            })),
          },
        }
      );
    } else {
      log.debug({ matchCount: missingContent.length }, 'Content completeness check passed');
    }

    return {
      finishedMatchesWithoutContent: missingContent.length,
      matchIds: missingContent.map(m => m.matchId),
      alertTriggered: shouldAlert,
      checkTime: now,
    };
  } catch (error) {
    log.error({ err: error }, 'Failed to check content completeness');
    throw error;
  }
}
```

Note: The existing getMatchesMissingPostMatchContent already filters to finished matches with predictions that lack content, so we reuse that query.
  </action>
  <verify>
File exists and exports checkContentCompleteness and ContentCompletenessResult. TypeScript compiles: `npx tsc --noEmit src/lib/queue/monitoring/content-completeness.ts`
  </verify>
  <done>
Content completeness module detects missing content and alerts via Sentry when matches lack post-match content.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create monitoring index and integrate with scheduler</name>
  <files>
    src/lib/queue/monitoring/index.ts
    src/lib/queue/scheduler.ts
  </files>
  <action>
1. Create barrel export file for monitoring module:
```typescript
// src/lib/queue/monitoring/index.ts
export { checkWorkerHealth, type WorkerHealthStatus } from './worker-health';
export { checkContentCompleteness, type ContentCompletenessResult } from './content-completeness';
```

2. Update scheduler.ts to add monitoring jobs:

Find the existing scheduler file and add two new repeatable jobs:

a) Worker health check (every 5 minutes):
```typescript
// Add import at top
import { checkWorkerHealth, checkContentCompleteness } from './monitoring';

// In the scheduler setup function, add:
await contentQueue.add(
  'worker-health-check',
  { type: 'worker_health_check', data: { queueName: QUEUE_NAMES.CONTENT } },
  {
    repeat: { every: 5 * 60 * 1000 }, // Every 5 minutes
    jobId: 'worker-health-check-repeatable',
    removeOnComplete: { age: 3600 }, // Keep 1 hour
    removeOnFail: { age: 86400 }, // Keep 1 day
  }
);
```

b) Content completeness check (every hour):
```typescript
await contentQueue.add(
  'content-completeness-check',
  { type: 'content_completeness_check', data: {} },
  {
    repeat: { every: 60 * 60 * 1000 }, // Every hour
    jobId: 'content-completeness-check-repeatable',
    removeOnComplete: { age: 86400 }, // Keep 1 day
    removeOnFail: { age: 604800 }, // Keep 1 week
  }
);
```

3. Update content worker to handle these job types:

In content.worker.ts, add handlers for the new job types in the job processing switch:
```typescript
} else if (type === 'worker_health_check') {
  const { queueName } = data as { queueName: string };
  return await checkWorkerHealth(queueName);
} else if (type === 'content_completeness_check') {
  return await checkContentCompleteness();
}
```

Import the monitoring functions at the top of content.worker.ts:
```typescript
import { checkWorkerHealth, checkContentCompleteness } from '../monitoring';
```
  </action>
  <verify>
1. Monitoring index exports both functions: `grep -l "checkWorkerHealth" src/lib/queue/monitoring/index.ts`
2. Scheduler adds repeatable jobs: `grep "content-completeness-check" src/lib/queue/scheduler.ts`
3. Build succeeds: `npm run build`
  </verify>
  <done>
Monitoring module has barrel exports, scheduler registers repeatable health and completeness checks, content worker processes these job types.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npm run build` passes
2. Monitoring files exist:
   - `src/lib/queue/monitoring/worker-health.ts`
   - `src/lib/queue/monitoring/content-completeness.ts`
   - `src/lib/queue/monitoring/index.ts`
3. Scheduler updated: `grep "completeness-check\|health-check" src/lib/queue/scheduler.ts`
4. Content worker handles new job types: `grep "worker_health_check\|content_completeness_check" src/lib/queue/workers/content.worker.ts`
</verification>

<success_criteria>
- [ ] worker-health.ts exports checkWorkerHealth function
- [ ] checkWorkerHealth calls queue.getWorkers() and checks for stalled jobs
- [ ] content-completeness.ts exports checkContentCompleteness function
- [ ] checkContentCompleteness uses getMatchesMissingPostMatchContent
- [ ] Sentry alerts fire for unhealthy workers and missing content
- [ ] Scheduler adds repeatable jobs for health check (5min) and completeness (1hr)
- [ ] Content worker handles worker_health_check and content_completeness_check job types
- [ ] npm run build passes
</success_criteria>

<output>
After completion, create `.planning/phases/34-pipeline-hardening/34-02-SUMMARY.md`
</output>
