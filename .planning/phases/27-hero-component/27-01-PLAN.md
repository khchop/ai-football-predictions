---
phase: 27-hero-component
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/match/use-live-match-minute.ts
  - src/components/match/match-hero.tsx
  - src/app/api/match-minute/[id]/route.ts
autonomous: true

must_haves:
  truths:
    - "Score/VS displays exactly once in hero section (not in header, H1, or elsewhere)"
    - "Hero shows teams with logo + name on left/right, score centered"
    - "Live matches display current minute via polling (30s interval)"
    - "Upcoming matches show VS text instead of score"
    - "All states have explicit badge: LIVE, FT, Upcoming, HT, POSTPONED, CANCELLED"
  artifacts:
    - path: "src/components/match/match-hero.tsx"
      provides: "Single authoritative score/VS display component"
      min_lines: 80
    - path: "src/components/match/use-live-match-minute.ts"
      provides: "Polling hook for live match minute with cleanup"
      min_lines: 40
    - path: "src/app/api/match-minute/[id]/route.ts"
      provides: "API endpoint returning current match minute"
      exports: ["GET"]
  key_links:
    - from: "src/components/match/match-hero.tsx"
      to: "MatchDataProvider context"
      via: "useMatch() hook"
      pattern: "useMatch\\(\\)"
    - from: "src/components/match/match-hero.tsx"
      to: "use-live-match-minute.ts"
      via: "useLiveMatchMinute() hook"
      pattern: "useLiveMatchMinute\\("
    - from: "src/components/match/use-live-match-minute.ts"
      to: "/api/match-minute/[id]"
      via: "fetch call"
      pattern: "fetch.*api/match-minute"
---

<objective>
Create the MatchHero component as the single authoritative score/VS display for match pages.

Purpose: Eliminate duplicate score displays across header, H1, and content areas by establishing one hero section as the canonical source. Support all match states (upcoming/live/finished/postponed/cancelled) with appropriate visual treatment.

Output: MatchHero component consuming MatchDataProvider context, useLiveMatchMinute polling hook, and API route for live match minute.
</objective>

<execution_context>
@/Users/pieterbos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-hero-component/27-CONTEXT.md
@.planning/phases/27-hero-component/27-RESEARCH.md

# From Phase 26 - Context provider foundation
@src/components/match/match-data-provider.tsx
@src/components/match/use-match.ts

# Existing patterns to follow
@src/components/match/match-header.tsx
@src/components/ui/badge.tsx
@src/lib/football/api-football.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useLiveMatchMinute polling hook</name>
  <files>src/components/match/use-live-match-minute.ts</files>
  <action>
Create custom hook for polling live match minute with proper cleanup and visibility detection.

Requirements:
1. Accept externalId (string | null), isLive (boolean), intervalMs (number = 30000)
2. Return string | null (e.g., "67'", "HT", "90'+3", null)
3. Only poll when isLive is true AND externalId is not null
4. Use useRef for interval ID (not state) to enable cleanup
5. Return cleanup function from useEffect that calls clearInterval
6. Add visibility change detection:
   - Listen to 'visibilitychange' event on document
   - Pause polling when document.hidden is true
   - Resume polling when page becomes visible again
   - Clean up visibility listener on unmount
7. Fetch from `/api/match-minute/${externalId}` endpoint
8. Include 'use client' directive

Pattern to follow (from 27-RESEARCH.md):
```typescript
'use client';

import { useEffect, useRef, useState } from 'react';

export function useLiveMatchMinute(
  externalId: string | null,
  isLive: boolean,
  intervalMs: number = 30000
): string | null {
  const [minute, setMinute] = useState<string | null>(null);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  // Main polling effect
  useEffect(() => {
    if (!isLive || !externalId) {
      setMinute(null);
      return;
    }

    async function fetchMinute() {
      try {
        const res = await fetch(`/api/match-minute/${externalId}`);
        if (res.ok) {
          const data = await res.json();
          setMinute(data.minute);
        }
      } catch (error) {
        console.error('Failed to fetch match minute:', error);
      }
    }

    fetchMinute();
    intervalRef.current = setInterval(fetchMinute, intervalMs);

    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
        intervalRef.current = null;
      }
    };
  }, [isLive, externalId, intervalMs]);

  // Visibility change handling
  useEffect(() => {
    function handleVisibilityChange() {
      if (document.hidden && intervalRef.current) {
        clearInterval(intervalRef.current);
        intervalRef.current = null;
      } else if (!document.hidden && isLive && externalId) {
        // Resume with fresh fetch + interval
        // ... (implementation details)
      }
    }

    document.addEventListener('visibilitychange', handleVisibilityChange);
    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
    };
  }, [isLive, externalId, intervalMs]);

  return minute;
}
```

DO NOT:
- Store interval ID in useState (causes stale closure issues)
- Forget cleanup function (memory leak)
- Poll when tab is hidden (wastes API quota)
  </action>
  <verify>
TypeScript compiles without errors:
```bash
npx tsc --noEmit src/components/match/use-live-match-minute.ts
```
  </verify>
  <done>Hook file exists at src/components/match/use-live-match-minute.ts with 'use client', proper useRef for interval, cleanup in useEffect return, and visibility change handling.</done>
</task>

<task type="auto">
  <name>Task 2: Create match-minute API route</name>
  <files>src/app/api/match-minute/[id]/route.ts</files>
  <action>
Create API route that returns current match minute for live matches.

Requirements:
1. Accept fixture ID as dynamic route param [id]
2. Fetch fixture status from API-Football
3. Use existing formatMatchMinute utility from @/lib/football/api-football
4. Return JSON: { minute: string | null }
5. Cache response for 30 seconds (next: { revalidate: 30 })
6. Handle errors gracefully (return { minute: null } on failure)

Implementation:
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { formatMatchMinute } from '@/lib/football/api-football';

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;

  try {
    const res = await fetch(
      `https://v3.football.api-sports.io/fixtures?id=${id}`,
      {
        headers: {
          'x-rapidapi-key': process.env.API_FOOTBALL_KEY || '',
          'x-rapidapi-host': 'v3.football.api-sports.io',
        },
        next: { revalidate: 30 },
      }
    );

    if (!res.ok) {
      return NextResponse.json({ minute: null }, { status: res.status });
    }

    const data = await res.json();
    const fixture = data.response?.[0];

    if (!fixture) {
      return NextResponse.json({ minute: null }, { status: 404 });
    }

    const minute = formatMatchMinute(fixture.fixture.status);

    return NextResponse.json(
      { minute },
      {
        headers: {
          'Cache-Control': 'public, s-maxage=30, stale-while-revalidate=60',
        },
      }
    );
  } catch (error) {
    console.error('Failed to fetch match minute:', error);
    return NextResponse.json({ minute: null }, { status: 500 });
  }
}
```

Note: formatMatchMinute expects { elapsed: number | null; short: string } which matches fixture.fixture.status from API-Football.
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit src/app/api/match-minute/\\[id\\]/route.ts
```
Route structure is valid (Next.js App Router dynamic route).
  </verify>
  <done>API route exists at src/app/api/match-minute/[id]/route.ts, returns { minute: string | null }, uses formatMatchMinute utility.</done>
</task>

<task type="auto">
  <name>Task 3: Create MatchHero component</name>
  <files>src/components/match/match-hero.tsx</files>
  <action>
Create the MatchHero component that consumes MatchDataProvider context and renders the single authoritative score display.

Layout per user decisions (27-CONTEXT.md):
```
[Home Team Logo+Name] — [Score/VS large centered] — [Away Team Logo+Name]
                        Competition • Date • Time/Minute • Badge
```

Requirements:
1. 'use client' directive (uses hooks)
2. Import and use useMatch() hook for data (NOT props)
3. Import and use useLiveMatchMinute() for live match minute
4. Import Badge from @/components/ui/badge
5. Import Image from next/image with priority prop for logos
6. Import format, parseISO from date-fns

Visual implementation:
1. Team sections: flex-1 text-center, logo (h-20 w-20 md:h-24 md:w-24), team name below
2. Score/VS: centered, large (text-5xl md:text-6xl), tabular-nums for score digits
3. Upcoming: show "VS" text with gradient-text class
4. Live/Finished: show score as "homeScore - awayScore"
5. Postponed: show "POSTPONED" text instead of score
6. Cancelled: show "CANCELLED" text with line-through

Meta row below (per user decisions):
- Competition name (with Trophy icon optional)
- Date (format: 'MMMM d, yyyy')
- Time OR live minute (live matches show minute, others show kickoff time 'HH:mm')
- Status badge:
  - live + HT minute: Badge variant="live" showing "HT"
  - live (not HT): Badge variant="live" showing "LIVE"
  - finished: Badge variant="finished" showing "FT"
  - upcoming: Badge variant="upcoming" showing "Upcoming"
  - postponed: custom styling showing "POSTPONED"
  - cancelled: custom styling showing "CANCELLED"

Important per user decisions:
- NO venue in hero (keep minimal)
- NO form or league position
- NO animation/pulsing on LIVE badge (user rejected)
- Clean/minimal background (solid or subtle)
- Always show match date for all states
- Winner team name/score highlighted in green for finished matches (existing pattern from match-header.tsx)

Fallback for missing logo: Show first letter of team name in placeholder div.

Follow existing match-header.tsx patterns for:
- Tailwind classes (bg-card, border-border, rounded-xl, etc.)
- Winner highlighting logic
- Logo placeholder styling
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit src/components/match/match-hero.tsx
```
Component uses useMatch() (not props), has 'use client' directive.
  </verify>
  <done>
MatchHero component exists at src/components/match/match-hero.tsx that:
- Uses useMatch() hook to get data from context
- Renders teams with logo + name on sides
- Renders score/VS centered and large
- Shows status badge for all states (LIVE, FT, Upcoming, HT, POSTPONED, CANCELLED)
- Shows live minute (from useLiveMatchMinute) or kickoff time
- Has no venue, no form, no league position per user decisions
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. All files exist and compile:
```bash
npx tsc --noEmit \
  src/components/match/match-hero.tsx \
  src/components/match/use-live-match-minute.ts \
  src/app/api/match-minute/\\[id\\]/route.ts
```

2. MatchHero uses useMatch (not props):
```bash
grep -q "useMatch()" src/components/match/match-hero.tsx && echo "PASS: uses useMatch" || echo "FAIL"
```

3. Polling hook has cleanup:
```bash
grep -q "clearInterval" src/components/match/use-live-match-minute.ts && echo "PASS: has cleanup" || echo "FAIL"
```

4. No duplicate score display patterns created (hero is single source)
</verification>

<success_criteria>
- src/components/match/match-hero.tsx exists and compiles
- src/components/match/use-live-match-minute.ts exists with cleanup logic
- src/app/api/match-minute/[id]/route.ts exists and returns { minute: string | null }
- MatchHero consumes context via useMatch() (not props)
- All match states have explicit badge display
- Live matches show minute via polling hook
</success_criteria>

<output>
After completion, create `.planning/phases/27-hero-component/27-01-SUMMARY.md`
</output>
