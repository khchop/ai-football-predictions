---
phase: 43-testing-validation
plan: 03
type: execute
wave: 3
depends_on: ["43-02"]
files_modified:
  - scripts/check-fallback-rate.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Fallback rate can be checked programmatically"
    - "Script alerts if fallback rate exceeds 5% threshold"
    - "Production validation confirms no regressions in working models"
  artifacts:
    - path: "scripts/check-fallback-rate.ts"
      provides: "Fallback rate monitoring script"
      contains: "fallbackRate"
    - path: "package.json"
      provides: "check:fallback-rate npm script"
      contains: "check:fallback"
  key_links:
    - from: "scripts/check-fallback-rate.ts"
      to: "src/lib/db/index.ts"
      via: "database query"
      pattern: "getDb|drizzle"
---

<objective>
Create production validation script to monitor fallback rates and confirm model health.

Purpose: Complete Phase 43 success criteria by providing tools to verify fallback frequency remains <5% and that previously disabled models are operating at >90% success rate.

Output: Production monitoring script that validates model health metrics from the database.
</objective>

<execution_context>
@/Users/pieterbos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/43-testing-validation/43-RESEARCH.md
@.planning/phases/43-testing-validation/43-02-SUMMARY.md
@src/app/api/admin/fallback-stats/route.ts
@src/lib/llm/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create fallback rate monitoring script</name>
  <files>
    - scripts/check-fallback-rate.ts
  </files>
  <action>
1. Create `scripts/check-fallback-rate.ts`:
   - Import dotenv and load .env.local
   - Import getDb from '../src/lib/db'
   - Import sql from 'drizzle-orm'
   - Import MODEL_FALLBACKS from '../src/lib/llm'

2. Implement fallback stats query (similar to fallback-stats route but for CLI):
   ```typescript
   interface FallbackCheck {
     modelId: string;
     totalPredictions: number;
     fallbackCount: number;
     fallbackRate: number;
     successRate: number;
   }

   async function getFallbackStats(days: number = 7): Promise<FallbackCheck[]> {
     const db = getDb();
     const cutoffDate = new Date();
     cutoffDate.setDate(cutoffDate.getDate() - days);

     const result = await db.execute<{
       modelId: string;
       totalPredictions: string;
       fallbackCount: string;
     }>(sql`
       SELECT
         "modelId",
         COUNT(*)::text as "totalPredictions",
         SUM(CASE WHEN "usedFallback" = true THEN 1 ELSE 0 END)::text as "fallbackCount"
       FROM predictions
       WHERE "createdAt" >= ${cutoffDate.toISOString()}
       GROUP BY "modelId"
       ORDER BY COUNT(*) DESC
     `);

     return result.rows.map(row => {
       const total = parseInt(row.totalPredictions, 10);
       const fallback = parseInt(row.fallbackCount, 10);
       return {
         modelId: row.modelId,
         totalPredictions: total,
         fallbackCount: fallback,
         fallbackRate: total > 0 ? fallback / total : 0,
         successRate: total > 0 ? (total - fallback) / total : 0,
       };
     });
   }
   ```

3. Implement validation logic:
   ```typescript
   const FALLBACK_THRESHOLD = 0.05; // 5%
   const SUCCESS_THRESHOLD = 0.90; // 90%
   const MIN_SAMPLES = 10; // Minimum predictions to evaluate

   async function main() {
     console.log('\n=== Fallback Rate Check ===\n');

     const stats = await getFallbackStats(7);

     // Calculate global fallback rate
     const globalStats = stats.reduce((acc, s) => {
       acc.total += s.totalPredictions;
       acc.fallback += s.fallbackCount;
       return acc;
     }, { total: 0, fallback: 0 });

     const globalFallbackRate = globalStats.total > 0
       ? globalStats.fallback / globalStats.total
       : 0;

     console.log(`Global stats (last 7 days):`);
     console.log(`  Total predictions: ${globalStats.total}`);
     console.log(`  Fallback count: ${globalStats.fallback}`);
     console.log(`  Fallback rate: ${(globalFallbackRate * 100).toFixed(2)}%`);
     console.log(`  Threshold: <${(FALLBACK_THRESHOLD * 100)}%`);

     // Check global threshold
     const globalPassed = globalFallbackRate < FALLBACK_THRESHOLD;
     console.log(`  Status: ${globalPassed ? 'PASS' : 'FAIL'}\n`);

     // Check models with configured fallbacks
     console.log('Models with fallback configured:');
     const modelsWithFallback = Object.keys(MODEL_FALLBACKS);

     let failedModels = 0;
     for (const modelId of modelsWithFallback) {
       const modelStats = stats.find(s => s.modelId === modelId);

       if (!modelStats || modelStats.totalPredictions < MIN_SAMPLES) {
         console.log(`  ${modelId}: Insufficient data (${modelStats?.totalPredictions || 0} samples)`);
         continue;
       }

       const passed = modelStats.successRate >= SUCCESS_THRESHOLD;
       const status = passed ? 'PASS' : 'FAIL';
       console.log(`  ${modelId}: ${(modelStats.successRate * 100).toFixed(1)}% success (${modelStats.totalPredictions} samples) - ${status}`);

       if (!passed) failedModels++;
     }

     console.log('\n=== SUMMARY ===');
     console.log(`Global fallback rate: ${globalPassed ? 'PASS' : 'FAIL'}`);
     console.log(`Models below 90% threshold: ${failedModels}`);

     // Exit code
     if (!globalPassed || failedModels > 0) {
       console.log('\nValidation FAILED');
       process.exit(1);
     }

     console.log('\nValidation PASSED');
     process.exit(0);
   }
   ```

4. Handle database connection cleanup:
   ```typescript
   main()
     .catch(error => {
       console.error('\nError:', error.message);
       process.exit(1);
     })
     .finally(() => {
       // Allow connection pool to drain
       setTimeout(() => process.exit(0), 100);
     });
   ```

Key validations:
- Global fallback rate <5% (requirement: "remains <5% of total predictions")
- Models with fallbacks configured have >90% success rate
- Reports per-model statistics for debugging
  </action>
  <verify>
Run `npm run check:fallback` (after adding script) - should query database and report results.
  </verify>
  <done>
Fallback rate check script created. Queries production database and validates against thresholds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add npm scripts and create validation summary</name>
  <files>
    - package.json
  </files>
  <action>
1. Add npm scripts to package.json:
   - "check:fallback": "npx tsx scripts/check-fallback-rate.ts"
   - "validate:production": "npm run check:fallback"
   - "validate:all": "npm run validate:models && npm run check:fallback"

2. Update existing validate script if present, or ensure it doesn't conflict.

3. Create a combined validation command that runs:
   a. Model JSON validation (42 models)
   b. Fallback rate check

The scripts provide:
- `npm run validate:models` - Test all 42 models return valid JSON
- `npm run check:fallback` - Verify production fallback rate <5%
- `npm run validate:all` - Complete validation suite
  </action>
  <verify>
Run `npm run check:fallback` - should complete without errors.
Run `cat package.json | grep validate` - should show all new scripts.
  </verify>
  <done>
All validation scripts added to package.json. Complete validation suite available via npm scripts.
  </done>
</task>

</tasks>

<verification>
1. `npm run check:fallback` queries database and reports fallback rates
2. Script exits with code 1 if global fallback rate >5%
3. Script exits with code 1 if any model with fallback has <90% success
4. `npm run validate:all` runs complete validation suite
</verification>

<success_criteria>
- Fallback rate script queries predictions table for last 7 days
- Global fallback rate threshold enforced (<5%)
- Per-model success rate tracked for models with fallback configured
- Script provides clear pass/fail output with exit codes
- npm scripts available for CI/manual validation
</success_criteria>

<output>
After completion, create `.planning/phases/43-testing-validation/43-03-SUMMARY.md`
</output>
