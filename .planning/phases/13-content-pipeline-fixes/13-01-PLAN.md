---
phase: 13-content-pipeline-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/db/queries.ts
  - src/lib/content/queries.ts
autonomous: true

must_haves:
  truths:
    - "Unified query returns content from matchContent table"
    - "Unified query returns content from matchRoundups table when no matchContent exists"
    - "Post-match content prefers roundup narrative over short matchContent"
    - "Query handles null cases gracefully (no errors when content missing)"
  artifacts:
    - path: "src/lib/db/queries.ts"
      provides: "getMatchContentUnified() function"
      exports: ["getMatchContentUnified"]
    - path: "src/lib/content/queries.ts"
      provides: "Updated getMatchContent() using unified logic"
  key_links:
    - from: "src/lib/db/queries.ts"
      to: "matchContent + matchRoundups tables"
      via: "LEFT JOIN with COALESCE"
      pattern: "COALESCE.*matchRoundups.*matchContent"
---

<objective>
Create unified content query that fetches from both matchContent and matchRoundups tables in a single database round-trip, using COALESCE to prioritize full roundup narratives over short-form matchContent for post-match display.

Purpose: Fix CONT-04 requirement - unified content source preventing missing content due to dual-table writes.
Output: `getMatchContentUnified()` query function in queries.ts
</objective>

<execution_context>
@/Users/pieterbos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-content-pipeline-fixes/13-RESEARCH.md

# Key existing files
@src/lib/db/schema.ts
@src/lib/db/queries.ts
@src/lib/content/queries.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create getMatchContentUnified() query function</name>
  <files>src/lib/db/queries.ts</files>
  <action>
Add new exported function `getMatchContentUnified(matchId: string)` that:

1. Uses LEFT JOIN to query both matchContent and matchRoundups tables by matchId
2. Returns unified content object with fields:
   - matchId: string
   - preMatchContent: string | null (from matchContent)
   - preMatchGeneratedAt: string | null (from matchContent)
   - bettingContent: string | null (from matchContent)
   - bettingGeneratedAt: string | null (from matchContent)
   - postMatchContent: string | null (COALESCE: prefer roundup.narrative over matchContent.postMatchContent)
   - postMatchGeneratedAt: string | null (CASE: use roundup.publishedAt if roundup exists, else matchContent timestamp)
   - hasFullRoundup: boolean (true if matchRoundups row exists)

3. Uses Drizzle sql template literal for COALESCE:
```typescript
postMatchContent: sql<string | null>`COALESCE(${matchRoundups.narrative}, ${matchContent.postMatchContent})`.as('post_match_content')
```

4. Handles edge cases:
   - matchContent exists but matchRoundups doesn't (return matchContent fields)
   - matchRoundups exists but matchContent doesn't (query must handle this - may need UNION or separate query for roundup-only matches)
   - Neither exists (return null)

5. Import matchRoundups from schema.ts if not already imported

Note: The research suggests LEFT JOIN from matchContent to matchRoundups. However, if roundups can exist WITHOUT matchContent (edge case), may need UNION or RIGHT JOIN. Check database to confirm expected state. Conservative approach: query both tables independently if UNION too complex.
  </action>
  <verify>
Add temporary test at end of function:
```typescript
// Test query - remove after verification
console.log('getMatchContentUnified test:', result);
```
Run: `npx tsx -e "import { getMatchContentUnified } from './src/lib/db/queries'; getMatchContentUnified('some-match-id').then(console.log).catch(console.error)"` with a known match ID that has content.
  </verify>
  <done>
Function returns content from both tables with COALESCE prioritizing roundup narrative for post-match content. TypeScript compiles without errors. Function is exported.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update content/queries.ts to use unified query</name>
  <files>src/lib/content/queries.ts</files>
  <action>
Update the existing `getMatchContent()` function in src/lib/content/queries.ts to use the unified query logic:

Option A (Preferred): Update getMatchContent to call getMatchContentUnified:
```typescript
import { getMatchContentUnified } from '@/lib/db/queries';

export async function getMatchContent(matchId: string) {
  return getMatchContentUnified(matchId);
}
```

Option B: If existing callers depend on old return type, create adapter:
```typescript
export async function getMatchContent(matchId: string) {
  const unified = await getMatchContentUnified(matchId);
  if (!unified) return null;

  // Map to existing return type if needed
  return {
    id: '', // Not needed by consumers
    matchId: unified.matchId,
    preMatchContent: unified.preMatchContent,
    preMatchGeneratedAt: unified.preMatchGeneratedAt,
    bettingContent: unified.bettingContent,
    bettingGeneratedAt: unified.bettingGeneratedAt,
    postMatchContent: unified.postMatchContent,
    postMatchGeneratedAt: unified.postMatchGeneratedAt,
    // Add hasFullRoundup if MatchContentSection needs it
  };
}
```

Remove the old direct query to matchContent table only.
  </action>
  <verify>
`npm run build` completes without type errors.
Check that MatchContentSection imports from content/queries still work.
  </verify>
  <done>
getMatchContent() now returns unified content from both tables. Build passes. No runtime errors on match page load.
  </done>
</task>

</tasks>

<verification>
1. Build passes: `npm run build`
2. Types correct: No TypeScript errors in queries.ts or content/queries.ts
3. Query works: Manual test with known match ID shows content from both tables
4. Edge case: Query returns gracefully null when no content exists (no 500 errors)
</verification>

<success_criteria>
- getMatchContentUnified() exists and is exported from queries.ts
- getMatchContent() returns unified content (prefers roundup for post-match)
- Build completes without type errors
- Content queries include data from matchRoundups.narrative when available
</success_criteria>

<output>
After completion, create `.planning/phases/13-content-pipeline-fixes/13-01-SUMMARY.md`
</output>
