---
phase: 05-stats-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/services/stats.ts
  - src/lib/types/stats.ts
autonomous: true

must_haves:
  truths:
    - "Stats service exports functions for model accuracy calculation"
    - "Accuracy formula uses tendencyPoints > 0 denominator"
    - "All division operations protected with NULLIF()"
  artifacts:
    - path: "src/lib/services/stats.ts"
      provides: "Canonical accuracy calculation functions"
      exports: ["getModelAccuracyStats", "getCompetitionModelStats", "ACCURACY_SQL"]
    - path: "src/lib/types/stats.ts"
      provides: "Shared TypeScript interfaces for stats"
      exports: ["ModelAccuracyStats", "CompetitionModelStats"]
  key_links:
    - from: "src/lib/services/stats.ts"
      to: "src/lib/db"
      via: "Drizzle ORM queries"
      pattern: "from.*@/lib/db"
---

<objective>
Create the canonical stats service layer that provides a single source of truth for all accuracy calculations.

Purpose: Centralizes accuracy formula in one place so all pages/components get consistent numbers. This is the foundation that Plan 02 and 03 will build upon.

Output: New `src/lib/services/stats.ts` with typed functions using correct `tendencyPoints > 0` formula, and `src/lib/types/stats.ts` with shared interfaces.
</objective>

<execution_context>
@/Users/pieterbos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-stats-foundation/05-RESEARCH.md

# Current correct pattern to follow
@src/lib/db/queries/stats.ts

# Database schema for reference
@src/lib/db/schema.ts

# Existing services directory structure
@src/lib/services/points-calculator.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create stats types</name>
  <files>src/lib/types/stats.ts</files>
  <action>
Create `src/lib/types/stats.ts` with shared interfaces for stats calculations:

```typescript
/**
 * Stats types for accuracy calculations
 * Single source of truth for stats-related TypeScript interfaces
 */

export interface ModelAccuracyStats {
  modelId: string;
  accuracy: number;           // Tendency accuracy: (tendencyPoints > 0) / scored * 100
  exactAccuracy: number;      // Exact score accuracy: exactScoreBonus=3 / scored * 100
  scoredPredictions: number;  // Denominator: predictions with status='scored'
  totalPredictions: number;   // All predictions including pending
  correctTendencies: number;  // Numerator for accuracy: tendencyPoints > 0
  exactScores: number;        // Numerator for exact: exactScoreBonus = 3
}

export interface CompetitionModelStats {
  modelId: string;
  competitionId: string;
  competitionName: string;
  accuracy: number;
  exactAccuracy: number;
  scoredPredictions: number;
  correctTendencies: number;
  exactScores: number;
  avgPoints: number;
  totalPoints: number;
}
```

This establishes the contract for what stats calculations return.
  </action>
  <verify>File exists and exports both interfaces: `grep -l "ModelAccuracyStats" src/lib/types/stats.ts && grep -l "CompetitionModelStats" src/lib/types/stats.ts`</verify>
  <done>Types file exists with ModelAccuracyStats and CompetitionModelStats interfaces exported</done>
</task>

<task type="auto">
  <name>Task 2: Create stats service with canonical accuracy formula</name>
  <files>src/lib/services/stats.ts</files>
  <action>
Create `src/lib/services/stats.ts` as the single source of truth for accuracy calculations.

Key requirements:
1. Use `tendencyPoints > 0` (not IS NOT NULL) for counting correct predictions
2. Use `NULLIF(denominator, 0)` to prevent division by zero
3. Denominator must be scored predictions only (status = 'scored'), not total predictions
4. Export reusable SQL fragments for consistency

```typescript
/**
 * Stats Service - Single Source of Truth for Accuracy Calculations
 *
 * CANONICAL FORMULA:
 * accuracy = (predictions with tendencyPoints > 0) / (scored predictions) * 100
 *
 * Key rules:
 * - Denominator: ALWAYS scored predictions (status = 'scored')
 * - Numerator: tendencyPoints > 0 (not IS NOT NULL - that includes 0-point wrong predictions)
 * - Division protection: NULLIF(denominator, 0) + COALESCE(result, 0)
 */

import { eq, and, sql } from 'drizzle-orm';
import { getDb, predictions, models, matches, competitions } from '@/lib/db';
import type { ModelAccuracyStats, CompetitionModelStats } from '@/lib/types/stats';

// ============= REUSABLE SQL FRAGMENTS =============
// Use these in all stats queries for consistency

/** Count of predictions with correct tendency (tendencyPoints > 0) */
export const CORRECT_TENDENCIES_SQL = sql<number>`SUM(CASE WHEN ${predictions.tendencyPoints} > 0 THEN 1 ELSE 0 END)`;

/** Count of predictions with exact score (exactScoreBonus = 3) */
export const EXACT_SCORES_SQL = sql<number>`SUM(CASE WHEN ${predictions.exactScoreBonus} = 3 THEN 1 ELSE 0 END)`;

/** Count of scored predictions (denominator for accuracy) */
export const SCORED_PREDICTIONS_SQL = sql<number>`SUM(CASE WHEN ${predictions.status} = 'scored' THEN 1 ELSE 0 END)`;

/** Tendency accuracy percentage with division protection */
export const ACCURACY_SQL = sql<number>`COALESCE(
  ROUND(
    100.0 * SUM(CASE WHEN ${predictions.tendencyPoints} > 0 THEN 1 ELSE 0 END)
    / NULLIF(SUM(CASE WHEN ${predictions.status} = 'scored' THEN 1 ELSE 0 END), 0)::numeric,
    1
  ),
  0
)`;

/** Exact score accuracy percentage with division protection */
export const EXACT_ACCURACY_SQL = sql<number>`COALESCE(
  ROUND(
    100.0 * SUM(CASE WHEN ${predictions.exactScoreBonus} = 3 THEN 1 ELSE 0 END)
    / NULLIF(SUM(CASE WHEN ${predictions.status} = 'scored' THEN 1 ELSE 0 END), 0)::numeric,
    1
  ),
  0
)`;

// ============= SERVICE FUNCTIONS =============

/**
 * Get accuracy stats for a model - CANONICAL VERSION
 * All pages must use this function, not raw queries
 */
export async function getModelAccuracyStats(modelId: string): Promise<ModelAccuracyStats | null> {
  const db = getDb();

  const result = await db
    .select({
      modelId: models.id,
      totalPredictions: sql<number>`COUNT(${predictions.id})`,
      scoredPredictions: SCORED_PREDICTIONS_SQL,
      correctTendencies: CORRECT_TENDENCIES_SQL,
      exactScores: EXACT_SCORES_SQL,
      accuracy: ACCURACY_SQL,
      exactAccuracy: EXACT_ACCURACY_SQL,
    })
    .from(models)
    .leftJoin(predictions, eq(predictions.modelId, models.id))
    .where(eq(models.id, modelId))
    .groupBy(models.id);

  if (!result[0]) return null;

  return {
    modelId: result[0].modelId,
    accuracy: Number(result[0].accuracy),
    exactAccuracy: Number(result[0].exactAccuracy),
    scoredPredictions: Number(result[0].scoredPredictions) || 0,
    totalPredictions: Number(result[0].totalPredictions) || 0,
    correctTendencies: Number(result[0].correctTendencies) || 0,
    exactScores: Number(result[0].exactScores) || 0,
  };
}

/**
 * Get model stats for a specific competition - CANONICAL VERSION
 */
export async function getCompetitionModelStats(
  modelId: string,
  competitionId: string
): Promise<CompetitionModelStats | null> {
  const db = getDb();

  const result = await db
    .select({
      modelId: sql<string>`${modelId}`,
      competitionId: competitions.id,
      competitionName: competitions.name,
      totalPredictions: sql<number>`COUNT(${predictions.id})`,
      scoredPredictions: SCORED_PREDICTIONS_SQL,
      correctTendencies: CORRECT_TENDENCIES_SQL,
      exactScores: EXACT_SCORES_SQL,
      accuracy: ACCURACY_SQL,
      exactAccuracy: EXACT_ACCURACY_SQL,
      avgPoints: sql<number>`COALESCE(ROUND(AVG(${predictions.totalPoints})::numeric, 2), 0)`,
      totalPoints: sql<number>`COALESCE(SUM(${predictions.totalPoints}), 0)`,
    })
    .from(predictions)
    .innerJoin(matches, eq(predictions.matchId, matches.id))
    .innerJoin(competitions, eq(matches.competitionId, competitions.id))
    .where(
      and(
        eq(predictions.modelId, modelId),
        eq(matches.competitionId, competitionId),
        eq(predictions.status, 'scored')
      )
    )
    .groupBy(competitions.id, competitions.name);

  if (!result[0]) return null;

  return {
    modelId: result[0].modelId,
    competitionId: result[0].competitionId,
    competitionName: result[0].competitionName,
    accuracy: Number(result[0].accuracy),
    exactAccuracy: Number(result[0].exactAccuracy),
    scoredPredictions: Number(result[0].scoredPredictions) || 0,
    correctTendencies: Number(result[0].correctTendencies) || 0,
    exactScores: Number(result[0].exactScores) || 0,
    avgPoints: Number(result[0].avgPoints),
    totalPoints: Number(result[0].totalPoints),
  };
}
```

Ensure the file:
- Imports from existing `@/lib/db` module
- Exports SQL fragments for reuse in other queries
- Uses COALESCE + NULLIF pattern consistently
- Returns properly typed results
  </action>
  <verify>
Run TypeScript check: `npx tsc --noEmit src/lib/services/stats.ts 2>&1 | head -20`
Verify exports: `grep -E "^export" src/lib/services/stats.ts | wc -l` should be >= 6
  </verify>
  <done>Stats service exists with getModelAccuracyStats, getCompetitionModelStats, and SQL fragments exported. TypeScript compiles without errors.</done>
</task>

</tasks>

<verification>
1. `src/lib/types/stats.ts` exists with ModelAccuracyStats and CompetitionModelStats interfaces
2. `src/lib/services/stats.ts` exists with:
   - ACCURACY_SQL using `tendencyPoints > 0` (not IS NOT NULL)
   - NULLIF() protection on all divisions
   - SCORED_PREDICTIONS_SQL using `status = 'scored'`
   - getModelAccuracyStats and getCompetitionModelStats functions
3. TypeScript compilation succeeds: `npx tsc --noEmit`
</verification>

<success_criteria>
- Stats service layer created as single source of truth
- Correct formula (`tendencyPoints > 0`) in ACCURACY_SQL
- Division protected with NULLIF()
- Types exported for consumers
- Ready for Plan 02 and 03 to consume
</success_criteria>

<output>
After completion, create `.planning/phases/05-stats-foundation/05-01-SUMMARY.md`
</output>
