---
phase: 51-retroactive-backfill-script
plan: 02
type: execute
wave: 2
depends_on: ["51-01"]
files_modified:
  - scripts/backfill-retroactive-predictions.ts
autonomous: true

must_haves:
  truths:
    - "Script identifies all matches from last 7 days where predictions count is less than 42"
    - "Matches missing analysis get analysis queued and completed before predictions"
    - "All 42 LLMs generate predictions for gap matches using pre-match context"
    - "Finished match predictions are scored immediately after prediction generation"
    - "Live/upcoming match predictions are stored for scoring when match finishes"
    - "Running script twice against same matches produces no duplicate predictions"
  artifacts:
    - path: "scripts/backfill-retroactive-predictions.ts"
      provides: "Complete retroactive backfill script"
      min_lines: 200
  key_links:
    - from: "scripts/backfill-retroactive-predictions.ts"
      to: "src/lib/queue/index.ts"
      via: "Queue imports for analysis, predictions, settlement"
      pattern: "analysisQueue|predictionsQueue|settlementQueue"
    - from: "scripts/backfill-retroactive-predictions.ts"
      to: "src/lib/db/queries.ts"
      via: "Database queries for gap detection"
      pattern: "getDb|getMatchAnalysisByMatchId"
    - from: "scripts/backfill-retroactive-predictions.ts"
      to: "src/lib/queue/types.ts"
      via: "allowRetroactive flag in job payloads"
      pattern: "allowRetroactive.*true"
---

<objective>
Create the one-shot retroactive backfill script that identifies matches missing predictions from the last N days, queues analysis/prediction/scoring jobs via BullMQ, and waits for completion.

Purpose: After pipeline failures (server restarts, API issues, worker crashes), matches from the last 7 days may have fewer than 42 predictions. This script retroactively generates predictions using pre-match context (via API-Football historical data) and immediately scores finished matches.

Output: A runnable script at `scripts/backfill-retroactive-predictions.ts` executable via `npx tsx scripts/backfill-retroactive-predictions.ts [--days N]`
</objective>

<execution_context>
@/Users/pieterbos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/51-retroactive-backfill-script/51-RESEARCH.md
@.planning/phases/51-retroactive-backfill-script/51-01-SUMMARY.md
@scripts/backfill-settlement.ts
@src/lib/queue/index.ts
@src/lib/queue/types.ts
@src/lib/db/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create retroactive backfill script with gap detection and job orchestration</name>
  <files>scripts/backfill-retroactive-predictions.ts</files>
  <action>
Create `scripts/backfill-retroactive-predictions.ts` following the established pattern from `scripts/backfill-settlement.ts`. The script has four key sections:

**1. Gap Detection Query** (`findMatchesMissingPredictions`):
- Query matches from last N days (default 7) using Drizzle ORM
- LEFT JOIN `matches` with `match_analysis` and `predictions`
- GROUP BY match, COUNT predictions, HAVING count < 42
- Filter: `kickoffTime >= cutoff`, `externalId IS NOT NULL` (required for API-Football)
- Filter OUT cancelled/postponed matches: `status IN ('scheduled', 'live', 'finished')`
- Return: matchId, status, kickoffTime, predictionCount, hasAnalysis (boolean from match_analysis.id IS NOT NULL), homeScore, awayScore, externalId, homeTeam, awayTeam
- NOTE: The hasAnalysis check should use `matchAnalysis.favoriteTeamName IS NOT NULL` (from Phase 50 - favoriteTeamName is the reliable indicator that analysis was actually fetched, not just that a row exists)

**2. Job Queueing Functions**:

`generateRetroactiveAnalysis(matchId, externalId, homeTeam, awayTeam)`:
- Check for existing job with ID `analyze-retro-{matchId}` via `analysisQueue.getJob(jobId)`
- If exists in `failed`/`completed` state, remove it first
- If exists in `delayed`/`waiting`/`active` state, skip (already processing)
- Queue analysis job: `analysisQueue.add(JOB_TYPES.ANALYZE_MATCH, { matchId, externalId, homeTeam, awayTeam, allowRetroactive: true }, { jobId, delay: 1000, priority: 3, attempts: 5, backoff: { type: 'exponential', delay: 30000 } })`

`generateRetroactivePredictions(matchId)`:
- Same idempotent pattern with job ID `predict-retro-{matchId}`
- Queue prediction job: `predictionsQueue.add(JOB_TYPES.PREDICT_MATCH, { matchId, attempt: 1 as const, skipIfDone: true, allowRetroactive: true }, { jobId, delay: 1000, priority: 3, attempts: 5, backoff: { type: 'exponential', delay: 30000 } })`

`scoreFinishedMatch(matchId, homeScore, awayScore, status)`:
- Same idempotent pattern with job ID `settle-retro-{matchId}`
- Queue settlement job: `settlementQueue.add(JOB_TYPES.SETTLE_MATCH, { matchId, homeScore, awayScore, status }, { jobId, delay: 1000, priority: 2, attempts: 3, backoff: { type: 'exponential', delay: 10000 } })`

**3. Wait for Job Completion** (`waitForJobCompletion`):
- Poll `queue.getJob(jobId)` every 2 seconds
- Return on `completed` state
- Throw on `failed` state with `job.failedReason`
- Throw on timeout (default 120s for analysis, 300s for predictions, 60s for settlement)
- If job not found, throw error

**4. Main Orchestration** (`main`):
- Parse `--days` CLI arg (default 7), validate positive integer
- Call `findMatchesMissingPredictions(days)`
- Print summary: total gaps found, breakdown by status (finished/live/scheduled)
- If zero gaps, print success and exit
- Process gaps SEQUENTIALLY (not parallel) to respect API-Football rate limits. Use a simple for-loop, NOT Promise.all with p-limit. Sequential is safer for a one-shot script and avoids race conditions in analysis/prediction ordering.
- For each gap:
  1. If `!hasAnalysis`: queue analysis, wait for completion (120s timeout)
  2. Queue predictions, wait for completion (300s timeout)
  3. If `status === 'finished' && homeScore !== null && awayScore !== null`: queue scoring, wait for completion (60s timeout)
- Track stats: matchesFound, analysisQueued, predictionsQueued, scoringQueued, errors[]
- Print summary report with all stats
- Call `closeQueueConnection()` in finally block
- Exit with code 0 on success, 1 on fatal error

**Important implementation details:**
- Import `dotenv/config` at top (script runs outside Next.js)
- Use `import { getDb } from '@/lib/db'` for database access
- Import queue exports from `@/lib/queue`: `analysisQueue, predictionsQueue, settlementQueue, JOB_TYPES, closeQueueConnection`
- Import schema from `@/lib/db/schema`: `matches, matchAnalysis, predictions`
- Import Drizzle operators: `eq, and, gte, isNotNull, sql, inArray` from `drizzle-orm`
- Use `console.log` for output (not pino logger - this is a one-shot script)
- Handle errors per-match (continue processing other matches on individual failures)
- The script should work identically whether run from local dev or production (uses same DB/Redis via env vars)
  </action>
  <verify>
1. Verify TypeScript compiles: `npx tsc --noEmit scripts/backfill-retroactive-predictions.ts` (or run through tsx dry-run)
2. Run `npx tsx scripts/backfill-retroactive-predictions.ts --days 0` to verify it handles edge cases gracefully (0 days = no matches = clean exit)
3. Grep the script for key patterns:
   - `allowRetroactive: true` appears in both analysis and prediction job payloads
   - `analyze-retro-` and `predict-retro-` and `settle-retro-` job ID prefixes present
   - `closeQueueConnection()` called in finally block
   - Sequential processing (no Promise.all or p-limit)
   - Status filter excludes cancelled/postponed
  </verify>
  <done>
Script at `scripts/backfill-retroactive-predictions.ts` is runnable via `npx tsx scripts/backfill-retroactive-predictions.ts [--days N]`. It:
1. Finds matches with < 42 predictions from last N days (RETRO-01)
2. Queues retroactive analysis for matches missing it (RETRO-02)
3. Queues predictions with allowRetroactive flag for all gap matches (RETRO-03)
4. Queues scoring for finished matches immediately after predictions complete (RETRO-04)
5. Stores live/scheduled predictions for future scoring (RETRO-05)
6. Uses deterministic job IDs and stale job cleanup for idempotency (RETRO-06)
  </done>
</task>

</tasks>

<verification>
1. Script compiles without TypeScript errors
2. Script handles `--days 0` gracefully (no matches, clean exit)
3. Script handles `--days 1` or `--days 7` and reports gap count
4. All 6 RETRO requirements addressed:
   - RETRO-01: Gap detection query with COUNT < 42
   - RETRO-02: Analysis queue with allowRetroactive: true
   - RETRO-03: Predictions queue with allowRetroactive: true and all 42 models
   - RETRO-04: Settlement queue for finished matches after predictions complete
   - RETRO-05: Non-finished matches skip scoring (stored for future)
   - RETRO-06: Deterministic job IDs + stale job removal = idempotent
5. `grep -c "allowRetroactive" scripts/backfill-retroactive-predictions.ts` shows at least 2 occurrences
6. `grep "closeQueueConnection" scripts/backfill-retroactive-predictions.ts` confirms cleanup
</verification>

<success_criteria>
- `npx tsx scripts/backfill-retroactive-predictions.ts --days 7` runs without crashing
- Script prints gap detection results with per-status breakdown
- Finished matches get analysis -> predictions -> scoring pipeline
- Live/scheduled matches get analysis -> predictions only
- Running script twice with same --days value queues no duplicate jobs (idempotent)
- All 6 RETRO requirements have corresponding implementation in the script
</success_criteria>

<output>
After completion, create `.planning/phases/51-retroactive-backfill-script/51-02-SUMMARY.md`
</output>
