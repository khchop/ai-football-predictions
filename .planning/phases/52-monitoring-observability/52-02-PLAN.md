---
phase: 52-monitoring-observability
plan: 02
type: execute
wave: 2
depends_on: ["52-01"]
files_modified:
  - src/app/api/health/route.ts
  - src/lib/queue/workers/backfill.worker.ts
  - src/lib/logger/metrics.ts
autonomous: true

must_haves:
  truths:
    - "GET /api/health returns matchCoverage percentage alongside existing status and timestamp"
    - "Health endpoint caches coverage result for 60 seconds to avoid expensive queries on frequent polling"
    - "Backfill worker logs ERROR when matches are within 2h of kickoff with no analysis/predictions jobs"
    - "Backfill worker logs INFO summary of pipeline coverage on each periodic run"
    - "Queue metrics include matchesWithoutPredictions count alongside existing queue stats"
  artifacts:
    - path: "src/app/api/health/route.ts"
      provides: "Enhanced health endpoint with match coverage (MON-01)"
      exports: ["GET"]
    - path: "src/lib/queue/workers/backfill.worker.ts"
      provides: "Pipeline health alert logging integrated into backfill cycle (MON-03)"
    - path: "src/lib/logger/metrics.ts"
      provides: "Extended collectQueueMetrics with matchesWithoutPredictions count (MON-04)"
      exports: ["collectQueueMetrics", "logQueueMetrics"]
  key_links:
    - from: "src/app/api/health/route.ts"
      to: "src/lib/monitoring/pipeline-coverage.ts"
      via: "getMatchCoverage import"
      pattern: "getMatchCoverage"
    - from: "src/app/api/health/route.ts"
      to: "src/lib/queue/index.ts"
      via: "isQueueConnectionHealthy import"
      pattern: "isQueueConnectionHealthy"
    - from: "src/lib/queue/workers/backfill.worker.ts"
      to: "src/lib/monitoring/pipeline-coverage.ts"
      via: "getMatchCoverage + classifyGapsBySeverity imports"
      pattern: "getMatchCoverage|classifyGapsBySeverity"
    - from: "src/lib/logger/metrics.ts"
      to: "src/lib/monitoring/pipeline-coverage.ts"
      via: "getMatchCoverage import for matchesWithoutPredictions"
      pattern: "getMatchCoverage"
---

<objective>
Enhance the health endpoint with match coverage metrics, integrate pipeline health alerts into the backfill worker, and extend queue metrics with "matches without predictions" count.

Purpose: Implements MON-01 (health endpoint coverage), MON-03 (critical gap alerts), and MON-04 (queue metrics extension). These are the passive/automated monitoring components that run without admin interaction.

Output: Enhanced `/api/health` with coverage %, backfill worker with alert logging, extended queue metrics.
</objective>

<execution_context>
@/Users/pieterbos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/52-monitoring-observability/52-RESEARCH.md
@.planning/phases/52-monitoring-observability/52-01-SUMMARY.md

Key codebase files to modify:
@src/app/api/health/route.ts (current: 9 lines, minimal health check)
@src/lib/queue/workers/backfill.worker.ts (447 lines, backfill cycle with 6 steps)
@src/lib/logger/metrics.ts (99 lines, collectQueueMetrics + logQueueMetrics + periodic logging)
@src/lib/queue/index.ts (isQueueConnectionHealthy on line 105)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance health endpoint with match coverage (MON-01)</name>
  <files>src/app/api/health/route.ts</files>
  <action>
Replace the current minimal health endpoint with an enhanced version that includes match coverage percentage.

**Current code** (src/app/api/health/route.ts, all 9 lines):
```typescript
import { NextResponse } from 'next/server';
export async function GET() {
  return NextResponse.json({ status: 'ok', timestamp: new Date().toISOString(), version: '1.0.0' });
}
```

**New implementation:**

Imports:
- `NextResponse` from `next/server`
- `getMatchCoverage` from `@/lib/monitoring/pipeline-coverage`
- `isQueueConnectionHealthy` from `@/lib/queue`

Add a module-level cache variable:
```typescript
let cachedCoverage: { percentage: number; totalMatches: number; coveredMatches: number; gaps: number; timestamp: number } | null = null;
const CACHE_TTL_MS = 60_000; // 60 seconds
```

In the GET handler:
1. Check Redis health: `const redisHealthy = isQueueConnectionHealthy()`
2. Get cached or fresh coverage:
   ```typescript
   const now = Date.now();
   if (!cachedCoverage || now - cachedCoverage.timestamp > CACHE_TTL_MS) {
     try {
       const coverage = await getMatchCoverage(6); // Next 6 hours
       cachedCoverage = {
         percentage: Math.round(coverage.percentage * 10) / 10,
         totalMatches: coverage.totalMatches,
         coveredMatches: coverage.coveredMatches,
         gaps: coverage.gaps.length,
         timestamp: now,
       };
     } catch {
       // If coverage check fails, don't crash health endpoint
       // Return stale cache or null
     }
   }
   ```
3. Determine overall health status:
   - `'ok'` if Redis healthy AND (no coverage data OR coverage >= 90%)
   - `'degraded'` if Redis healthy but coverage < 90%
   - `'unhealthy'` if Redis not healthy
4. Return response:
   ```typescript
   const status = !redisHealthy ? 'unhealthy'
     : (cachedCoverage && cachedCoverage.percentage < 90) ? 'degraded'
     : 'ok';

   return NextResponse.json({
     status,
     timestamp: new Date().toISOString(),
     version: '1.0.0',
     checks: {
       redis: redisHealthy ? 'healthy' : 'unhealthy',
       matchCoverage: cachedCoverage ? {
         percentage: cachedCoverage.percentage,
         totalMatches: cachedCoverage.totalMatches,
         coveredMatches: cachedCoverage.coveredMatches,
         gaps: cachedCoverage.gaps,
       } : null,
     },
   }, {
     status: status === 'unhealthy' ? 503 : 200,
   });
   ```

IMPORTANT: Health endpoint has NO auth requirement (load balancers and uptime monitors need unauthenticated access). Do NOT add admin auth. The coverage data returned is aggregate only (percentage, counts) - no match details are exposed.

IMPORTANT: Do NOT import `connection` from `next/server` (the PPR signal). The health endpoint should work in all contexts, and getMatchCoverage already handles DB access without it.
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. `curl http://localhost:3000/api/health` returns JSON with `status`, `timestamp`, `version`, and `checks.matchCoverage` fields
3. Two rapid requests return same coverage data (caching works)
  </verify>
  <done>
Health endpoint returns `{ status, timestamp, version, checks: { redis, matchCoverage: { percentage, totalMatches, coveredMatches, gaps } } }`. Coverage is cached for 60s. HTTP 503 when Redis unhealthy, 200 otherwise.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add pipeline health alerts to backfill worker (MON-03) and extend queue metrics (MON-04)</name>
  <files>
    src/lib/queue/workers/backfill.worker.ts
    src/lib/logger/metrics.ts
  </files>
  <action>
**Part A: Backfill worker pipeline health check (MON-03)**

In `src/lib/queue/workers/backfill.worker.ts`, add a pipeline health check as step 7 (after the existing step 6 "zero-prediction matches"). This runs at the END of every backfill cycle.

Add imports at the top of the file:
```typescript
import { getMatchCoverage, classifyGapsBySeverity } from '@/lib/monitoring/pipeline-coverage';
```

After the step 6 block (after line ~406, the zero-prediction for-loop), add step 7:

```typescript
// 7. Pipeline health check - alert on matches approaching kickoff without jobs (MON-03)
try {
  const coverage = await getMatchCoverage(6); // Check next 6 hours
  const { critical, warning } = classifyGapsBySeverity(coverage.gaps);

  // Log coverage summary at INFO level
  log.info({
    coveragePercentage: Math.round(coverage.percentage * 10) / 10,
    totalMatches: coverage.totalMatches,
    coveredMatches: coverage.coveredMatches,
    totalGaps: coverage.gaps.length,
    criticalGaps: critical.length,
    warningGaps: warning.length,
  }, 'Pipeline coverage check');

  // Alert on critical gaps (< 2h to kickoff) at ERROR level
  if (critical.length > 0) {
    log.error({
      criticalGaps: critical.map(g => ({
        matchId: g.matchId,
        match: `${g.homeTeam} vs ${g.awayTeam}`,
        kickoffTime: g.kickoffTime,
        hoursUntilKickoff: g.hoursUntilKickoff,
        missingJobs: g.missingJobs,
      })),
    }, `CRITICAL: ${critical.length} match(es) within 2h of kickoff without scheduled jobs`);
  }

  // Log warnings (2-4h) at WARN level
  if (warning.length > 0) {
    log.warn({
      warningGaps: warning.map(g => ({
        matchId: g.matchId,
        match: `${g.homeTeam} vs ${g.awayTeam}`,
        hoursUntilKickoff: g.hoursUntilKickoff,
        missingJobs: g.missingJobs,
      })),
    }, `WARNING: ${warning.length} match(es) within 2-4h of kickoff without scheduled jobs`);
  }
} catch (healthError: any) {
  log.warn({ err: healthError }, 'Pipeline health check failed (non-critical)');
}
```

This is wrapped in its own try/catch so a health check failure never blocks the actual backfill work.

**Part B: Extend queue metrics with matchesWithoutPredictions (MON-04)**

In `src/lib/logger/metrics.ts`, extend `logQueueMetrics()` to include a "matches without predictions" count.

Add import at the top:
```typescript
import { getMatchCoverage } from '@/lib/monitoring/pipeline-coverage';
```

In the `logQueueMetrics()` function (after the existing `metricsLogger.info()` call at line ~74), add:

```typescript
// Pipeline coverage metrics (MON-04)
try {
  const coverage = await getMatchCoverage(6);
  metricsLogger.info({
    matchCoverage: {
      percentage: Math.round(coverage.percentage * 10) / 10,
      totalMatches: coverage.totalMatches,
      matchesWithoutPredictions: coverage.gaps.length,
    },
  }, 'Pipeline coverage metrics');
} catch (coverageError) {
  metricsLogger.debug(
    { error: coverageError instanceof Error ? coverageError.message : String(coverageError) },
    'Failed to collect pipeline coverage metrics'
  );
}
```

Use `debug` level for the error case since periodic metrics logging failure is not critical. The coverage data will also be logged by the backfill worker's health check.
  </action>
  <verify>
1. `npx tsc --noEmit` passes (no type errors in modified files)
2. Check backfill worker compiles: no import resolution errors for pipeline-coverage module
3. Check metrics.ts compiles: getMatchCoverage import resolves
4. Review that the health check is AFTER step 6 and inside its own try/catch
  </verify>
  <done>
Backfill worker logs pipeline coverage at INFO level and critical gaps at ERROR level on every hourly cycle (MON-03). Queue metrics include matchesWithoutPredictions count in periodic 5-minute logging (MON-04). Both use the shared getMatchCoverage() function from Plan 01.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes for all modified files
2. Health endpoint returns match coverage data: `curl http://localhost:3000/api/health | jq .checks.matchCoverage`
3. Health endpoint caches for 60s (two rapid curls return same timestamp in cache)
4. Backfill worker has step 7 with pipeline health check (grep for "Pipeline coverage check" in backfill.worker.ts)
5. Metrics.ts logs matchesWithoutPredictions (grep for "matchesWithoutPredictions" in metrics.ts)
6. Build passes: `npm run build` or `npx next build --webpack`
</verification>

<success_criteria>
- MON-01: /api/health shows match coverage percentage, total matches, covered count, and gap count
- MON-03: Server logs contain ERROR-level alerts for matches within 2h of kickoff with no jobs
- MON-04: Queue metrics include "matchesWithoutPredictions" count in periodic logging
- Health endpoint remains unauthenticated (accessible to load balancers)
- Coverage data is cached for 60s in health endpoint (no DB/Redis spam)
- Backfill health check failure never blocks actual backfill work (isolated try/catch)
</success_criteria>

<output>
After completion, create `.planning/phases/52-monitoring-observability/52-02-SUMMARY.md`
</output>
