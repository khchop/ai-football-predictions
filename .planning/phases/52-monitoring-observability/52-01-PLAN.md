---
phase: 52-monitoring-observability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/monitoring/pipeline-coverage.ts
  - src/lib/monitoring/types.ts
autonomous: true

must_haves:
  truths:
    - "getMatchCoverage(hoursAhead) returns coverage percentage, total matches, covered count, and gap details"
    - "Each gap includes matchId, homeTeam, awayTeam, kickoffTime, hoursUntilKickoff, and which jobs are missing"
    - "Coverage is calculated by comparing upcoming scheduled matches against delayed/waiting/active BullMQ jobs"
    - "When no upcoming matches exist, coverage returns 100% with zero totals"
  artifacts:
    - path: "src/lib/monitoring/pipeline-coverage.ts"
      provides: "getMatchCoverage() function - core coverage calculation logic"
      exports: ["getMatchCoverage"]
    - path: "src/lib/monitoring/types.ts"
      provides: "MatchCoverageResult, MatchGap, PipelineHealthSummary interfaces"
      exports: ["MatchCoverageResult", "MatchGap", "PipelineHealthSummary"]
  key_links:
    - from: "src/lib/monitoring/pipeline-coverage.ts"
      to: "src/lib/db/queries.ts"
      via: "getDb() and matches table import"
      pattern: "getDb\\(\\)|from\\(matches\\)"
    - from: "src/lib/monitoring/pipeline-coverage.ts"
      to: "src/lib/queue/index.ts"
      via: "getAnalysisQueue, getPredictionsQueue imports"
      pattern: "getAnalysisQueue|getPredictionsQueue"
---

<objective>
Create the core pipeline coverage calculation module that determines what percentage of upcoming matches have scheduled analysis and prediction jobs in BullMQ.

Purpose: This module is the shared foundation for the health endpoint (Plan 02) and admin dashboard (Plan 03). Separating it allows both consumers to reuse the same calculation logic.

Output: `src/lib/monitoring/pipeline-coverage.ts` with `getMatchCoverage()` function, and `src/lib/monitoring/types.ts` with shared interfaces.
</objective>

<execution_context>
@/Users/pieterbos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/52-monitoring-observability/52-RESEARCH.md

Key codebase files to reference:
@src/lib/db/queries.ts (lines 1-10 for imports, lines 129-150 for getUpcomingMatches pattern)
@src/lib/queue/index.ts (lines 266-289 for getAnalysisQueue/getPredictionsQueue)
@src/lib/db/schema.ts (lines 22-47 for matches table schema with kickoffTime, status, homeTeam, awayTeam)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create monitoring types</name>
  <files>src/lib/monitoring/types.ts</files>
  <action>
Create `src/lib/monitoring/types.ts` with the following interfaces:

```typescript
export interface MatchGap {
  matchId: string;
  homeTeam: string;
  awayTeam: string;
  kickoffTime: string;
  hoursUntilKickoff: number;
  missingJobs: ('analysis' | 'predictions')[];
}

export interface MatchCoverageResult {
  percentage: number;       // 0-100, coverage of upcoming matches with jobs
  totalMatches: number;     // Total scheduled matches in time window
  coveredMatches: number;   // Matches with both analysis AND predictions jobs
  gaps: MatchGap[];         // Matches missing one or both job types
}

export interface PipelineHealthSummary {
  timestamp: string;
  coverage: MatchCoverageResult;
  gapsBySeverity: {
    critical: MatchGap[];   // < 2h to kickoff
    warning: MatchGap[];    // 2-4h to kickoff
    info: MatchGap[];       // 4-6h to kickoff
  };
}
```

No external dependencies. Pure type definitions.
  </action>
  <verify>Run `npx tsc --noEmit src/lib/monitoring/types.ts` or verify the file compiles by checking for TypeScript errors.</verify>
  <done>Types file exists with MatchGap, MatchCoverageResult, and PipelineHealthSummary interfaces exported.</done>
</task>

<task type="auto">
  <name>Task 2: Create pipeline coverage calculation</name>
  <files>src/lib/monitoring/pipeline-coverage.ts</files>
  <action>
Create `src/lib/monitoring/pipeline-coverage.ts` with the `getMatchCoverage()` function.

**Imports** (follow existing patterns from `src/lib/db/queries.ts` lines 1-10):
- `getDb`, `matches` from `@/lib/db/index`
- `and`, `gte`, `lte`, `eq` from `drizzle-orm`
- `getAnalysisQueue`, `getPredictionsQueue` from `@/lib/queue/index`
- `MatchCoverageResult`, `MatchGap` from `./types`
- `loggers` from `@/lib/logger/modules`

**Function: `getMatchCoverage(hoursAhead: number = 6): Promise<MatchCoverageResult>`**

Implementation steps:
1. Create a child logger: `loggers.api.child({ module: 'pipeline-coverage' })`
2. Calculate time window: `now` to `now + hoursAhead hours`
3. Query upcoming scheduled matches using Drizzle:
   ```typescript
   const db = getDb();
   const upcomingMatches = await db
     .select({
       id: matches.id,
       homeTeam: matches.homeTeam,
       awayTeam: matches.awayTeam,
       kickoffTime: matches.kickoffTime,
     })
     .from(matches)
     .where(
       and(
         eq(matches.status, 'scheduled'),
         gte(matches.kickoffTime, now.toISOString()),
         lte(matches.kickoffTime, future.toISOString())
       )
     );
   ```
   NOTE: Use `eq(matches.status, 'scheduled')` - only scheduled matches need pre-match jobs. Live/finished matches don't need new jobs.
   NOTE: Do NOT call `connection()` from `next/server` - this function runs in worker context too (backfill worker), not just API routes.

4. Early return if no upcoming matches: `{ percentage: 100, totalMatches: 0, coveredMatches: 0, gaps: [] }`

5. Get delayed/waiting/active jobs from both queues:
   ```typescript
   const [analysisJobs, predictionJobs] = await Promise.all([
     getAnalysisQueue().getJobs(['delayed', 'waiting', 'active'], 0, 1000),
     getPredictionsQueue().getJobs(['delayed', 'waiting', 'active'], 0, 1000),
   ]);
   ```

6. Build Set of matchIds with scheduled jobs (O(1) lookup):
   ```typescript
   const analysisMatchIds = new Set(
     analysisJobs.map(j => j.data?.matchId).filter(Boolean)
   );
   const predictionMatchIds = new Set(
     predictionJobs.map(j => j.data?.matchId).filter(Boolean)
   );
   ```

7. Identify gaps - matches WITHOUT both analysis AND prediction jobs:
   ```typescript
   const gaps: MatchGap[] = upcomingMatches
     .filter(m => !analysisMatchIds.has(m.id) || !predictionMatchIds.has(m.id))
     .map(m => {
       const kickoff = new Date(m.kickoffTime);
       const hoursUntilKickoff = (kickoff.getTime() - now.getTime()) / (3600000);
       const missingJobs: ('analysis' | 'predictions')[] = [];
       if (!analysisMatchIds.has(m.id)) missingJobs.push('analysis');
       if (!predictionMatchIds.has(m.id)) missingJobs.push('predictions');
       return {
         matchId: m.id,
         homeTeam: m.homeTeam,
         awayTeam: m.awayTeam,
         kickoffTime: m.kickoffTime,
         hoursUntilKickoff: Math.round(hoursUntilKickoff * 10) / 10,
         missingJobs,
       };
     })
     .sort((a, b) => a.hoursUntilKickoff - b.hoursUntilKickoff);
   ```
   Sort gaps by urgency (closest to kickoff first).

8. Calculate coverage:
   ```typescript
   const coveredMatches = upcomingMatches.length - gaps.length;
   const percentage = upcomingMatches.length > 0
     ? (coveredMatches / upcomingMatches.length) * 100
     : 100;
   ```

9. Log at debug level: `log.debug({ totalMatches, coveredMatches, gaps: gaps.length }, 'Pipeline coverage calculated')`

10. Return `{ percentage, totalMatches: upcomingMatches.length, coveredMatches, gaps }`

**Also export a helper: `classifyGapsBySeverity(gaps: MatchGap[])`**

```typescript
export function classifyGapsBySeverity(gaps: MatchGap[]) {
  return {
    critical: gaps.filter(g => g.hoursUntilKickoff < 2),
    warning: gaps.filter(g => g.hoursUntilKickoff >= 2 && g.hoursUntilKickoff < 4),
    info: gaps.filter(g => g.hoursUntilKickoff >= 4),
  };
}
```

**Error handling:** Wrap the entire function body in try/catch. On error, log at error level with the error details and re-throw. This lets callers (health endpoint, admin endpoint) decide their own error response strategy.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no type errors. Specifically check:
- Drizzle imports resolve correctly
- Queue imports resolve correctly
- MatchCoverageResult type matches return shape
- No unused imports or variables
  </verify>
  <done>
`src/lib/monitoring/pipeline-coverage.ts` exports `getMatchCoverage()` and `classifyGapsBySeverity()`. The function queries upcoming scheduled matches, compares against BullMQ job matchIds, and returns coverage percentage with gap details. No type errors.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` completes without errors
2. `src/lib/monitoring/types.ts` exports MatchGap, MatchCoverageResult, PipelineHealthSummary
3. `src/lib/monitoring/pipeline-coverage.ts` exports getMatchCoverage, classifyGapsBySeverity
4. getMatchCoverage returns MatchCoverageResult shape
5. No circular dependency issues (monitoring imports from db and queue, nothing imports back)
</verification>

<success_criteria>
- Core coverage calculation module exists with proper types
- Function queries both DB (matches) and Redis (BullMQ jobs)
- Gap detection identifies matches missing analysis OR predictions jobs
- Gaps sorted by urgency (closest kickoff first)
- Empty match window returns 100% coverage (no false alerts)
- classifyGapsBySeverity helper splits gaps into critical/warning/info buckets
</success_criteria>

<output>
After completion, create `.planning/phases/52-monitoring-observability/52-01-SUMMARY.md`
</output>
