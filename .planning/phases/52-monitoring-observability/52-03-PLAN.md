---
phase: 52-monitoring-observability
plan: 03
type: execute
wave: 2
depends_on: ["52-01"]
files_modified:
  - src/app/api/admin/pipeline-health/route.ts
  - src/app/api/admin/settlement-failures/route.ts
autonomous: true

must_haves:
  truths:
    - "GET /api/admin/pipeline-health returns matches within 6h of kickoff with no scheduled jobs, classified by severity"
    - "GET /api/admin/settlement-failures returns failed settlement jobs from both queue and DLQ with error reasons"
    - "Both endpoints require admin authentication (X-Admin-Password header)"
    - "Both endpoints are rate-limited using RATE_LIMIT_PRESETS.admin (10 req/min)"
    - "Settlement failures endpoint includes retry controls (POST for retry)"
  artifacts:
    - path: "src/app/api/admin/pipeline-health/route.ts"
      provides: "Admin pipeline health endpoint with gap detection (MON-02)"
      exports: ["GET"]
    - path: "src/app/api/admin/settlement-failures/route.ts"
      provides: "Admin settlement failures dashboard endpoint (MON-05)"
      exports: ["GET", "POST"]
  key_links:
    - from: "src/app/api/admin/pipeline-health/route.ts"
      to: "src/lib/monitoring/pipeline-coverage.ts"
      via: "getMatchCoverage + classifyGapsBySeverity imports"
      pattern: "getMatchCoverage|classifyGapsBySeverity"
    - from: "src/app/api/admin/settlement-failures/route.ts"
      to: "src/lib/queue/index.ts"
      via: "getSettlementQueue import"
      pattern: "getSettlementQueue"
    - from: "src/app/api/admin/settlement-failures/route.ts"
      to: "src/lib/queue/dead-letter.ts"
      via: "getDeadLetterJobs import for DLQ entries"
      pattern: "getDeadLetterJobs"
---

<objective>
Create two admin dashboard API endpoints: one for pipeline health gap detection showing matches approaching kickoff without jobs, and one for settlement failure investigation with retry controls.

Purpose: Implements MON-02 (admin gap detection dashboard) and MON-05 (settlement failure dashboard). These are active monitoring tools for admin investigation.

Output: `/api/admin/pipeline-health` (GET) and `/api/admin/settlement-failures` (GET + POST).
</objective>

<execution_context>
@/Users/pieterbos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/52-monitoring-observability/52-RESEARCH.md
@.planning/phases/52-monitoring-observability/52-01-SUMMARY.md

Key codebase files to reference (for auth/rate-limit pattern):
@src/app/api/admin/settlement/retry/route.ts (exact pattern to follow for admin auth + rate limiting)
@src/app/api/admin/queue-status/route.ts (another admin endpoint pattern)
@src/app/api/admin/dlq/route.ts (DLQ endpoint pattern)
@src/lib/queue/dead-letter.ts (getDeadLetterJobs, DLQEntry interface)
@src/lib/queue/index.ts (getSettlementQueue, JOB_TYPES)
@src/lib/utils/admin-auth.ts (requireAdminAuth)
@src/lib/utils/rate-limiter.ts (checkRateLimit, getRateLimitKey, createRateLimitHeaders, RATE_LIMIT_PRESETS)
@src/lib/utils/error-sanitizer.ts (sanitizeError)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pipeline health admin endpoint (MON-02)</name>
  <files>src/app/api/admin/pipeline-health/route.ts</files>
  <action>
Create `src/app/api/admin/pipeline-health/route.ts` following the exact admin endpoint pattern from `src/app/api/admin/settlement/retry/route.ts`.

**Imports:**
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { requireAdminAuth } from '@/lib/utils/admin-auth';
import { checkRateLimit, getRateLimitKey, createRateLimitHeaders, RATE_LIMIT_PRESETS } from '@/lib/utils/rate-limiter';
import { sanitizeError } from '@/lib/utils/error-sanitizer';
import { getMatchCoverage, classifyGapsBySeverity } from '@/lib/monitoring/pipeline-coverage';
```

**GET handler implementation:**

Follow the EXACT pattern from settlement/retry/route.ts (rate limit first, then auth):

1. Rate limit check:
   ```typescript
   const rateLimitKey = getRateLimitKey(req);
   const rateLimitResult = await checkRateLimit(`admin:pipeline-health:${rateLimitKey}`, RATE_LIMIT_PRESETS.admin);
   ```
   If not allowed, return 429 with retryAfter (same pattern as settlement/retry).

2. Admin auth:
   ```typescript
   const authError = requireAdminAuth(req);
   if (authError) return authError;
   ```

3. Get coverage data:
   ```typescript
   const coverage = await getMatchCoverage(6); // 6-hour window for early warning
   const severity = classifyGapsBySeverity(coverage.gaps);
   ```

4. Return response:
   ```typescript
   return NextResponse.json({
     timestamp: new Date().toISOString(),
     summary: {
       coveragePercentage: Math.round(coverage.percentage * 10) / 10,
       totalMatches: coverage.totalMatches,
       coveredMatches: coverage.coveredMatches,
       totalGaps: coverage.gaps.length,
     },
     gapsBySeverity: {
       critical: severity.critical.length,
       warning: severity.warning.length,
       info: severity.info.length,
     },
     matches: {
       critical: severity.critical,
       warning: severity.warning,
       info: severity.info,
     },
   }, {
     headers: createRateLimitHeaders(rateLimitResult),
   });
   ```

5. Error handling (try/catch around steps 3-4):
   ```typescript
   catch (error) {
     return NextResponse.json(
       { error: sanitizeError(error, 'admin-pipeline-health') },
       { status: 500, headers: createRateLimitHeaders(rateLimitResult) }
     );
   }
   ```

Add a JSDoc comment at the top:
```typescript
/**
 * Pipeline Health Admin API (MON-02)
 *
 * Shows matches approaching kickoff (within 6h) that have no scheduled
 * analysis or predictions jobs. Gaps classified by severity:
 * - critical: < 2h to kickoff
 * - warning: 2-4h to kickoff
 * - info: 4-6h to kickoff
 *
 * SECURITY: Requires admin authentication via X-Admin-Password header
 */
```
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. `curl -H "X-Admin-Password: $ADMIN_PASSWORD" http://localhost:3000/api/admin/pipeline-health` returns JSON with summary and gaps
3. `curl http://localhost:3000/api/admin/pipeline-health` returns 401 (no auth)
  </verify>
  <done>
`/api/admin/pipeline-health` returns coverage summary with gaps classified as critical/warning/info. Requires admin auth. Rate limited at 10 req/min.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create settlement failures admin endpoint (MON-05)</name>
  <files>src/app/api/admin/settlement-failures/route.ts</files>
  <action>
Create `src/app/api/admin/settlement-failures/route.ts` with GET (view failures) and POST (retry specific failure).

**Imports:**
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { requireAdminAuth } from '@/lib/utils/admin-auth';
import { checkRateLimit, getRateLimitKey, createRateLimitHeaders, RATE_LIMIT_PRESETS } from '@/lib/utils/rate-limiter';
import { sanitizeError } from '@/lib/utils/error-sanitizer';
import { getSettlementQueue, JOB_TYPES } from '@/lib/queue/index';
import { getDeadLetterJobs } from '@/lib/queue/dead-letter';
import { getMatchById } from '@/lib/db/queries';
```

**GET handler - View settlement failures:**

Same rate-limit + auth pattern. Then:

```typescript
const settlementQueue = getSettlementQueue();

// Get failed jobs from settlement queue
const failedJobs = await settlementQueue.getFailed(0, 100);

// Get settlement-related DLQ entries
const dlqJobs = await getDeadLetterJobs(100, 0);
const settlementDlqJobs = dlqJobs.filter(j => j.queueName === 'settlement-queue');

// Format failures for dashboard
const failures = [
  ...failedJobs.map(job => ({
    jobId: job.id,
    matchId: job.data?.matchId,
    source: 'queue' as const,
    failedReason: job.failedReason ? job.failedReason.substring(0, 300) : null,
    attemptsMade: job.attemptsMade,
    timestamp: job.timestamp,
    processedOn: job.processedOn,
    finishedOn: job.finishedOn,
  })),
  ...settlementDlqJobs.map(job => ({
    jobId: job.jobId,
    matchId: job.data?.matchId,
    source: 'dlq' as const,
    failedReason: job.failedReason ? job.failedReason.substring(0, 300) : null,
    attemptsMade: job.attemptsMade || 0,
    timestamp: job.timestamp,
    processedOn: null,
    finishedOn: null,
  })),
];

return NextResponse.json({
  timestamp: new Date().toISOString(),
  totalFailures: failures.length,
  fromQueue: failedJobs.length,
  fromDlq: settlementDlqJobs.length,
  failures,
}, {
  headers: createRateLimitHeaders(rateLimitResult),
});
```

NOTE: The `failedReason` field on DLQEntry is named `failedReason` (check the DLQEntry interface in dead-letter.ts - it's actually `failureReason`). Check the actual DLQEntry interface and use the correct field name. The DLQEntry interface has `failedReason: string` (line 24 of dead-letter.ts), so use `job.failedReason`.

**POST handler - Retry specific settlement failure:**

Same rate-limit + auth pattern. Then:

Parse request body for `matchId` (string, required):
```typescript
const body = await req.json();
const { matchId } = body;

if (!matchId || typeof matchId !== 'string') {
  return NextResponse.json(
    { error: 'matchId is required' },
    { status: 400, headers: createRateLimitHeaders(rateLimitResult) }
  );
}
```

Follow the pattern from `settlement/retry/route.ts` for a single match:
1. Look up the match: `const matchData = await getMatchById(matchId);`
2. If not found, return 404
3. If not finished, return 400 with status info
4. Try to remove existing failed job for this match from queue:
   ```typescript
   const settlementQueue = getSettlementQueue();
   const possibleJobIds = [`settle-${matchId}`, `settle-retry-${matchId}`, `settle-zero-pred-${matchId}`];
   for (const jid of possibleJobIds) {
     try {
       const existingJob = await settlementQueue.getJob(jid);
       if (existingJob && await existingJob.isFailed()) {
         await existingJob.remove();
       }
     } catch { /* job doesn't exist */ }
   }
   ```
5. Re-queue with fresh data:
   ```typescript
   const { match } = matchData;
   await settlementQueue.add(
     JOB_TYPES.SETTLE_MATCH,
     {
       matchId: match.id,
       homeScore: match.homeScore ?? 0,
       awayScore: match.awayScore ?? 0,
       status: match.status,
     },
     {
       delay: 1000,
       priority: 1,
       jobId: `settle-retry-${match.id}`,
     }
   );
   ```
6. Return success: `{ success: true, matchId, message: 'Settlement job re-queued' }`

Add JSDoc:
```typescript
/**
 * Settlement Failures Admin API (MON-05)
 *
 * GET: View failed settlement jobs from queue and DLQ with error reasons
 * POST: Retry a specific failed settlement by matchId
 *
 * SECURITY: Requires admin authentication via X-Admin-Password header
 */
```
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. `curl -H "X-Admin-Password: $ADMIN_PASSWORD" http://localhost:3000/api/admin/settlement-failures` returns JSON with failures list
3. `curl -X POST -H "X-Admin-Password: $ADMIN_PASSWORD" -H "Content-Type: application/json" -d '{"matchId":"test"}' http://localhost:3000/api/admin/settlement-failures` returns 404 for nonexistent match
4. Both endpoints return 401 without admin auth
  </verify>
  <done>
`/api/admin/settlement-failures` GET returns failed settlement jobs from both queue and DLQ with error reasons, source, attempt counts, and timestamps. POST retries a specific matchId by removing the failed job and re-queuing with fresh data. Both require admin auth and rate limiting.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes for all new files
2. Build passes: `npm run build` or `npx next build --webpack`
3. Pipeline health endpoint: `curl -H "X-Admin-Password: ..." /api/admin/pipeline-health` returns severity-classified gaps
4. Settlement failures endpoint: `curl -H "X-Admin-Password: ..." /api/admin/settlement-failures` returns failure list
5. Both endpoints reject unauthenticated requests with 401
6. Rate limiting works (11th request in 1 minute returns 429)
</verification>

<success_criteria>
- MON-02: Admin dashboard endpoint shows matches within 6h of kickoff with no scheduled jobs, classified as critical/warning/info
- MON-05: Settlement failure dashboard shows failed jobs from both queue and DLQ with error reasons and retry via POST
- Both endpoints follow exact admin auth + rate limiting pattern from existing admin routes
- Error messages sanitized in production (sanitizeError used)
- No sensitive data leakage (failedReason truncated to 300 chars, no full stack traces)
</success_criteria>

<output>
After completion, create `.planning/phases/52-monitoring-observability/52-03-SUMMARY.md`
</output>
