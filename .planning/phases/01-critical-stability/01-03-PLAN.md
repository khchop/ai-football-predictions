---
phase: 01-critical-stability
plan: 03
type: execute
wave: 1
depends_on: []
files_modified: [src/lib/llm/prompt.ts, src/lib/llm/providers/base.ts, src/lib/utils/validation.ts]
autonomous: true
must_haves:
  truths:
    - "JSON in markdown code blocks successfully extracted"
    - "Malformed JSON extracted via regex pattern matching"
    - "Extra text surrounding JSON doesn't break parsing"
    - "Invalid scores (negative, >20) are detected and rejected"
    - "Parse failures log first 500 chars of raw response for debugging"
  artifacts:
    - path: "src/lib/llm/prompt.ts"
      provides: "Multi-strategy JSON extraction with fallbacks"
      contains: "parsePredictionResponse|multiStrategyParse|extractFromMarkdown"
    - path: "src/lib/utils/validation.ts"
      provides: "Score validation utilities"
      exports: ["isValidScore", "isValidScorePair", "validatePrediction"]
  key_links:
    - from: "src/lib/llm/prompt.ts"
      to: "src/lib/utils/validation.ts"
      via: "isV alidScore import"
      pattern: "import.*isValidScore.*from.*validation"
    - from: "src/lib/llm/providers/base.ts"
      to: "src/lib/llm/prompt.ts"
      via: "parsePredictionResponse call"
      pattern: "parsePredictionResponse\(.*response\)"
---

<objective>
Implement multi-strategy JSON extraction for LLM responses with fallbacks, score validation, and detailed error logging.

Purpose: Handle LLM responses with inconsistent formatting (markdown wrappers, extra text, malformed JSON) by trying multiple extraction strategies in sequence, validating scores, and logging parse failures for debugging.
Output: Robust JSON parser that extracts valid predictions from malformed LLM outputs.
</objective>

<execution_context>
@/Users/pieterbos/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Research: Multi-strategy JSON extraction
From .planning/phases/01-critical-stability/01-RESEARCH.md:
- Current issue: LLM JSON parse failures crash predictions, no fallback strategies
- Pattern: Fallback chain: direct JSON → markdown code block → regex extraction → flexible pattern matching
- Score validation: Reject negative scores, scores > 20, invalid score pairs
- Logging: First 500 chars of raw response on parse failure
- Graceful degradation: Treat regex-extracted scores as valid (if score extracted, it's valid)

# Context decisions:
- JSON fallback: Treat regex-extracted scores as normal
- LLM response logging: First 500 chars of raw response on parse failures
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create score validation utilities</name>
  <files>src/lib/utils/validation.ts</files>
  <action>
Create src/lib/utils/validation.ts with score validation functions:

```typescript
/**
 * Validate single score value (0-20, not negative, not null/undefined)
 */
export function isValidScore(score: unknown): score is number {
  return (
    typeof score === 'number' &&
    !isNaN(score) &&
    score >= 0 &&
    score <= 20 &&
    Number.isInteger(score)
  );
}

/**
 * Validate score pair (both home and away are valid)
 */
export function isValidScorePair(scores: { home_score?: unknown; away_score?: unknown }): scores is { home_score: number; away_score: number } {
  return isValidScore(scores.home_score) && isValidScore(scores.away_score);
}

/**
 * Validate prediction object structure
 */
export interface ValidatedPrediction {
  homeScore: number;
  awayScore: number;
}

export function validatePrediction(input: unknown): ValidatedPrediction | null {
  if (!input || typeof input !== 'object') {
    return null;
  }

  const scores = input as Record<string, unknown>;

  // Try multiple field name patterns
  const homeScore = scores.home_score ?? scores.homeScore ?? scores.home;
  const awayScore = scores.away_score ?? scores.awayScore ?? scores.away;

  if (!isValidScore(homeScore) || !isValidScore(awayScore)) {
    return null;
  }

  return {
    homeScore: homeScore as number,
    awayScore: awayScore as number,
  };
}
```

Export functions for use in parsers.
</action>
  <verify>grep -E "function isValidScore|function isValidScorePair|function validatePrediction" src/lib/utils/validation.ts</verify>
  <done>Validation utilities created: isValidScore(), isValidScorePair(), validatePrediction() with support for multiple field name patterns</done>
</task>

<task type="auto">
  <name>Task 2: Implement multi-strategy JSON extraction</name>
  <files>src/lib/llm/prompt.ts</files>
  <action>
Read existing src/lib/llm/prompt.ts. Add multi-strategy parsing function:

```typescript
import { logger } from '../logger';
import { isValidScorePair, validatePrediction } from '../utils/validation';

export interface ParseResult {
  success: boolean;
  predictions?: Array<{ matchId: string; homeScore: number; awayScore: number }>;
  error?: string;
}

/**
 * Strategy 1: Direct JSON parse (cleanest inputs)
 */
function parseDirectJSON(response: string): Array<{ matchId: string; homeScore: number; awayScore: number }> | null {
  try {
    const trimmed = response.trim();
    // Handle array response
    if (trimmed.startsWith('[')) {
      const parsed = JSON.parse(trimmed) as Array<{ matchId: string; home_score: number; away_score: number }>;
      return parsed.map(p => ({
        matchId: p.matchId,
        homeScore: p.home_score,
        awayScore: p.away_score,
      }));
    }
    // Handle object response
    else if (trimmed.startsWith('{')) {
      const parsed = JSON.parse(trimmed) as { predictions?: Array<{ matchId: string; home_score: number; away_score: number }> };
      return parsed.predictions?.map(p => ({
        matchId: p.matchId,
        homeScore: p.home_score,
        awayScore: p.away_score,
      })) || [];
    }
    return null;
  } catch {
    return null;
  }
}

/**
 * Strategy 2: Extract from markdown code blocks
 */
function extractFromMarkdownCodeBlock(response: string): string | null {
  // Try ```json``` blocks
  const jsonBlockMatch = response.match(/```json\n?([\s\S]*?)\n?```/i);
  if (jsonBlockMatch) {
    return jsonBlockMatch[1].trim();
  }

  // Try generic ``` blocks
  const codeBlockMatch = response.match(/```\n?([\s\S]*?)\n?```/);
  if (codeBlockMatch) {
    return codeBlockMatch[1].trim();
  }

  return null;
}

/**
 * Strategy 3: Regex extraction for structured JSON objects
 */
function extractScorePatterns(response: string): Array<{ matchId: string; homeScore: number; awayScore: number }> | null {
  const predictions: Array<{ matchId: string; homeScore: number; awayScore: number }> = [];

  // Pattern: {"matchId": "...", "home_score": 1, "away_score": 2}
  const jsonPattern = /\{\s*"matchId"\s*:\s*"([^"]+)"\s*,\s*"home_score"\s*:\s*(\d+)\s*,\s*"away_score"\s*:\s*(\d+)\s*\}/gi;

  const matches = [...response.matchAll(jsonPattern)];
  for (const match of matches) {
    const homeScore = parseInt(match[2], 10);
    const awayScore = parseInt(match[3], 10);

    if (isValidScore(homeScore) && isValidScore(awayScore)) {
      predictions.push({
        matchId: match[1],
        homeScore,
        awayScore,
      });
    }
  }

  if (predictions.length > 0) {
    return predictions;
  }

  return null;
}

/**
 * Strategy 4: Flexible pattern matching (any score-like numbers)
 */
function extractFlexibleScores(response: string): Array<{ matchId: string; homeScore: number; awayScore: number }> | null {
  // Look for patterns like: matchId: "xxx", home: 1, away: 2
  const flexiblePattern = /matchId["']?\s*[:=]\s*"([^"]+)".*?(?:home|home_score|homeScore)["']?\s*[:=]\s*(\d+).*?(?:away|away_score|awayScore)["']?\s*[:=]\s*(\d+)/gis;

  const predictions: Array<{ matchId: string; homeScore: number; awayScore: number }> = [];
  const matches = [...response.matchAll(flexiblePattern)];

  for (const match of matches) {
    const homeScore = parseInt(match[2], 10);
    const awayScore = parseInt(match[3], 10);

    if (isValidScore(homeScore) && isValidScore(awayScore)) {
      predictions.push({
        matchId: match[1],
        homeScore,
        awayScore,
      });
    }
  }

  if (predictions.length > 0) {
    return predictions;
  }

  return null;
}

/**
 * Multi-strategy parser with fallbacks
 */
export function parseBatchPredictionResponse(
  response: string,
  matchIds: string[]
): ParseResult {
  if (!response || typeof response !== 'string') {
    return {
      success: false,
      error: 'Empty or invalid response',
    };
  }

  const strategies = [
    { name: 'Direct JSON', fn: () => parseDirectJSON(response) },
    { name: 'Markdown code block', fn: () => {
      const extracted = extractFromMarkdownCodeBlock(response);
      return extracted ? parseDirectJSON(extracted) : null;
    }},
    { name: 'Score pattern regex', fn: () => extractScorePatterns(response) },
    { name: 'Flexible pattern', fn: () => extractFlexibleScores(response) },
  ];

  // Try each strategy in order
  for (let i = 0; i < strategies.length; i++) {
    try {
      const result = strategies[i].fn();

      if (result && result.length > 0) {
        // Validate predictions
        const validPredictions = result.filter(p => {
          if (!p.matchId || !isValidScorePair({ home_score: p.homeScore, away_score: p.awayScore })) {
            return false;
          }
          // Ensure matchId is in expected set
          return matchIds.includes(p.matchId);
        });

        if (validPredictions.length > 0) {
          logger.info({
            strategy: strategies[i].name,
            totalFound: result.length,
            validPredictions: validPredictions.length,
          }, 'Successfully parsed predictions');

          return {
            success: true,
            predictions: validPredictions,
          };
        }
      }
    } catch (error) {
      // Continue to next strategy
      logger.debug({
        strategy: strategies[i].name,
        error: error instanceof Error ? error.message : String(error),
      }, 'Strategy failed');
    }
  }

  // All strategies failed - log error with preview
  logger.error({
    responsePreview: response.slice(0, 500),
    responseLength: response.length,
    strategiesAttempted: strategies.length,
  }, 'All JSON parse strategies failed');

  return {
    success: false,
    error: 'Could not extract valid predictions from response',
  };
}
```

Add to existing or create new prompt.ts file.
</action>
  <verify>grep -E "function parseDirectJSON|function extractFromMarkdownCodeBlock|function parseBatchPredictionResponse" src/lib/llm/prompt.ts</verify>
  <done>Multi-strategy parser implemented: 4 strategies (direct JSON → markdown → score regex → flexible), validation, error logging with preview</done>
</task>

<task type="auto">
  <name>Task 3: Update provider base class to use multi-strategy parser</name>
  <files>src/lib/llm/providers/base.ts</files>
  <action>
Read src/lib/llm/providers/base.ts. Update to use new parseBatchPredictionResponse function:

```typescript
import { parseBatchPredictionResponse } from '../prompt';

export abstract class BaseLLMProvider {
  // ... existing code ...

  async callAPI(systemPrompt: string, userPrompt: string): Promise<string> {
    // ... existing API logic ...
  }

  async getPredictions(matchIds: string[]): Promise<Array<{ matchId: string; homeScore: number; awayScore: number }>> {
    try {
      const response = await this.callAPI(BATCH_SYSTEM_PROMPT, this.buildPrompt(matchIds));

      const parsed = parseBatchPredictionResponse(response, matchIds);

      if (!parsed.success) {
        logger.warn({
          providerId: this.id,
          error: parsed.error,
        }, 'Failed to parse predictions');
        return [];
      }

      return parsed.predictions || [];

    } catch (error) {
      logger.error({
        providerId: this.id,
        error: error instanceof Error ? error.message : String(error),
      }, 'API call failed');
      throw error;
    }
  }
}
```

Update method signature and implementation to use parseBatchPredictionResponse.
</action>
  <verify>grep -E "parseBatchPredictionResponse" src/lib/llm/providers/base.ts</verify>
  <done>Provider base class updated: getPredictions() uses parseBatchPredictionResponse with error handling</done>
</task>

<task type="auto">
  <name>Task 4: Add unit tests for validation utils</name>
  <files>src/lib/utils/__tests__/validation.test.ts</files>
  <action>
Create src/lib/utils/__tests__/validation.test.ts:

```typescript
import { isValidScore, isValidScorePair, validatePrediction } from '../validation';

describe('isValidScore', () => {
  it('accepts valid scores', () => {
    expect(isValidScore(0)).toBe(true);
    expect(isValidScore(1)).toBe(true);
    expect(isValidScore(10)).toBe(true);
    expect(isValidScore(20)).toBe(true);
  });

  it('rejects invalid scores', () => {
    expect(isValidScore(-1)).toBe(false);
    expect(isValidScore(21)).toBe(false);
    expect(isValidScore(1.5)).toBe(false);
    expect(isValidScore(NaN)).toBe(false);
    expect(isValidScore(null)).toBe(false);
    expect(isValidScore(undefined)).toBe(false);
    expect(isValidScore('1')).toBe(false);
  });
});

describe('isValidScorePair', () => {
  it('accepts valid score pairs', () => {
    expect(isValidScorePair({ home_score: 1, away_score: 2 })).toBe(true);
    expect(isValidScorePair({ homeScore: 0, awayScore: 20 })).toBe(true);
  });

  it('rejects invalid score pairs', () => {
    expect(isValidScorePair({ home_score: -1, away_score: 2 })).toBe(false);
    expect(isValidScorePair({ home_score: 1 })).toBe(false);
    expect(isValidScorePair({})).toBe(false);
  });
});

describe('validatePrediction', () => {
  it('validates correct prediction objects', () => {
    expect(validatePrediction({ home_score: 1, away_score: 2 })).toEqual({ homeScore: 1, awayScore: 2 });
    expect(validatePrediction({ homeScore: 3, awayScore: 0 })).toEqual({ homeScore: 3, awayScore: 0 });
  });

  it('handles multiple field name patterns', () => {
    expect(validatePrediction({ home: 1, away: 2 })).toEqual({ homeScore: 1, awayScore: 2 });
  });

  it('rejects invalid inputs', () => {
    expect(validatePrediction(null)).toBe(null);
    expect(validatePrediction({ home_score: -1, away_score: 2 })).toBe(null);
    expect(validatePrediction({})).toBe(null);
  });
});
```

Run tests: `npm test -- validation.test.ts`
</action>
  <verify>grep -E "describe.*isValidScore|it.*accepts valid" src/lib/utils/__tests__/validation.test.ts</verify>
  <done>Unit tests created and passing for validation utilities (isValidScore, isValidScorePair, validatePrediction)</done>
</task>

</tasks>

<verification>
1. Direct JSON parsing: Test with `{"matchId":"1","home_score":1,"away_score":2}` - extracts correctly
2. Markdown extraction: Test with ```json\n{...}\n``` - extracts correctly
3. Regex fallback: Test with `matchId: "1", home: 1, away: 2` - extracts correctly
4. Invalid scores rejected: Test with `{"home_score":-1,"away_score":2}` - returns success:false
5. Parse failure logging: Force parse failure, check logs contain "responsePreview" with first 500 chars
6. All strategies exhausted: Test with garbage input, logs "All JSON parse strategies failed"
</verification>

<success_criteria>
- Clean JSON responses parsed successfully via direct JSON.parse
- Markdown code blocks extracted and parsed correctly
- Malformed JSON extracted via regex pattern matching
- Extra text surrounding JSON doesn't break parsing
- Invalid scores (negative, >20, non-integer) detected and rejected
- Parse failures log first 500 chars of raw response for debugging
- Score validation utilities tested and passing
- Multi-strategy parser works with LLM responses from real providers
</success_criteria>

<output>
After completion, create `.planning/phases/01-critical-stability/01-03-SUMMARY.md`

Use summary template with:
- Multi-strategy extraction implemented (4 strategies with fallbacks)
- Score validation created (isValidScore, isValidScorePair, validatePrediction)
- Error logging with response preview on failures
- Unit tests for validation utilities
- Parse success rate improvement (if measurable)
- Any codebase patterns discovered
- Issues encountered and resolutions
</output>
