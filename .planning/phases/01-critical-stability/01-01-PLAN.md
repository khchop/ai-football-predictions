---
phase: 01-critical-stability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/lib/db/index.ts, src/lib/logger/index.ts]
autonomous: true
must_haves:
  truths:
    - "Database pool supports 20+ concurrent connections without exhaustion"
    - "Pool health metrics logged every 30 seconds with alerts on 80%+ utilization"
    - "Connection timeout (5s) prevents hanging queries"
    - "Idle timeout (30s) recycles unused connections"
  artifacts:
    - path: "src/lib/db/index.ts"
      provides: "Pool configuration with monitoring"
      min_lines: 80
      contains: "Pool({", "max:", "keepAlive:", "monitorPoolHealth"
    - path: "src/lib/logger/index.ts"
      provides: "Structured logging for database operations"
      contains: "pino", "child"
  key_links:
    - from: "src/lib/db/index.ts"
      to: "process.env.DATABASE_URL"
      via: "Pool connectionString"
      pattern: "process\\.env\\.DATABASE_URL"
    - from: "src/lib/db/index.ts"
      to: "logger"
      via: "pino import"
      pattern: "import.*pino.*from"
---

<objective>
Configure PostgreSQL connection pool for 20+ concurrent workers with health monitoring and alerting.

Purpose: Prevent "connection pool exhausted" errors under 12+ concurrent queue workers by increasing pool size, implementing health checks, and alerting on high utilization.
Output: Production-ready pool configuration with monitoring infrastructure.
</objective>

<execution_context>
@/Users/pieterbos/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Research: Database pool sizing and monitoring
From .planning/phases/01-critical-stability/01-RESEARCH.md:
- Current issue: Default pool size (10) too small for 12+ workers, causing exhaustion
- Recommendation: Increase to max=20, set connectionTimeoutMillis=5000, idleTimeoutMillis=30000
- Monitoring: Log pool metrics every 30 seconds, alert at waitingCount > 5 or utilization > 90%
- KeepAlive enabled to prevent connection drops
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure pool with production settings</name>
  <files>src/lib/db/index.ts</files>
  <action>
Read existing src/lib/db/index.ts to understand current pool configuration. Update Pool initialization with:
- max: parseInt(process.env.DB_POOL_MAX || '20', 10) (increase from current default)
- min: parseInt(process.env.DB_POOL_MIN || '2', 10)
- idleTimeoutMillis: 30000
- connectionTimeoutMillis: 5000
- keepAlive: true
- keepAliveInitialDelayMillis: 10000

Add pool error handler:
pool.on('error', (err) => {
  logger.error({ error: err.message }, 'Unexpected pool error');
});

Use default export for pool: export default pool;
</action>
  <verify>grep -A10 "Pool({" src/lib/db/index.ts | grep -E "max:|idleTimeoutMillis:|connectionTimeoutMillis:|keepAlive:"</verify>
  <done>Pool configured with max=20, timeouts (5s connection, 30s idle), keepAlive enabled</done>
</task>

<task type="auto">
  <name>Task 2: Implement pool health monitoring</name>
  <files>src/lib/db/index.ts</files>
  <action>
Add monitorPoolHealth function:
```typescript
interface PoolHealth {
  totalCount: number;
  idleCount: number;
  waitingCount: number;
  maxConnections: number;
  utilizationPercent: number;
}

function monitorPoolHealth(pool: Pool): void {
  const health: PoolHealth = {
    totalCount: pool.totalCount,
    idleCount: pool.idleCount,
    waitingCount: pool.waitingCount,
    maxConnections: pool.options.max || 20,
    utilizationPercent: Math.round(
      ((pool.totalCount - pool.idleCount) / (pool.options.max || 20)) * 100
    ),
  };

  logger.debug(health, 'Pool health check');

  // Alert on concerning conditions
  if (health.waitingCount > 5) {
    logger.warn(health, 'High connection wait queue detected');
  }
  if (health.utilizationPercent > 90) {
    logger.warn(health, 'Pool utilization exceeds 90%');
  }
  if (health.totalCount === health.maxConnections && health.idleCount === 0) {
    logger.error(health, 'Pool exhausted - all connections in use');
  }
}
```

Start monitoring interval:
```typescript
setInterval(() => monitorPoolHealth(pool), 30000);
```

Add at module level, after pool initialization.
</action>
  <verify>grep -A20 "function monitorPoolHealth" src/lib/db/index.ts | grep -E "waitingCount > 5|utilizationPercent.*90|Pool exhausted"</verify>
  <done>Health monitoring runs every 30s, logs debug metrics, warns at 5+ waiting or 90%+ utilization, errors on exhaustion</done>
</task>

<task type="auto">
  <name>Task 3: Set up DB child logger for structured output</name>
  <files>src/lib/db/index.ts</files>
  <action>
Import pino logger (or use existing logger import):
```typescript
import pino from 'pino';
const logger = pino({ level: process.env.LOG_LEVEL || 'info' });
```

OR if logger infrastructure exists:
```typescript
import { dbLogger } from '../logger';
const logger = dbLogger;
```

Add child logger for monitoring context:
```typescript
const dbLogger = logger.child({ module: 'database-pool' });
```
Replace logger references with dbLogger in monitorPoolHealth.
</action>
  <verify>grep -E "import.*pino|logger\.child" src/lib/db/index.ts</verify>
  <done>DB logger configured with module='database-pool' for structured log context</done>
</task>

</tasks>

<verification>
1. Pool accepts 20 connections: Check pg.Pool logs during worker startup
2. Health monitoring active: Check logs for "Pool health check" entries every 30s
3. Alerting working: Simulate high load, expect "Pool utilization exceeds 90%" warning
4. No pool exhaustion errors: Run 12+ concurrent prediction jobs, verify queries complete without errors
</verification>

<success_criteria>
- Pool configuration supports 20+ concurrent connections
- Health metrics logged automatically every 30 seconds
- Alerts trigger at 5+ waiting connections or 90%+ utilization
- Connection timeout of 5s prevents query hangs
- System handles 12+ concurrent workers without "pool exhausted" errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-critical-stability/01-01-SUMMARY.md`

Use summary template with:
- Pool settings applied (max=20, timeouts, keepAlive)
- Monitoring infrastructure deployed
- Any codebase patterns discovered
- Issues encountered and resolutions
</output>
