---
phase: 42-dynamic-model-counts
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/llm/index.ts
  - src/lib/cache/redis.ts
  - src/lib/db/queries.ts
autonomous: true

must_haves:
  truths:
    - "getActiveModelCount() returns count from database, not provider arrays"
    - "Cache key exists for active model count"
    - "Model enable/disable invalidates model count cache"
    - "getOverallStats().activeModels returns same value as getActiveModelCount()"
  artifacts:
    - path: "src/lib/llm/index.ts"
      provides: "getActiveModelCount() function"
      exports: ["getActiveModelCount"]
    - path: "src/lib/cache/redis.ts"
      provides: "activeModelCount cache key and invalidation function"
      contains: "activeModelCount"
    - path: "src/lib/db/queries.ts"
      provides: "Model status change calls invalidation"
      contains: "invalidateModelCountCaches"
  key_links:
    - from: "src/lib/llm/index.ts"
      to: "src/lib/cache/redis.ts"
      via: "withCache import for caching"
      pattern: "withCache.*cacheKeys\\.activeModelCount"
    - from: "src/lib/db/queries.ts"
      to: "src/lib/cache/redis.ts"
      via: "invalidation call on model status change"
      pattern: "invalidateModelCountCaches"
---

<objective>
Create single source of truth for active model count with proper cache invalidation infrastructure.

Purpose: Provides the foundation for replacing all hardcoded "35 models" references with dynamic counts. Ensures count updates immediately when models are enabled/disabled.
Output: `getActiveModelCount()` function exported from llm/index.ts, cache infrastructure in redis.ts
</objective>

<execution_context>
@/Users/pieterbos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/42-dynamic-model-counts/42-RESEARCH.md

# Key source files
@src/lib/llm/index.ts
@src/lib/cache/redis.ts
@src/lib/db/queries.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add cache key and invalidation function to redis.ts</name>
  <files>src/lib/cache/redis.ts</files>
  <action>
Add to `cacheKeys` object (around line 368-397):
```typescript
activeModelCount: () => 'db:models:count:active',
```

Add new export function `invalidateModelCountCaches()` after `invalidateStatsCache()` (around line 455):
```typescript
/**
 * Invalidate all caches that depend on active model count
 * Called when model status changes (enable/disable/auto-disable)
 */
export async function invalidateModelCountCaches(): Promise<void> {
  const redis = getRedis();
  if (!redis) return;

  try {
    await Promise.all([
      cacheDelete(cacheKeys.activeModelCount()),
      cacheDelete(cacheKeys.overallStats()),
      // Leaderboard caches include model count in FAQs
      cacheDeletePattern('db:leaderboard:*'),
    ]);
    loggers.cache.info('Invalidated model count caches');
  } catch (error) {
    loggers.cache.error({
      error: error instanceof Error ? error.message : String(error)
    }, 'Failed to invalidate model count caches');
  }
}
```

Do NOT modify any existing functions or cache keys.
  </action>
  <verify>
Run `grep -n "activeModelCount" src/lib/cache/redis.ts` shows cache key and function.
Run `npx tsc --noEmit` passes without errors.
  </verify>
  <done>
- `cacheKeys.activeModelCount()` returns `'db:models:count:active'`
- `invalidateModelCountCaches()` is exported and calls cacheDelete for activeModelCount, overallStats, and leaderboard pattern
  </done>
</task>

<task type="auto">
  <name>Task 2: Add getActiveModelCount() to llm/index.ts</name>
  <files>src/lib/llm/index.ts</files>
  <action>
Add imports at top of file (after existing imports):
```typescript
import { withCache, cacheKeys, CACHE_TTL } from '@/lib/cache/redis';
import { getDb, models } from '@/lib/db';
import { eq, sql } from 'drizzle-orm';
```

Add new export function after `getProviderStats()` (around line 186):
```typescript
/**
 * Get active model count from database (cached)
 * This is the SINGLE SOURCE OF TRUTH for model count in UI/content
 *
 * Queries database `models.active = true`, not provider arrays.
 * Provider arrays show configured models (42), this shows operationally active ones.
 *
 * @returns Number of active models from database
 */
export async function getActiveModelCount(): Promise<number> {
  return withCache(
    cacheKeys.activeModelCount(),
    CACHE_TTL.STATS, // 60s TTL (same as overall stats)
    async () => {
      const db = getDb();
      const result = await db
        .select({ count: sql<number>`COUNT(*)::int` })
        .from(models)
        .where(eq(models.active, true));
      return result[0]?.count || 0;
    }
  );
}
```

Verify CACHE_TTL is imported - if not available, use literal 60 seconds.
  </action>
  <verify>
Run `npx tsc --noEmit` passes without errors.
Run `grep -n "getActiveModelCount" src/lib/llm/index.ts` shows function definition.
  </verify>
  <done>
- `getActiveModelCount()` is exported from src/lib/llm/index.ts
- Function queries database for COUNT(*) where active = true
- Result is cached with 60s TTL
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire invalidation to model status changes</name>
  <files>src/lib/db/queries.ts</files>
  <action>
Add import at top of file:
```typescript
import { invalidateModelCountCaches } from '@/lib/cache/redis';
```

Find the following functions that change model status and add invalidation call AFTER each database update:

1. Find `updateModelActiveStatus` or similar function that sets `models.active`
2. Find `autoDisableModel` or `deactivateModel` function
3. Find any function that calls `db.update(models)` with `active` field

For each function, add after the database update:
```typescript
// Invalidate model count caches
await invalidateModelCountCaches();
```

If no such functions exist in queries.ts, check sync-models.ts:
```bash
grep -r "models.active\|autoDisabled" src/lib/db/
```

Add invalidation to whichever file contains the model status mutation.
  </action>
  <verify>
Run `grep -rn "invalidateModelCountCaches" src/lib/db/` shows at least one call.
Run `npx tsc --noEmit` passes without errors.
  </verify>
  <done>
- `invalidateModelCountCaches()` is called after every model status change
- Cache invalidation is atomic (called after DB update commits)
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `npx tsc --noEmit` passes
2. Function exports: `grep "export.*getActiveModelCount\|export.*invalidateModelCountCaches" src/lib/llm/index.ts src/lib/cache/redis.ts` shows both exports
3. Cache key: `grep "activeModelCount" src/lib/cache/redis.ts` shows key definition
4. Invalidation wiring: `grep -r "invalidateModelCountCaches" src/lib/db/` shows at least one call
</verification>

<success_criteria>
- getActiveModelCount() function exists and is exported
- Function queries database, not provider arrays
- Cache key `db:models:count:active` is defined
- invalidateModelCountCaches() is exported and invalidates related caches
- Model status changes trigger cache invalidation
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/42-dynamic-model-counts/42-01-SUMMARY.md`
</output>
