---
phase: 36-blog-generation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/content/generator.ts
  - src/lib/queue/workers/content.worker.ts
autonomous: true

must_haves:
  truths:
    - "generateLeagueRoundup throws RetryableContentError on LLM failures"
    - "generateModelReport throws RetryableContentError on LLM failures"
    - "Blog generation failures appear in BullMQ dead letter queue after retry exhaustion"
    - "Job schedulers for blog content are registered and trigger on schedule"
  artifacts:
    - path: "src/lib/content/generator.ts"
      provides: "Blog generation with proper error handling"
      contains: "RetryableContentError"
    - path: "src/lib/queue/workers/content.worker.ts"
      provides: "Blog job processing with error propagation"
      contains: "generateLeagueRoundupContent"
  key_links:
    - from: "src/lib/content/generator.ts"
      to: "src/lib/errors/content-errors.ts"
      via: "import RetryableContentError"
      pattern: "RetryableContentError"
    - from: "src/lib/queue/workers/content.worker.ts"
      to: "src/lib/content/generator.ts"
      via: "generateLeagueRoundup, generateModelReport"
      pattern: "generateLeagueRoundup|generateModelReport"
---

<objective>
Align blog generation error handling with match content patterns established in Phase 32

Purpose: Blog generation should use the same error handling pattern as match content - throwing RetryableContentError/FatalContentError instead of returning false or catching errors silently. This enables BullMQ retry logic and DLQ routing.

Output: Updated generator.ts with proper error handling for blog functions, verified job scheduler triggers
</objective>

<execution_context>
@/Users/pieterbos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-blog-generation/36-RESEARCH.md
@src/lib/content/generator.ts
@src/lib/queue/workers/content.worker.ts
@src/lib/errors/content-errors.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add RetryableContentError to blog generation functions</name>
  <files>src/lib/content/generator.ts</files>
  <action>
Review and update `generateLeagueRoundup` and `generateModelReport` functions to use the same error handling pattern as match content (established in Phase 32).

1. First, verify the import exists at the top of generator.ts. If not, add:
```typescript
import { RetryableContentError, FatalContentError } from '@/lib/errors/content-errors';
```

2. In `generateLeagueRoundup` function, wrap the LLM call in proper error handling. After the `generateWithTogetherAI` call (around line 341), add error classification:

```typescript
// After the try block for generateWithTogetherAI
} catch (error: any) {
  // Check if it's a validation error (hallucination detected) - these are fatal
  if (error.message?.includes('validation failed')) {
    throw new FatalContentError(
      `League roundup validation failed: ${error.message}`,
      {
        matchId: 'N/A',
        reason: 'validation_failed',
        timestamp: new Date().toISOString(),
      }
    );
  }

  // Rate limit and transient errors are retryable
  throw new RetryableContentError(
    `League roundup generation failed: ${error.message}`,
    {
      matchId: 'N/A',
      homeTeam: roundupData.competition,
      awayTeam: '',
      contentType: 'league_roundup',
      timestamp: new Date().toISOString(),
      originalError: error,
    }
  );
}
```

3. In `generateModelReport` function, add similar error handling after the `generateWithTogetherAI` call:

```typescript
} catch (error: any) {
  throw new RetryableContentError(
    `Model report generation failed: ${error.message}`,
    {
      matchId: 'N/A',
      homeTeam: reportData.period,
      awayTeam: '',
      contentType: 'model_report',
      timestamp: new Date().toISOString(),
      originalError: error,
    }
  );
}
```

NOTE: The functions may already have try-catch blocks. If so, modify the existing catch block to throw the appropriate error class instead of logging and returning or re-throwing a generic error.

4. Verify that existing error throws (like the validation check at line 381) are preserved - these are already correct.
  </action>
  <verify>
1. Search for RetryableContentError in generator.ts: `grep "RetryableContentError" src/lib/content/generator.ts`
2. Verify import exists: `grep "import.*content-errors" src/lib/content/generator.ts`
3. Verify generateLeagueRoundup has error handling: `grep -A 5 "catch.*error" src/lib/content/generator.ts | grep -E "RetryableContentError|FatalContentError"`
  </verify>
  <done>
generateLeagueRoundup and generateModelReport throw RetryableContentError on LLM failures and FatalContentError on validation failures
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify blog job scheduler triggers and worker processing</name>
  <files>src/lib/queue/workers/content.worker.ts</files>
  <action>
Verify that the content worker properly handles blog generation job types and propagates errors correctly.

1. Check the worker switch statement handles 'league_roundup' and 'model_report' types (should already exist around lines 86-94). Verify these cases:
   - Call `generateLeagueRoundupContent` and `generateModelReportContent`
   - Do NOT wrap in try-catch that swallows errors (errors should propagate to BullMQ)

2. Verify `generateLeagueRoundupContent` (around line 384) properly propagates errors:
   - Should have try-catch that logs but RE-THROWS the error
   - Should NOT return false or suppress errors

3. Verify `generateModelReportContent` (around line 415) properly propagates errors:
   - Should have try-catch that logs but RE-THROWS the error
   - Should NOT return false or suppress errors

4. Check that both functions are called from the job type handlers without error suppression.

If any function catches errors and does NOT re-throw, update to re-throw:

```typescript
// WRONG pattern (suppresses error)
} catch (error) {
  log.error({ err: error }, 'Failed');
  return { success: false };
}

// CORRECT pattern (propagates to BullMQ)
} catch (error) {
  log.error({ err: error }, 'Failed');
  throw error; // Re-throw for BullMQ retry
}
```
  </action>
  <verify>
1. Verify job type handlers exist: `grep -E "type === 'league_roundup'|type === 'model_report'" src/lib/queue/workers/content.worker.ts`
2. Verify error propagation: `grep -A 3 "catch (error)" src/lib/queue/workers/content.worker.ts | grep "throw error"`
3. Test TypeScript compilation: `npx tsc --noEmit`
  </verify>
  <done>
Content worker properly handles 'league_roundup' and 'model_report' job types, errors propagate to BullMQ for retry logic
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify job schedulers are registered</name>
  <files>src/lib/queue/setup.ts</files>
  <action>
Verify that blog generation job schedulers are properly registered. This is a verification task - the schedulers should already exist from a prior implementation.

1. Confirm weekly league roundup scheduler exists (should be around lines 308-320):
   - Job name: 'scan-league-roundups'
   - Pattern: '0 8 * * 1' (Monday 8 AM) or similar weekly pattern
   - Data type: 'scan_league_roundups'

2. Confirm monthly model report scheduler exists (should be around lines 322-339):
   - Job name: 'generate-model-report'
   - Pattern: '0 9 1 * *' (1st of month 9 AM) or similar monthly pattern
   - Data type: 'model_report'

3. If schedulers are missing, add them using the `registerRepeatableJob` helper:

```typescript
// Weekly league roundups
await registerRepeatableJob(
  contentQueue,
  'scan-league-roundups',
  { type: 'scan_league_roundups', data: {} },
  {
    repeat: {
      pattern: '0 8 * * 1', // Monday 8 AM
      tz: 'Europe/Berlin',
    },
    jobId: 'league-roundups-weekly',
  }
);

// Monthly model report
await registerRepeatableJob(
  contentQueue,
  'generate-model-report',
  {
    type: 'model_report',
    data: {
      period: new Date().toLocaleDateString('en-US', { month: 'long', year: 'numeric' })
    }
  },
  {
    repeat: {
      pattern: '0 9 1 * *', // 1st of month 9 AM
      tz: 'Europe/Berlin',
    },
    jobId: 'model-report-monthly',
  }
);
```

Log verification result without making changes if schedulers already exist correctly.
  </action>
  <verify>
1. Verify roundup scheduler: `grep -A 10 "league-roundups-weekly" src/lib/queue/setup.ts`
2. Verify model report scheduler: `grep -A 10 "model-report-monthly" src/lib/queue/setup.ts`
3. Verify cron patterns are valid: Check patterns against standard cron format
  </verify>
  <done>
Blog job schedulers are registered with correct cron patterns and job types. Weekly roundups trigger Monday 8 AM, monthly reports trigger 1st of month 9 AM.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Run TypeScript compilation: `npx tsc --noEmit` - should pass
2. Verify error classes are imported: `grep "RetryableContentError" src/lib/content/generator.ts`
3. Verify job schedulers exist: `grep -E "league-roundups-weekly|model-report-monthly" src/lib/queue/setup.ts`
4. Verify error propagation in worker: `grep -B 2 "throw error" src/lib/queue/workers/content.worker.ts`
</verification>

<success_criteria>
1. generateLeagueRoundup throws RetryableContentError on LLM failures
2. generateModelReport throws RetryableContentError on LLM failures
3. Content worker re-throws errors (does not suppress with return false)
4. Job schedulers for league roundups (weekly) and model reports (monthly) are registered
5. TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/36-blog-generation/36-02-SUMMARY.md`
</output>
