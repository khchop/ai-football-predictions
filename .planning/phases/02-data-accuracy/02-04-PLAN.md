---
phase: 02-data-accuracy
plan: 04
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/lib/cache/redis.ts
  - src/lib/queue/workers/scoring.worker.ts
autonomous: true

must_haves:
  truths:
    - "Cache shows updated data within 5 seconds of settlement completion"
    - "Cache invalidation uses non-blocking SCAN instead of blocking KEYS"
    - "Leaderboard cache is invalidated after all predictions are scored"
    - "No stale data visible immediately after settlement"
  artifacts:
    - path: "src/lib/cache/redis.ts"
      provides: "SCAN-based pattern deletion"
      contains: "scanStream|scan"
    - path: "src/lib/queue/workers/scoring.worker.ts"
      provides: "Post-transaction cache invalidation"
  key_links:
    - from: "src/lib/queue/workers/scoring.worker.ts"
      to: "src/lib/cache/redis.ts"
      via: "invalidateMatchCaches after transaction commit"
      pattern: "transaction.*then.*invalidateMatchCaches"
---

<objective>
Replace blocking KEYS command with non-blocking SCAN for cache pattern deletion, and ensure cache invalidation timing prevents stale data display.

Purpose: The current `cacheDeletePattern` uses Redis KEYS command which blocks the server during execution - dangerous in production. SCAN is non-blocking and iterative.

Output: Non-blocking cache invalidation that doesn't impact Redis performance, with guaranteed freshness after settlement.
</objective>

<execution_context>
@/Users/pieterbos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-data-accuracy/02-RESEARCH.md
@.planning/phases/02-data-accuracy/02-01-SUMMARY.md

@src/lib/cache/redis.ts
@src/lib/queue/workers/scoring.worker.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace KEYS with SCAN in cacheDeletePattern</name>
  <files>src/lib/cache/redis.ts</files>
  <action>
Update the `cacheDeletePattern` function to use Redis SCAN instead of KEYS:

Replace the current implementation (around lines 283-295):

```typescript
/**
 * Delete multiple cache keys by pattern using SCAN (non-blocking)
 * SCAN iterates through keys without blocking Redis, unlike KEYS which blocks
 */
export async function cacheDeletePattern(pattern: string): Promise<number> {
  const redis = getRedis();
  if (!redis) return 0;

  try {
    let deletedCount = 0;
    let cursor = '0';

    // Use SCAN to iterate through keys matching pattern
    // SCAN is non-blocking and returns in batches
    do {
      // SCAN cursor MATCH pattern COUNT 100
      const [nextCursor, keys] = await redis.scan(cursor, 'MATCH', pattern, 'COUNT', 100);
      cursor = nextCursor;

      if (keys.length > 0) {
        // Delete found keys in batch
        const deleted = await redis.del(...keys);
        deletedCount += deleted;
      }
    } while (cursor !== '0'); // SCAN returns '0' when complete

    loggers.cache.debug({ pattern, deletedCount }, 'Deleted cache keys by pattern (SCAN)');
    return deletedCount;
  } catch (error) {
    loggers.cache.error({
      pattern,
      error: error instanceof Error ? error.message : String(error)
    }, 'Error deleting cache pattern with SCAN');
    return 0;
  }
}
```

**Why this matters:**
- `KEYS pattern` scans ALL keys and blocks Redis until complete
- With 10k+ keys, KEYS can block for 50-200ms
- `SCAN` returns in batches without blocking other operations
- COUNT 100 is a hint for batch size (not a limit)
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit src/lib/cache/redis.ts`
2. Uses SCAN: `grep "scan" src/lib/cache/redis.ts`
3. No KEYS usage: `grep -v "\/\/" src/lib/cache/redis.ts | grep -c "\.keys(" | test $(cat) -eq 0`
  </verify>
  <done>
`cacheDeletePattern` uses SCAN loop instead of blocking KEYS command
  </done>
</task>

<task type="auto">
  <name>Task 2: Add explicit cache key invalidation for stats</name>
  <files>src/lib/cache/redis.ts</files>
  <action>
Enhance `invalidateMatchCaches` to also invalidate stats-related caches that affect leaderboard display:

Update the function (around line 340):

```typescript
/**
 * Invalidate caches when match finishes
 * Called from scoring logic AFTER transaction commits
 */
export async function invalidateMatchCaches(matchId: string): Promise<void> {
  const redis = getRedis();
  if (!redis) return;

  try {
    // Delete in parallel for speed
    await Promise.all([
      // Invalidate ALL leaderboard caches (various filter combinations)
      cacheDeletePattern('db:leaderboard:*'),

      // Invalidate overall stats
      cacheDelete(cacheKeys.overallStats()),

      // Invalidate top performing model cache
      cacheDelete(cacheKeys.topPerformingModel()),

      // Invalidate specific match predictions cache
      cacheDelete(cacheKeys.matchPredictions(matchId)),
    ]);

    loggers.cache.info({ matchId }, 'Invalidated match caches (leaderboard, stats, predictions)');
  } catch (error) {
    loggers.cache.error({
      matchId,
      error: error instanceof Error ? error.message : String(error)
    }, 'Error invalidating match caches');
  }
}
```

Also add a new function for immediate stats refresh after settlement:

```typescript
/**
 * Force refresh stats cache after settlement
 * Called after transaction commit to ensure fresh data
 */
export async function invalidateStatsCache(options?: { matchId?: string }): Promise<void> {
  const redis = getRedis();
  if (!redis) return;

  try {
    await Promise.all([
      cacheDelete(cacheKeys.overallStats()),
      cacheDelete(cacheKeys.topPerformingModel()),
      // Model-specific caches if matchId provided
      ...(options?.matchId ? [cacheDeletePattern(`db:model:*:stats`)] : []),
    ]);

    loggers.cache.debug(options || {}, 'Invalidated stats caches');
  } catch (error) {
    loggers.cache.error({
      error: error instanceof Error ? error.message : String(error),
      ...options,
    }, 'Error invalidating stats caches');
  }
}
```

Export the new function.
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit src/lib/cache/redis.ts`
2. Function enhanced: `grep "topPerformingModel" src/lib/cache/redis.ts`
  </verify>
  <done>
`invalidateMatchCaches` clears all relevant caches including leaderboard, stats, and model data
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify cache invalidation is post-transaction in worker</name>
  <files>src/lib/queue/workers/scoring.worker.ts</files>
  <action>
Verify and document that cache invalidation happens AFTER the transaction commits:

1. Add a comment block clarifying the timing requirement:

```typescript
// ========================================================
// CRITICAL: Cache invalidation timing
// ========================================================
// Cache must be invalidated ONLY after transaction commits.
// If invalidated during transaction:
//   1. Another request might refill cache with old data
//   2. Transaction could rollback, leaving stale cache
//
// Pattern: await transaction() -> await invalidateMatchCaches()
// ========================================================
```

2. Ensure the current code structure follows this pattern:
   - `scorePredictionsTransactional()` must complete (transaction committed)
   - THEN call `invalidateMatchCaches(matchId)`

3. If Plan 02-01 changed the structure, verify the pattern:
```typescript
// Score in transaction
const result = await scorePredictionsTransactional(matchId, actualHome, actualAway, quotas);

if (!result.success) {
  throw new Error(result.error);
}

// AFTER transaction: invalidate caches
await invalidateMatchCaches(matchId);
log.info(`Invalidated caches for match ${matchId}`);
```

4. Add logging to confirm cache invalidation completed:
```typescript
log.info({ matchId, scoredCount: result.scoredCount }, 'Cache invalidated after successful settlement');
```
  </action>
  <verify>
1. Comment exists: `grep "CRITICAL.*Cache invalidation" src/lib/queue/workers/scoring.worker.ts`
2. Pattern correct: `grep -A 5 "scorePredictionsTransactional" src/lib/queue/workers/scoring.worker.ts | grep "invalidateMatchCaches"`
  </verify>
  <done>
Cache invalidation is documented and verified to occur only after transaction commits
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **SCAN is used instead of KEYS:**
```bash
grep -n "\.scan(" src/lib/cache/redis.ts
grep -v "//" src/lib/cache/redis.ts | grep "\.keys(" || echo "No blocking KEYS found - good!"
```

2. **Stats caches are invalidated:**
```bash
grep "topPerformingModel\|overallStats" src/lib/cache/redis.ts
```

3. **Timing is correct:**
```bash
grep -B 3 "invalidateMatchCaches" src/lib/queue/workers/scoring.worker.ts
```

4. **Build passes:**
```bash
npm run build
```
</verification>

<success_criteria>
- `cacheDeletePattern` uses SCAN loop (not KEYS)
- `invalidateMatchCaches` clears leaderboard, stats, and model caches
- Cache invalidation happens AFTER `scorePredictionsTransactional` returns
- Code includes comments explaining timing requirement
- Build completes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-data-accuracy/02-04-SUMMARY.md`
</output>
