---
phase: 02-data-accuracy
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/queue/workers/scoring.worker.ts
  - src/lib/db/queries.ts
autonomous: true

must_haves:
  truths:
    - "All 35 predictions for a match are scored exactly once, even under concurrent settlement jobs"
    - "No prediction is scored twice when two settlement jobs run concurrently"
    - "Cache shows updated data only after all predictions are committed to database"
  artifacts:
    - path: "src/lib/queue/workers/scoring.worker.ts"
      provides: "Transaction-wrapped settlement with FOR UPDATE locking"
      contains: "for.*update"
    - path: "src/lib/db/queries.ts"
      provides: "Transactional prediction scoring function"
      exports: ["scorePredictionsTransactional"]
  key_links:
    - from: "src/lib/queue/workers/scoring.worker.ts"
      to: "src/lib/db/queries.ts"
      via: "scorePredictionsTransactional function call"
      pattern: "scorePredictionsTransactional"
    - from: "src/lib/queue/workers/scoring.worker.ts"
      to: "src/lib/cache/redis.ts"
      via: "invalidateMatchCaches called after transaction commits"
      pattern: "await.*transaction.*invalidateMatchCaches"
---

<objective>
Implement database transaction with row-level locking for prediction settlement to prevent race conditions when concurrent settlement jobs attempt to score the same match.

Purpose: Eliminate double-scoring bugs where two settlement jobs (e.g., live-score worker + backfill job) read predictions as 'pending' and both update to 'scored', causing points to be awarded twice.

Output: Transaction-safe settlement that locks prediction rows during scoring, ensuring exactly-once scoring per prediction.
</objective>

<execution_context>
@/Users/pieterbos/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pieterbos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-data-accuracy/02-RESEARCH.md

@src/lib/queue/workers/scoring.worker.ts
@src/lib/db/queries.ts
@src/lib/cache/redis.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create transactional prediction scoring function in queries.ts</name>
  <files>src/lib/db/queries.ts</files>
  <action>
Add a new function `scorePredictionsTransactional` that wraps the entire prediction scoring flow in a database transaction with FOR UPDATE locking:

1. Create the function signature:
```typescript
export async function scorePredictionsTransactional(
  matchId: string,
  actualHome: number,
  actualAway: number,
  quotas: { home: number; draw: number; away: number }
): Promise<{
  success: boolean;
  scoredCount: number;
  failedCount: number;
  error?: string;
}>
```

2. Inside the function:
   - Use `db.transaction(async (tx) => { ... })` wrapper
   - First, SELECT predictions FOR UPDATE with `.for('update')`:
     ```typescript
     const pendingPredictions = await tx
       .select()
       .from(predictions)
       .where(and(
         eq(predictions.matchId, matchId),
         eq(predictions.status, 'pending')
       ))
       .for('update');
     ```
   - If no pending predictions, return early (already scored)
   - Loop through predictions and call `calculateQuotaScores` for each
   - Update each prediction to 'scored' status within the transaction
   - Return the count of successfully scored predictions

3. Handle errors:
   - Wrap in try/catch, return `{ success: false, error: message }`
   - Transaction will auto-rollback on any exception

4. DO NOT call cache invalidation inside the transaction - caller must do this after

Note: Import `for` from drizzle-orm if needed. The Drizzle syntax is `.for('update')` appended to select query.
  </action>
  <verify>
TypeScript compiles without errors: `npx tsc --noEmit src/lib/db/queries.ts`
  </verify>
  <done>
Function `scorePredictionsTransactional` exists in queries.ts with FOR UPDATE locking inside transaction
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor scoring worker to use transactional settlement</name>
  <files>src/lib/queue/workers/scoring.worker.ts</files>
  <action>
Refactor the scoring worker to use the new transactional function:

1. Import the new function:
```typescript
import { scorePredictionsTransactional, updateModelStreak } from '@/lib/db/queries';
```

2. Replace the existing scoring loop (lines ~88-207) with a call to the transactional function:
```typescript
// Calculate quotas first (this doesn't need to be in transaction)
const quotas = calculateQuotas(predictions.map(p => ({
  predictedHome: p.predictedHome,
  predictedAway: p.predictedAway,
})));

// Step 2: Save quotas to match for display
await updateMatchQuotas(matchId, quotas.home, quotas.draw, quotas.away);

// Step 3: Score all predictions in a single transaction with row locking
const result = await scorePredictionsTransactional(
  matchId,
  actualHome,
  actualAway,
  quotas
);

if (!result.success) {
  throw new Error(result.error || 'Settlement transaction failed');
}

const scoredCount = result.scoredCount;
const failedCount = result.failedCount;
```

3. Keep streak updates AFTER the transaction (not inside):
   - After `scorePredictionsTransactional` returns successfully
   - Query the now-scored predictions to get result types
   - Call `updateModelStreak` for each model (existing code, just move it outside the main transaction)

4. Cache invalidation MUST remain AFTER transaction:
```typescript
// Only after transaction committed successfully
if (result.success && result.scoredCount > 0) {
  await invalidateMatchCaches(matchId);
  // ... rest of post-settlement logic
}
```

5. Remove the try/catch around individual prediction updates since transaction handles atomicity

6. Keep existing logging but adjust to reflect transaction-based flow
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit src/lib/queue/workers/scoring.worker.ts`
2. Worker file contains `.for('update')` or uses `scorePredictionsTransactional`
3. Cache invalidation appears AFTER transaction call (not inside)
  </verify>
  <done>
Scoring worker uses transaction with row locking for settlement, cache invalidation happens only after successful commit
  </done>
</task>

<task type="auto">
  <name>Task 3: Add streak updates within transaction for atomicity</name>
  <files>src/lib/db/queries.ts</files>
  <action>
Update the `scorePredictionsTransactional` function to also update model streaks within the same transaction:

1. Add streak update logic inside the transaction loop after scoring each prediction:
```typescript
// After updating prediction scores within transaction
const resultType: 'exact' | 'tendency' | 'wrong' =
  breakdown.total === 0 ? 'wrong' :
  breakdown.exactScoreBonus > 0 ? 'exact' : 'tendency';

// Update streak within same transaction - use updateModelStreakInTransaction
await updateModelStreakInTransaction(tx, prediction.modelId, resultType);
```

2. Create a new helper function `updateModelStreakInTransaction` that takes a transaction context:
```typescript
async function updateModelStreakInTransaction(
  tx: any, // Transaction context
  modelId: string,
  resultType: 'exact' | 'tendency' | 'wrong'
): Promise<void> {
  // Lock model row for update
  const modelResult = await tx
    .select()
    .from(models)
    .where(eq(models.id, modelId))
    .for('update')
    .limit(1);

  const model = modelResult[0];
  if (!model) return;

  // ... existing streak calculation logic from updateModelStreak ...
  // Copy the streak update logic but use `tx` instead of `db`
}
```

3. This ensures:
   - Both prediction scoring AND streak updates happen atomically
   - Model row is locked to prevent concurrent streak updates
   - If any part fails, everything rolls back

4. Keep the existing `updateModelStreak` function for backward compatibility (other callers may use it)
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit src/lib/db/queries.ts`
2. grep confirms streak update inside transaction: `grep -A 5 'updateModelStreakInTransaction' src/lib/db/queries.ts`
  </verify>
  <done>
Streak updates happen within the same transaction as prediction scoring, with row-level locking on model table
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Transaction structure verified:**
```bash
grep -n "for.*'update'" src/lib/db/queries.ts
grep -n "transaction" src/lib/queue/workers/scoring.worker.ts
```

2. **Cache invalidation timing verified:**
```bash
grep -B5 -A5 "invalidateMatchCaches" src/lib/queue/workers/scoring.worker.ts
# Should show it's AFTER the transaction call, not inside
```

3. **Build passes:**
```bash
npm run build
```
</verification>

<success_criteria>
- `scorePredictionsTransactional` function uses `db.transaction()` with `.for('update')` on prediction select
- Scoring worker calls this function instead of individual updates
- Cache invalidation (`invalidateMatchCaches`) is called only after transaction commits
- Model streak updates use FOR UPDATE lock on models table within same transaction
- Build completes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-data-accuracy/02-01-SUMMARY.md`
</output>
